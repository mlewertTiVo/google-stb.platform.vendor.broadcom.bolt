#!/usr/bin/perl -w
# ***************************************************************************
# Broadcom Proprietary and Confidential. (c)2016 Broadcom. All rights reserved.
# *
# *  THIS SOFTWARE MAY ONLY BE USED SUBJECT TO AN EXECUTED SOFTWARE LICENSE
# *  AGREEMENT  BETWEEN THE USER AND BROADCOM.  YOU HAVE NO RIGHT TO USE OR
# *  EXPLOIT THIS MATERIAL EXCEPT SUBJECT TO THE TERMS OF SUCH AN AGREEMENT.
# *
# ***************************************************************************
use strict;
use warnings FATAL=>q(all);
use Data::Dumper;
use File::Spec;
use File::Basename;
use Getopt::Std;
use lib dirname(File::Spec->rel2abs(__FILE__));
use BcmUtils;
use Cwd qw(abs_path);

my $P = basename $0;

sub generate_pmap_h_file {
	my ($cpupmaps, $chp, $ver) = @_;
	my $fh;
	$ver = lc $ver;

	my $loc = abs_path($0);
	$loc =~ s/\/[^\/]+\.pl$//g;
	$loc = "$loc/../include/$chp$ver/";

	if (-d $loc) {
		open($fh, ">$loc/pmap.h") or
		die "Can't open output file pmap.h";
	}
	else {
		printf $fh "Couldn't open $loc";
		exit(-1);
	}

	my @lines = BcmUtils::create_copyright_header("h");
	print $fh @lines;

	print $fh "/***************************************************************************\n";
	print $fh "*\n";
	print $fh "* This file is generated by generate_pmap_file.pl for supporting platforms.\n";
	print $fh "*\n";
	print $fh "* This file contains a list of PMAPs and the corresponding register settings\n";
	print $fh "*\n";
	print $fh "***************************************************************************/\n";
	print $fh "\n";
	print $fh "#ifndef BCHP_PMAP_PRIV_H__\n";
	print $fh "#define BCHP_PMAP_PRIV_H__\n";
	print $fh "\n";
	print $fh "/* Private power resource IDs */\n";

	my @maxkey = sort keys %$cpupmaps;
	my @array = @{$cpupmaps}{@maxkey};

	print $fh "enum pmaps {\n";
	foreach (sort keys %$cpupmaps) {
		print $fh "\t$_\,\n";
	}
	print $fh "\tPMapMax\,\n";
	print $fh "\} pmaps\;\n";

	print $fh "\nstruct pmapParameters {\n";
	print $fh "\tuint16_t ndiv_int;\n";
	print $fh "\tuint8_t pdiv;\n";
	print $fh "\tuint8_t mdiv_p0;\n";
	print $fh "\tuint8_t mdiv_p1;\n";
	print $fh "\tuint8_t mdiv_p2;\n";
	print $fh "\tuint8_t mdiv_p3;\n";
	print $fh "\tuint8_t mdiv_p4;\n";
	print $fh "\} pmapParameters\;\n";

	print $fh "\n#ifndef AVS_ONCE";
	print $fh "\n#define AVS_ONCE\n";
	print $fh "static const struct pmapParameters pmapTable[PMapMax] = {\n";

	foreach (sort keys %$cpupmaps) {
		if (exists $cpupmaps->{$_}{ndiv_int}) {
			print $fh "\t\{$cpupmaps->{$_}{ndiv_int}";
		}
		if (exists $cpupmaps->{$_}{pdiv}) {
			print $fh "\,\t$cpupmaps->{$_}{pdiv}";
		}
		if (exists $cpupmaps->{$_}{mdiv_p0}) {
			print $fh "\,\t$cpupmaps->{$_}{mdiv_p0}";
		}
		if (exists $cpupmaps->{$_}{mdiv_p1}) {
			print $fh "\,\t$cpupmaps->{$_}{mdiv_p1}";
		}
		if (exists $cpupmaps->{$_}{mdiv_p2}) {
			print $fh "\,\t$cpupmaps->{$_}{mdiv_p2}";
		}
		if (exists $cpupmaps->{$_}{mdiv_p3}) {
			print $fh "\,\t$cpupmaps->{$_}{mdiv_p3}";
		}
		if (exists $cpupmaps->{$_}{mdiv_p4}) {
			print $fh "\,\t$cpupmaps->{$_}{mdiv_p4}";
		}
		if (exists $cpupmaps->{$_}{mdiv_p5}) {
			print $fh "\t$cpupmaps->{$_}{mdiv_p5}\,";
		}
		print $fh "}\,\n"
	}
	print $fh "\}\;\n";

	print $fh "#endif\n";
	print $fh "\n#endif\n";

	close($fh);
}

sub parse_clkgen_rdb_file {
	my ($file, $hash_map) = @_;
	my ($reg, $field, $resource, $default, $case);
	my $coreprefix;

	open(INFILE,"$file") or die "Can't open input file $file";

	if($file =~ /\/design\/(.*?)\/rdb\//) {
		$coreprefix = uc($1);
	}
	$coreprefix =~ s/SYS_CTRL/SUN_TOP_CTRL/;

	foreach (<INFILE>) {
		s/\r\n/\n/;	# convert DOS to Unix
		s/^\s+//;	# Remove whitespace at beginning of line
		s/\s+$//;	# Remove whitespace at end of line
		s/"//g;

		if (/^coreprefix\s*(\w+)/) {
			$coreprefix = $1;
		} elsif (/^regtype32\s*(\w+)/) {
			$reg = $1;

			$reg =~ s/Type/$coreprefix/;

			$case = "";
		} elsif (/^field\s*(\w+)/) {
			$field = $1;
			$resource = $reg."_".$field;

			if($case ne "") {
				$field = $case."_".$field;
			}
		} elsif (/^\/\/PMPState:\s*CPU:/) {
			my @temp = split(' ', $_);
			foreach (@temp){
				if($field =~ /MDIV_CH0/) {
					if(/CPU:PMap\s*(\d+):(.*?)(\d+):(\d+)/){
						$hash_map->{"PMap".$1}{"mdiv_p".$3} = $4;
					}
				}
				if($field =~ /NDIV_INT/) {
					if(/CPU:PMap\s*(\d+):(.*?)(\d+):(\d+)/){
						$hash_map->{"PMap".$1}{ndiv_int} = $4;
					}
				}
			}
		}
		elsif (/^\/\/PMPowerProfile:\s*CPU\s*:\s*(.*?)\s*:\s*PMap(\d+)/) {
			push( @{ $hash_map->{"PMap".$2}{powerprofiles} }, $1);
		}
	}
	foreach (keys %$hash_map) {
		$hash_map->{$_}{pdiv} = 3;
	}
	close(INFILE);
}

sub usage($$)
{
	my ($p, $e) = @_;

	print "err: " . $e . "\n";
	print "usage: $p [options]\n";
	print " -f <chip family>\n";
	print " -v <chip version>\n";
	print " <The output file pmap.h is created in ../include/family_version/>\n";
	exit(-22); # Invalid argument
}

sub main {
	my %cpupmaps;
	my ($arg_family, $arg_version, $dir);
	my %cmdflags=();

	getopts("hf:v:", \%cmdflags) or
		usage($P,"bad options");

	usage($P, "none")
		if (defined $cmdflags{h});

	$arg_family = $cmdflags{f}
		if (defined $cmdflags{f});

	usage($P, "Family is required")
		if (!defined $arg_family);

	$arg_version = $cmdflags{v}
		if (defined $cmdflags{v});

	usage($P, "Chip version is required")
		if (!defined $arg_version);

	$dir = "/projects/BCM".$arg_family."/".$arg_version."/snapshot";

	print "\n\n";
	print "Processing clock gen rdb\n";
	print "Chip Family	: $arg_family\n";
	print "Version		: $arg_version\n";
	print "Using RDB $dir\n";
	print"\n\n";

	parse_clkgen_rdb_file($dir."/design/clkgen/rdb/clkgen.rdb", \%cpupmaps);

	generate_pmap_h_file(\%cpupmaps, $arg_family, $arg_version);

	return 0;
}

exit main();

