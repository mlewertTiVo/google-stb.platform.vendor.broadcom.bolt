--- zlib-1.1.3/adler32.c	1998-02-02 09:12:35.000000000 -0500
+++ zlib-1.1.3/adler32.c	2014-02-07 11:53:21.349326823 -0500
@@ -3,7 +3,7 @@
  * For conditions of distribution and use, see copyright notice in zlib.h 
  */
 
-/* @(#) $Id$ */
+/* @(#) $Id: adler32.c,v 1.1 2001/11/09 01:48:01 mpl Exp $ */
 
 #include "zlib.h"
 
@@ -19,15 +19,16 @@
 
 /* ========================================================================= */
 uLong ZEXPORT adler32(adler, buf, len)
-    uLong adler;
-    const Bytef *buf;
-    uInt len;
+uLong adler;
+const Bytef *buf;
+uInt len;
 {
     unsigned long s1 = adler & 0xffff;
     unsigned long s2 = (adler >> 16) & 0xffff;
     int k;
 
-    if (buf == Z_NULL) return 1L;
+	if (buf == Z_NULL)
+		return 1L;
 
     while (len > 0) {
         k = len < NMAX ? len : NMAX;
@@ -37,7 +38,8 @@
 	    buf += 16;
             k -= 16;
         }
-        if (k != 0) do {
+		if (k != 0)
+			do {
             s1 += *buf++;
 	    s2 += s1;
         } while (--k);
--- zlib-1.1.3/compress.c	1998-02-02 09:12:36.000000000 -0500
+++ zlib-1.1.3/compress.c	2014-02-07 11:53:21.349326823 -0500
@@ -3,7 +3,7 @@
  * For conditions of distribution and use, see copyright notice in zlib.h 
  */
 
-/* @(#) $Id$ */
+/* @(#) $Id: compress.c,v 1.1 2001/11/09 01:48:01 mpl Exp $ */
 
 #include "zlib.h"
 
@@ -18,32 +18,35 @@
    memory, Z_BUF_ERROR if there was not enough room in the output buffer,
    Z_STREAM_ERROR if the level parameter is invalid.
 */
-int ZEXPORT compress2 (dest, destLen, source, sourceLen, level)
-    Bytef *dest;
-    uLongf *destLen;
-    const Bytef *source;
-    uLong sourceLen;
-    int level;
+int ZEXPORT compress2(dest, destLen, source, sourceLen, level)
+Bytef *dest;
+uLongf *destLen;
+const Bytef *source;
+uLong sourceLen;
+int level;
 {
     z_stream stream;
     int err;
 
-    stream.next_in = (Bytef*)source;
-    stream.avail_in = (uInt)sourceLen;
+	stream.next_in = (Bytef *) source;
+	stream.avail_in = (uInt) sourceLen;
 #ifdef MAXSEG_64K
     /* Check for source > 64K on 16-bit machine: */
-    if ((uLong)stream.avail_in != sourceLen) return Z_BUF_ERROR;
+	if ((uLong) stream.avail_in != sourceLen)
+		return Z_BUF_ERROR;
 #endif
     stream.next_out = dest;
-    stream.avail_out = (uInt)*destLen;
-    if ((uLong)stream.avail_out != *destLen) return Z_BUF_ERROR;
-
-    stream.zalloc = (alloc_func)0;
-    stream.zfree = (free_func)0;
-    stream.opaque = (voidpf)0;
+	stream.avail_out = (uInt) * destLen;
+	if ((uLong) stream.avail_out != *destLen)
+		return Z_BUF_ERROR;
+
+	stream.zalloc = (alloc_func) 0;
+	stream.zfree = (free_func) 0;
+	stream.opaque = (voidpf) 0;
 
     err = deflateInit(&stream, level);
-    if (err != Z_OK) return err;
+	if (err != Z_OK)
+		return err;
 
     err = deflate(&stream, Z_FINISH);
     if (err != Z_STREAM_END) {
@@ -58,11 +61,12 @@
 
 /* ===========================================================================
  */
-int ZEXPORT compress (dest, destLen, source, sourceLen)
-    Bytef *dest;
-    uLongf *destLen;
-    const Bytef *source;
-    uLong sourceLen;
+int ZEXPORT compress(dest, destLen, source, sourceLen)
+Bytef *dest;
+uLongf *destLen;
+const Bytef *source;
+uLong sourceLen;
 {
-    return compress2(dest, destLen, source, sourceLen, Z_DEFAULT_COMPRESSION);
+	return compress2(dest, destLen, source, sourceLen,
+			 Z_DEFAULT_COMPRESSION);
 }
--- zlib-1.1.3/crc32.c	1998-02-02 09:12:36.000000000 -0500
+++ zlib-1.1.3/crc32.c	2014-02-07 11:53:21.349326823 -0500
@@ -3,7 +3,7 @@
  * For conditions of distribution and use, see copyright notice in zlib.h 
  */
 
-/* @(#) $Id$ */
+/* @(#) $Id: crc32.c,v 1.1 2001/11/09 01:48:01 mpl Exp $ */
 
 #include "zlib.h"
 
@@ -45,16 +45,16 @@
   int n, k;
   uLong poly;            /* polynomial exclusive-or pattern */
   /* terms of polynomial defining this crc (except x^32): */
-  static const Byte p[] = {0,1,2,4,5,7,8,10,11,12,16,22,23,26};
+	static const Byte p[] =
+	    { 0, 1, 2, 4, 5, 7, 8, 10, 11, 12, 16, 22, 23, 26 };
 
   /* make exclusive-or pattern from polynomial (0xedb88320L) */
   poly = 0L;
-  for (n = 0; n < sizeof(p)/sizeof(Byte); n++)
+	for (n = 0; n < sizeof(p) / sizeof(Byte); n++)
     poly |= 1L << (31 - p[n]);
  
-  for (n = 0; n < 256; n++)
-  {
-    c = (uLong)n;
+	for (n = 0; n < 256; n++) {
+		c = (uLong) n;
     for (k = 0; k < 8; k++)
       c = c & 1 ? poly ^ (c >> 1) : c >> 1;
     crc_table[n] = c;
@@ -124,10 +124,11 @@
 /* =========================================================================
  * This function can be used by asm versions of crc32()
  */
-const uLongf * ZEXPORT get_crc_table()
+const uLongf *ZEXPORT get_crc_table()
 {
 #ifdef DYNAMIC_CRC_TABLE
-  if (crc_table_empty) make_crc_table();
+	if (crc_table_empty)
+		make_crc_table();
 #endif
   return (const uLongf *)crc_table;
 }
@@ -140,22 +141,23 @@
 
 /* ========================================================================= */
 uLong ZEXPORT crc32(crc, buf, len)
-    uLong crc;
-    const Bytef *buf;
-    uInt len;
+uLong crc;
+const Bytef *buf;
+uInt len;
 {
-    if (buf == Z_NULL) return 0L;
+	if (buf == Z_NULL)
+		return 0L;
 #ifdef DYNAMIC_CRC_TABLE
     if (crc_table_empty)
       make_crc_table();
 #endif
     crc = crc ^ 0xffffffffL;
-    while (len >= 8)
-    {
+	while (len >= 8) {
       DO8(buf);
       len -= 8;
     }
-    if (len) do {
+	if (len)
+		do {
       DO1(buf);
     } while (--len);
     return crc ^ 0xffffffffL;
--- zlib-1.1.3/deflate.c	1998-07-09 12:06:12.000000000 -0400
+++ zlib-1.1.3/deflate.c	2014-02-07 11:53:21.349326823 -0500
@@ -47,7 +47,7 @@
  *
  */
 
-/* @(#) $Id$ */
+/* @(#) $Id: deflate.c,v 1.1 2001/11/09 01:48:02 mpl Exp $ */
 
 #include "deflate.h"
 
@@ -70,26 +70,26 @@
     finish_done     /* finish done, accept no more input or output */
 } block_state;
 
-typedef block_state (*compress_func) OF((deflate_state *s, int flush));
+typedef block_state(*compress_func) OF((deflate_state * s, int flush));
 /* Compression function. Returns the block state after the call. */
 
-local void fill_window    OF((deflate_state *s));
-local block_state deflate_stored OF((deflate_state *s, int flush));
-local block_state deflate_fast   OF((deflate_state *s, int flush));
-local block_state deflate_slow   OF((deflate_state *s, int flush));
-local void lm_init        OF((deflate_state *s));
-local void putShortMSB    OF((deflate_state *s, uInt b));
+local void fill_window OF((deflate_state * s));
+local block_state deflate_stored OF((deflate_state * s, int flush));
+local block_state deflate_fast OF((deflate_state * s, int flush));
+local block_state deflate_slow OF((deflate_state * s, int flush));
+local void lm_init OF((deflate_state * s));
+local void putShortMSB OF((deflate_state * s, uInt b));
 local void flush_pending  OF((z_streamp strm));
-local int read_buf        OF((z_streamp strm, Bytef *buf, unsigned size));
+local int read_buf OF((z_streamp strm, Bytef * buf, unsigned size));
 #ifdef ASMV
-      void match_init OF((void)); /* asm code initialization */
-      uInt longest_match  OF((deflate_state *s, IPos cur_match));
+void match_init OF((void));	/* asm code initialization */
+uInt longest_match OF((deflate_state * s, IPos cur_match));
 #else
-local uInt longest_match  OF((deflate_state *s, IPos cur_match));
+local uInt longest_match OF((deflate_state * s, IPos cur_match));
 #endif
 
 #ifdef DEBUG
-local  void check_match OF((deflate_state *s, IPos start, IPos match,
+local void check_match OF((deflate_state * s, IPos start, IPos match,
                             int length));
 #endif
 
@@ -101,7 +101,7 @@
 /* Tail of hash chains */
 
 #ifndef TOO_FAR
-#  define TOO_FAR 4096
+#define TOO_FAR 4096
 #endif
 /* Matches of length 3 are discarded if their distance exceeds TOO_FAR */
 
@@ -125,17 +125,21 @@
 
 local const config configuration_table[10] = {
 /*      good lazy nice chain */
-/* 0 */ {0,    0,  0,    0, deflate_stored},  /* store only */
-/* 1 */ {4,    4,  8,    4, deflate_fast}, /* maximum speed, no lazy matches */
+	/* 0 */ {0, 0, 0, 0, deflate_stored},
+	/* store only */
+	/* 1 */ {4, 4, 8, 4, deflate_fast},
+	/* maximum speed, no lazy matches */
 /* 2 */ {4,    5, 16,    8, deflate_fast},
 /* 3 */ {4,    6, 32,   32, deflate_fast},
 
-/* 4 */ {4,    4, 16,   16, deflate_slow},  /* lazy matches */
+	/* 4 */ {4, 4, 16, 16, deflate_slow},
+	/* lazy matches */
 /* 5 */ {8,   16, 32,   32, deflate_slow},
 /* 6 */ {8,   16, 128, 128, deflate_slow},
 /* 7 */ {8,   32, 128, 256, deflate_slow},
 /* 8 */ {32, 128, 258, 1024, deflate_slow},
-/* 9 */ {32, 258, 258, 4096, deflate_slow}}; /* maximum compression */
+/* 9 */ {32, 258, 258, 4096, deflate_slow}
+};				/* maximum compression */
 
 /* Note: the deflate() code requires max_lazy >= MIN_MATCH and max_chain >= 4
  * For deflate_fast() (levels <= 3) good is ignored and lazy has a different
@@ -145,7 +149,9 @@
 #define EQUAL 0
 /* result of memcmp for equal strings */
 
-struct static_tree_desc_s {int dummy;}; /* for buggy compilers */
+struct static_tree_desc_s {
+	int dummy;
+};				/* for buggy compilers */
 
 /* ===========================================================================
  * Update a hash value with the given input byte
@@ -188,10 +193,10 @@
 
 /* ========================================================================= */
 int ZEXPORT deflateInit_(strm, level, version, stream_size)
-    z_streamp strm;
-    int level;
-    const char *version;
-    int stream_size;
+z_streamp strm;
+int level;
+const char *version;
+int stream_size;
 {
     return deflateInit2_(strm, level, Z_DEFLATED, MAX_WBITS, DEF_MEM_LEVEL,
 			 Z_DEFAULT_STRATEGY, version, stream_size);
@@ -201,18 +206,18 @@
 /* ========================================================================= */
 int ZEXPORT deflateInit2_(strm, level, method, windowBits, memLevel, strategy,
 		  version, stream_size)
-    z_streamp strm;
-    int  level;
-    int  method;
-    int  windowBits;
-    int  memLevel;
-    int  strategy;
-    const char *version;
-    int stream_size;
+z_streamp strm;
+int level;
+int method;
+int windowBits;
+int memLevel;
+int strategy;
+const char *version;
+int stream_size;
 {
     deflate_state *s;
     int noheader = 0;
-    static const char* my_version = ZLIB_VERSION;
+	static const char *my_version = ZLIB_VERSION;
 
     ushf *overlay;
     /* We overlay pending_buf and d_buf+l_buf. This works since the average
@@ -223,16 +228,19 @@
         stream_size != sizeof(z_stream)) {
 	return Z_VERSION_ERROR;
     }
-    if (strm == Z_NULL) return Z_STREAM_ERROR;
+	if (strm == Z_NULL)
+		return Z_STREAM_ERROR;
 
     strm->msg = Z_NULL;
     if (strm->zalloc == Z_NULL) {
 	strm->zalloc = zcalloc;
-	strm->opaque = (voidpf)0;
+		strm->opaque = (voidpf) 0;
     }
-    if (strm->zfree == Z_NULL) strm->zfree = zcfree;
+	if (strm->zfree == Z_NULL)
+		strm->zfree = zcfree;
 
-    if (level == Z_DEFAULT_COMPRESSION) level = 6;
+	if (level == Z_DEFAULT_COMPRESSION)
+		level = 6;
 #ifdef FASTEST
     level = 1;
 #endif
@@ -247,7 +255,8 @@
         return Z_STREAM_ERROR;
     }
     s = (deflate_state *) ZALLOC(strm, 1, sizeof(deflate_state));
-    if (s == Z_NULL) return Z_MEM_ERROR;
+	if (s == Z_NULL)
+		return Z_MEM_ERROR;
     strm->state = (struct internal_state FAR *)s;
     s->strm = strm;
 
@@ -259,39 +268,39 @@
     s->hash_bits = memLevel + 7;
     s->hash_size = 1 << s->hash_bits;
     s->hash_mask = s->hash_size - 1;
-    s->hash_shift =  ((s->hash_bits+MIN_MATCH-1)/MIN_MATCH);
+	s->hash_shift = ((s->hash_bits + MIN_MATCH - 1) / MIN_MATCH);
 
-    s->window = (Bytef *) ZALLOC(strm, s->w_size, 2*sizeof(Byte));
+	s->window = (Bytef *) ZALLOC(strm, s->w_size, 2 * sizeof(Byte));
     s->prev   = (Posf *)  ZALLOC(strm, s->w_size, sizeof(Pos));
     s->head   = (Posf *)  ZALLOC(strm, s->hash_size, sizeof(Pos));
 
     s->lit_bufsize = 1 << (memLevel + 6); /* 16K elements by default */
 
-    overlay = (ushf *) ZALLOC(strm, s->lit_bufsize, sizeof(ush)+2);
+	overlay = (ushf *) ZALLOC(strm, s->lit_bufsize, sizeof(ush) + 2);
     s->pending_buf = (uchf *) overlay;
-    s->pending_buf_size = (ulg)s->lit_bufsize * (sizeof(ush)+2L);
+	s->pending_buf_size = (ulg) s->lit_bufsize * (sizeof(ush) + 2L);
 
     if (s->window == Z_NULL || s->prev == Z_NULL || s->head == Z_NULL ||
         s->pending_buf == Z_NULL) {
-        strm->msg = (char*)ERR_MSG(Z_MEM_ERROR);
-        deflateEnd (strm);
+		strm->msg = (char *)ERR_MSG(Z_MEM_ERROR);
+		deflateEnd(strm);
         return Z_MEM_ERROR;
     }
-    s->d_buf = overlay + s->lit_bufsize/sizeof(ush);
-    s->l_buf = s->pending_buf + (1+sizeof(ush))*s->lit_bufsize;
+	s->d_buf = overlay + s->lit_bufsize / sizeof(ush);
+	s->l_buf = s->pending_buf + (1 + sizeof(ush)) * s->lit_bufsize;
 
     s->level = level;
     s->strategy = strategy;
-    s->method = (Byte)method;
+	s->method = (Byte) method;
 
     return deflateReset(strm);
 }
 
 /* ========================================================================= */
-int ZEXPORT deflateSetDictionary (strm, dictionary, dictLength)
-    z_streamp strm;
-    const Bytef *dictionary;
-    uInt  dictLength;
+int ZEXPORT deflateSetDictionary(strm, dictionary, dictLength)
+z_streamp strm;
+const Bytef *dictionary;
+uInt dictLength;
 {
     deflate_state *s;
     uInt length = dictLength;
@@ -299,12 +308,14 @@
     IPos hash_head = 0;
 
     if (strm == Z_NULL || strm->state == Z_NULL || dictionary == Z_NULL ||
-        strm->state->status != INIT_STATE) return Z_STREAM_ERROR;
+	    strm->state->status != INIT_STATE)
+		return Z_STREAM_ERROR;
 
     s = strm->state;
     strm->adler = adler32(strm->adler, dictionary, dictLength);
 
-    if (length < MIN_MATCH) return Z_OK;
+	if (length < MIN_MATCH)
+		return Z_OK;
     if (length > MAX_DIST(s)) {
 	length = MAX_DIST(s);
 #ifndef USE_DICT_HEAD
@@ -324,24 +335,26 @@
     for (n = 0; n <= length - MIN_MATCH; n++) {
 	INSERT_STRING(s, n, hash_head);
     }
-    if (hash_head) hash_head = 0;  /* to make compiler happy */
+	if (hash_head)
+		hash_head = 0;	/* to make compiler happy */
     return Z_OK;
 }
 
 /* ========================================================================= */
-int ZEXPORT deflateReset (strm)
-    z_streamp strm;
+int ZEXPORT deflateReset(strm)
+z_streamp strm;
 {
     deflate_state *s;
     
     if (strm == Z_NULL || strm->state == Z_NULL ||
-        strm->zalloc == Z_NULL || strm->zfree == Z_NULL) return Z_STREAM_ERROR;
+	    strm->zalloc == Z_NULL || strm->zfree == Z_NULL)
+		return Z_STREAM_ERROR;
 
     strm->total_in = strm->total_out = 0;
     strm->msg = Z_NULL; /* use zfree if we ever allocate msg dynamically */
     strm->data_type = Z_UNKNOWN;
 
-    s = (deflate_state *)strm->state;
+	s = (deflate_state *) strm->state;
     s->pending = 0;
     s->pending_out = s->pending_buf;
 
@@ -360,15 +373,16 @@
 
 /* ========================================================================= */
 int ZEXPORT deflateParams(strm, level, strategy)
-    z_streamp strm;
-    int level;
-    int strategy;
+z_streamp strm;
+int level;
+int strategy;
 {
     deflate_state *s;
     compress_func func;
     int err = Z_OK;
 
-    if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;
+	if (strm == Z_NULL || strm->state == Z_NULL)
+		return Z_STREAM_ERROR;
     s = strm->state;
 
     if (level == Z_DEFAULT_COMPRESSION) {
@@ -399,12 +413,12 @@
  * IN assertion: the stream state is correct and there is enough room in
  * pending_buf.
  */
-local void putShortMSB (s, b)
-    deflate_state *s;
-    uInt b;
+local void putShortMSB(s, b)
+deflate_state *s;
+uInt b;
 {
-    put_byte(s, (Byte)(b >> 8));
-    put_byte(s, (Byte)(b & 0xff));
+	put_byte(s, (Byte) (b >> 8));
+	put_byte(s, (Byte) (b & 0xff));
 }   
 
 /* =========================================================================
@@ -414,12 +428,14 @@
  * (See also read_buf()).
  */
 local void flush_pending(strm)
-    z_streamp strm;
+z_streamp strm;
 {
     unsigned len = strm->state->pending;
 
-    if (len > strm->avail_out) len = strm->avail_out;
-    if (len == 0) return;
+	if (len > strm->avail_out)
+		len = strm->avail_out;
+	if (len == 0)
+		return;
 
     zmemcpy(strm->next_out, strm->state->pending_out, len);
     strm->next_out  += len;
@@ -433,9 +449,9 @@
 }
 
 /* ========================================================================= */
-int ZEXPORT deflate (strm, flush)
-    z_streamp strm;
-    int flush;
+int ZEXPORT deflate(strm, flush)
+z_streamp strm;
+int flush;
 {
     int old_flush; /* value of flush param for previous deflate call */
     deflate_state *s;
@@ -451,7 +467,8 @@
 	(s->status == FINISH_STATE && flush != Z_FINISH)) {
         ERR_RETURN(strm, Z_STREAM_ERROR);
     }
-    if (strm->avail_out == 0) ERR_RETURN(strm, Z_BUF_ERROR);
+	if (strm->avail_out == 0)
+		ERR_RETURN(strm, Z_BUF_ERROR);
 
     s->strm = strm; /* just in case */
     old_flush = s->last_flush;
@@ -460,12 +477,14 @@
     /* Write the zlib header */
     if (s->status == INIT_STATE) {
 
-        uInt header = (Z_DEFLATED + ((s->w_bits-8)<<4)) << 8;
-        uInt level_flags = (s->level-1) >> 1;
+		uInt header = (Z_DEFLATED + ((s->w_bits - 8) << 4)) << 8;
+		uInt level_flags = (s->level - 1) >> 1;
 
-        if (level_flags > 3) level_flags = 3;
+		if (level_flags > 3)
+			level_flags = 3;
         header |= (level_flags << 6);
-	if (s->strstart != 0) header |= PRESET_DICT;
+		if (s->strstart != 0)
+			header |= PRESET_DICT;
         header += 31 - (header % 31);
 
         s->status = BUSY_STATE;
@@ -473,8 +492,8 @@
 
 	/* Save the adler32 of the preset dictionary: */
 	if (s->strstart != 0) {
-	    putShortMSB(s, (uInt)(strm->adler >> 16));
-	    putShortMSB(s, (uInt)(strm->adler & 0xffff));
+			putShortMSB(s, (uInt) (strm->adler >> 16));
+			putShortMSB(s, (uInt) (strm->adler & 0xffff));
 	}
 	strm->adler = 1L;
     }
@@ -513,7 +532,7 @@
         (flush != Z_NO_FLUSH && s->status != FINISH_STATE)) {
         block_state bstate;
 
-	bstate = (*(configuration_table[s->level].func))(s, flush);
+		bstate = (*(configuration_table[s->level].func)) (s, flush);
 
         if (bstate == finish_started || bstate == finish_done) {
             s->status = FINISH_STATE;
@@ -535,7 +554,7 @@
             if (flush == Z_PARTIAL_FLUSH) {
                 _tr_align(s);
             } else { /* FULL_FLUSH or SYNC_FLUSH */
-                _tr_stored_block(s, (char*)0, 0L, 0);
+				_tr_stored_block(s, (char *)0, 0L, 0);
                 /* For a full flush, this empty block will be recognized
                  * as a special marker by inflate_sync().
                  */
@@ -552,12 +571,14 @@
     }
     Assert(strm->avail_out > 0, "bug2");
 
-    if (flush != Z_FINISH) return Z_OK;
-    if (s->noheader) return Z_STREAM_END;
+	if (flush != Z_FINISH)
+		return Z_OK;
+	if (s->noheader)
+		return Z_STREAM_END;
 
     /* Write the zlib trailer (adler32) */
-    putShortMSB(s, (uInt)(strm->adler >> 16));
-    putShortMSB(s, (uInt)(strm->adler & 0xffff));
+	putShortMSB(s, (uInt) (strm->adler >> 16));
+	putShortMSB(s, (uInt) (strm->adler & 0xffff));
     flush_pending(strm);
     /* If avail_out is zero, the application will call deflate again
      * to flush the rest.
@@ -567,12 +588,13 @@
 }
 
 /* ========================================================================= */
-int ZEXPORT deflateEnd (strm)
-    z_streamp strm;
+int ZEXPORT deflateEnd(strm)
+z_streamp strm;
 {
     int status;
 
-    if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;
+	if (strm == Z_NULL || strm->state == Z_NULL)
+		return Z_STREAM_ERROR;
 
     status = strm->state->status;
     if (status != INIT_STATE && status != BUSY_STATE &&
@@ -597,9 +619,9 @@
  * To simplify the source, this is not supported for 16-bit MSDOS (which
  * doesn't have enough memory anyway to duplicate compression states).
  */
-int ZEXPORT deflateCopy (dest, source)
-    z_streamp dest;
-    z_streamp source;
+int ZEXPORT deflateCopy(dest, source)
+z_streamp dest;
+z_streamp source;
 {
 #ifdef MAXSEG_64K
     return Z_STREAM_ERROR;
@@ -618,31 +639,34 @@
     *dest = *source;
 
     ds = (deflate_state *) ZALLOC(dest, 1, sizeof(deflate_state));
-    if (ds == Z_NULL) return Z_MEM_ERROR;
-    dest->state = (struct internal_state FAR *) ds;
+	if (ds == Z_NULL)
+		return Z_MEM_ERROR;
+	dest->state = (struct internal_state FAR *)ds;
     *ds = *ss;
     ds->strm = dest;
 
-    ds->window = (Bytef *) ZALLOC(dest, ds->w_size, 2*sizeof(Byte));
+	ds->window = (Bytef *) ZALLOC(dest, ds->w_size, 2 * sizeof(Byte));
     ds->prev   = (Posf *)  ZALLOC(dest, ds->w_size, sizeof(Pos));
     ds->head   = (Posf *)  ZALLOC(dest, ds->hash_size, sizeof(Pos));
-    overlay = (ushf *) ZALLOC(dest, ds->lit_bufsize, sizeof(ush)+2);
+	overlay = (ushf *) ZALLOC(dest, ds->lit_bufsize, sizeof(ush) + 2);
     ds->pending_buf = (uchf *) overlay;
 
     if (ds->window == Z_NULL || ds->prev == Z_NULL || ds->head == Z_NULL ||
         ds->pending_buf == Z_NULL) {
-        deflateEnd (dest);
+		deflateEnd(dest);
         return Z_MEM_ERROR;
     }
     /* following zmemcpy do not work for 16-bit MSDOS */
     zmemcpy(ds->window, ss->window, ds->w_size * 2 * sizeof(Byte));
-    zmemcpy(ds->prev, ss->prev, ds->w_size * sizeof(Pos));
-    zmemcpy(ds->head, ss->head, ds->hash_size * sizeof(Pos));
-    zmemcpy(ds->pending_buf, ss->pending_buf, (uInt)ds->pending_buf_size);
+	zmemcpy((Bytef *) ds->prev, (const Bytef *)ss->prev,
+		ds->w_size * sizeof(Pos));
+	zmemcpy((Bytef *) ds->head, (const Bytef *)ss->head,
+		ds->hash_size * sizeof(Pos));
+	zmemcpy(ds->pending_buf, ss->pending_buf, (uInt) ds->pending_buf_size);
 
     ds->pending_out = ds->pending_buf + (ss->pending_out - ss->pending_buf);
-    ds->d_buf = overlay + ds->lit_bufsize/sizeof(ush);
-    ds->l_buf = ds->pending_buf + (1+sizeof(ush))*ds->lit_bufsize;
+	ds->d_buf = overlay + ds->lit_bufsize / sizeof(ush);
+	ds->l_buf = ds->pending_buf + (1 + sizeof(ush)) * ds->lit_bufsize;
 
     ds->l_desc.dyn_tree = ds->dyn_ltree;
     ds->d_desc.dyn_tree = ds->dyn_dtree;
@@ -660,14 +684,16 @@
  * (See also flush_pending()).
  */
 local int read_buf(strm, buf, size)
-    z_streamp strm;
-    Bytef *buf;
-    unsigned size;
+z_streamp strm;
+Bytef *buf;
+unsigned size;
 {
     unsigned len = strm->avail_in;
 
-    if (len > size) len = size;
-    if (len == 0) return 0;
+	if (len > size)
+		len = size;
+	if (len == 0)
+		return 0;
 
     strm->avail_in  -= len;
 
@@ -684,10 +710,10 @@
 /* ===========================================================================
  * Initialize the "longest match" routines for a new zlib stream
  */
-local void lm_init (s)
-    deflate_state *s;
+local void lm_init(s)
+deflate_state *s;
 {
-    s->window_size = (ulg)2L*s->w_size;
+	s->window_size = (ulg) 2L *s->w_size;
 
     CLEAR_HASH(s);
 
@@ -701,7 +727,7 @@
     s->strstart = 0;
     s->block_start = 0L;
     s->lookahead = 0;
-    s->match_length = s->prev_length = MIN_MATCH-1;
+	s->match_length = s->prev_length = MIN_MATCH - 1;
     s->match_available = 0;
     s->ins_h = 0;
 #ifdef ASMV
@@ -724,17 +750,17 @@
  */
 #ifndef FASTEST
 local uInt longest_match(s, cur_match)
-    deflate_state *s;
-    IPos cur_match;                             /* current match */
+deflate_state *s;
+IPos cur_match;			/* current match */
 {
-    unsigned chain_length = s->max_chain_length;/* max hash chain length */
+	unsigned chain_length = s->max_chain_length;	/* max hash chain length */
     register Bytef *scan = s->window + s->strstart; /* current string */
     register Bytef *match;                       /* matched string */
     register int len;                           /* length of current match */
     int best_len = s->prev_length;              /* best match length so far */
     int nice_match = s->nice_match;             /* stop if match long enough */
-    IPos limit = s->strstart > (IPos)MAX_DIST(s) ?
-        s->strstart - (IPos)MAX_DIST(s) : NIL;
+	IPos limit = s->strstart > (IPos) MAX_DIST(s) ?
+	    s->strstart - (IPos) MAX_DIST(s) : NIL;
     /* Stop when cur_match becomes <= limit. To simplify the code,
      * we prevent matches with the string of window index 0.
      */
@@ -746,11 +772,11 @@
      * Try with and without -DUNALIGNED_OK to check.
      */
     register Bytef *strend = s->window + s->strstart + MAX_MATCH - 1;
-    register ush scan_start = *(ushf*)scan;
-    register ush scan_end   = *(ushf*)(scan+best_len-1);
+	register ush scan_start = *(ushf *) scan;
+	register ush scan_end = *(ushf *) (scan + best_len - 1);
 #else
     register Bytef *strend = s->window + s->strstart + MAX_MATCH;
-    register Byte scan_end1  = scan[best_len-1];
+	register Byte scan_end1 = scan[best_len - 1];
     register Byte scan_end   = scan[best_len];
 #endif
 
@@ -766,9 +792,11 @@
     /* Do not look for matches beyond the end of the input. This is necessary
      * to make deflate deterministic.
      */
-    if ((uInt)nice_match > s->lookahead) nice_match = s->lookahead;
+	if ((uInt) nice_match > s->lookahead)
+		nice_match = s->lookahead;
 
-    Assert((ulg)s->strstart <= s->window_size-MIN_LOOKAHEAD, "need lookahead");
+	Assert((ulg) s->strstart <= s->window_size - MIN_LOOKAHEAD,
+	       "need lookahead");
 
     do {
         Assert(cur_match < s->strstart, "no future");
@@ -781,8 +809,9 @@
         /* This code assumes sizeof(unsigned short) == 2. Do not use
          * UNALIGNED_OK if your compiler uses a different size.
          */
-        if (*(ushf*)(match+best_len-1) != scan_end ||
-            *(ushf*)match != scan_start) continue;
+		if (*(ushf *) (match + best_len - 1) != scan_end ||
+		    *(ushf *) match != scan_start)
+			continue;
 
         /* It is not necessary to compare scan[2] and match[2] since they are
          * always equal when the other bytes match, given that the hash keys
@@ -796,26 +825,28 @@
         Assert(scan[2] == match[2], "scan[2]?");
         scan++, match++;
         do {
-        } while (*(ushf*)(scan+=2) == *(ushf*)(match+=2) &&
-                 *(ushf*)(scan+=2) == *(ushf*)(match+=2) &&
-                 *(ushf*)(scan+=2) == *(ushf*)(match+=2) &&
-                 *(ushf*)(scan+=2) == *(ushf*)(match+=2) &&
+		} while (*(ushf *) (scan += 2) == *(ushf *) (match += 2) &&
+			 *(ushf *) (scan += 2) == *(ushf *) (match += 2) &&
+			 *(ushf *) (scan += 2) == *(ushf *) (match += 2) &&
+			 *(ushf *) (scan += 2) == *(ushf *) (match += 2) &&
                  scan < strend);
         /* The funny "do {}" generates better code on most compilers */
 
         /* Here, scan <= window+strstart+257 */
-        Assert(scan <= s->window+(unsigned)(s->window_size-1), "wild scan");
-        if (*scan == *match) scan++;
+		Assert(scan <= s->window + (unsigned)(s->window_size - 1),
+		       "wild scan");
+		if (*scan == *match)
+			scan++;
 
-        len = (MAX_MATCH - 1) - (int)(strend-scan);
-        scan = strend - (MAX_MATCH-1);
+		len = (MAX_MATCH - 1) - (int)(strend - scan);
+		scan = strend - (MAX_MATCH - 1);
 
 #else /* UNALIGNED_OK */
 
         if (match[best_len]   != scan_end  ||
-            match[best_len-1] != scan_end1 ||
-            *match            != *scan     ||
-            *++match          != scan[1])      continue;
+		    match[best_len - 1] != scan_end1 ||
+		    *match != *scan || *++match != scan[1])
+			continue;
 
         /* The check at best_len-1 can be removed because it will be made
          * again later. (This heuristic is not always a win.)
@@ -836,7 +867,8 @@
                  *++scan == *++match && *++scan == *++match &&
                  scan < strend);
 
-        Assert(scan <= s->window+(unsigned)(s->window_size-1), "wild scan");
+		Assert(scan <= s->window + (unsigned)(s->window_size - 1),
+		       "wild scan");
 
         len = MAX_MATCH - (int)(strend - scan);
         scan = strend - MAX_MATCH;
@@ -846,18 +878,20 @@
         if (len > best_len) {
             s->match_start = cur_match;
             best_len = len;
-            if (len >= nice_match) break;
+			if (len >= nice_match)
+				break;
 #ifdef UNALIGNED_OK
-            scan_end = *(ushf*)(scan+best_len-1);
+			scan_end = *(ushf *) (scan + best_len - 1);
 #else
-            scan_end1  = scan[best_len-1];
+			scan_end1 = scan[best_len - 1];
             scan_end   = scan[best_len];
 #endif
         }
     } while ((cur_match = prev[cur_match & wmask]) > limit
              && --chain_length != 0);
 
-    if ((uInt)best_len <= s->lookahead) return (uInt)best_len;
+	if ((uInt) best_len <= s->lookahead)
+		return (uInt) best_len;
     return s->lookahead;
 }
 
@@ -866,8 +900,8 @@
  * Optimized version for level == 1 only
  */
 local uInt longest_match(s, cur_match)
-    deflate_state *s;
-    IPos cur_match;                             /* current match */
+deflate_state *s;
+IPos cur_match;			/* current match */
 {
     register Bytef *scan = s->window + s->strstart; /* current string */
     register Bytef *match;                       /* matched string */
@@ -879,7 +913,8 @@
      */
     Assert(s->hash_bits >= 8 && MAX_MATCH == 258, "Code too clever");
 
-    Assert((ulg)s->strstart <= s->window_size-MIN_LOOKAHEAD, "need lookahead");
+	Assert((ulg) s->strstart <= s->window_size - MIN_LOOKAHEAD,
+	       "need lookahead");
 
     Assert(cur_match < s->strstart, "no future");
 
@@ -887,7 +922,8 @@
 
     /* Return failure if the match length is less than 2:
      */
-    if (match[0] != scan[0] || match[1] != scan[1]) return MIN_MATCH-1;
+	if (match[0] != scan[0] || match[1] != scan[1])
+		return MIN_MATCH - 1;
 
     /* The check at best_len-1 can be removed because it will be made
      * again later. (This heuristic is not always a win.)
@@ -905,14 +941,14 @@
     } while (*++scan == *++match && *++scan == *++match &&
 	     *++scan == *++match && *++scan == *++match &&
 	     *++scan == *++match && *++scan == *++match &&
-	     *++scan == *++match && *++scan == *++match &&
-	     scan < strend);
+		 *++scan == *++match && *++scan == *++match && scan < strend);
 
-    Assert(scan <= s->window+(unsigned)(s->window_size-1), "wild scan");
+	Assert(scan <= s->window + (unsigned)(s->window_size - 1), "wild scan");
 
     len = MAX_MATCH - (int)(strend - scan);
 
-    if (len < MIN_MATCH) return MIN_MATCH - 1;
+	if (len < MIN_MATCH)
+		return MIN_MATCH - 1;
 
     s->match_start = cur_match;
     return len <= s->lookahead ? len : s->lookahead;
@@ -925,27 +961,29 @@
  * Check that the match at match_start is indeed a match.
  */
 local void check_match(s, start, match, length)
-    deflate_state *s;
-    IPos start, match;
-    int length;
+deflate_state *s;
+IPos start, match;
+int length;
 {
     /* check that the match is indeed a match */
-    if (zmemcmp(s->window + match,
-                s->window + start, length) != EQUAL) {
+	if (zmemcmp(s->window + match, s->window + start, length) != EQUAL) {
         fprintf(stderr, " start %u, match %u, length %d\n",
 		start, match, length);
         do {
-	    fprintf(stderr, "%c%c", s->window[match++], s->window[start++]);
+			fprintf(stderr, "%c%c", s->window[match++],
+				s->window[start++]);
 	} while (--length != 0);
         z_error("invalid match");
     }
     if (z_verbose > 1) {
-        fprintf(stderr,"\\[%d,%d]", start-match, length);
-        do { putc(s->window[start++], stderr); } while (--length != 0);
+		fprintf(stderr, "\\[%d,%d]", start - match, length);
+		do {
+			putc(s->window[start++], stderr);
+		} while (--length != 0);
     }
 }
 #else
-#  define check_match(s, start, match, length)
+#define check_match(s, start, match, length)
 #endif
 
 /* ===========================================================================
@@ -959,7 +997,7 @@
  *    option -- not supported here).
  */
 local void fill_window(s)
-    deflate_state *s;
+deflate_state *s;
 {
     register unsigned n, m;
     register Posf *p;
@@ -967,7 +1005,9 @@
     uInt wsize = s->w_size;
 
     do {
-        more = (unsigned)(s->window_size -(ulg)s->lookahead -(ulg)s->strstart);
+		more =
+		    (unsigned)(s->window_size - (ulg) s->lookahead -
+			       (ulg) s->strstart);
 
         /* Deal with !@#$% 64K limit: */
         if (more == 0 && s->strstart == 0 && s->lookahead == 0) {
@@ -982,12 +1022,12 @@
         /* If the window is almost full and there is insufficient lookahead,
          * move the upper half to the lower one to make room in the upper half.
          */
-        } else if (s->strstart >= wsize+MAX_DIST(s)) {
+		} else if (s->strstart >= wsize + MAX_DIST(s)) {
 
-            zmemcpy(s->window, s->window+wsize, (unsigned)wsize);
+			zmemcpy(s->window, s->window + wsize, (unsigned)wsize);
             s->match_start -= wsize;
             s->strstart    -= wsize; /* we now have strstart >= MAX_DIST */
-            s->block_start -= (long) wsize;
+			s->block_start -= (long)wsize;
 
             /* Slide the hash table (could be avoided with 32 bit values
                at the expense of memory usage). We slide even when level == 0
@@ -999,7 +1039,7 @@
 	    p = &s->head[n];
 	    do {
 		m = *--p;
-		*p = (Pos)(m >= wsize ? m-wsize : NIL);
+				*p = (Pos) (m >= wsize ? m - wsize : NIL);
 	    } while (--n);
 
 	    n = wsize;
@@ -1007,7 +1047,7 @@
 	    p = &s->prev[n];
 	    do {
 		m = *--p;
-		*p = (Pos)(m >= wsize ? m-wsize : NIL);
+				*p = (Pos) (m >= wsize ? m - wsize : NIL);
 		/* If n is not on any hash chain, prev[n] is garbage but
 		 * its value will never be used.
 		 */
@@ -1015,7 +1055,8 @@
 #endif
             more += wsize;
         }
-        if (s->strm->avail_in == 0) return;
+		if (s->strm->avail_in == 0)
+			return;
 
         /* If there was no sliding:
          *    strstart <= WSIZE+MAX_DIST-1 && lookahead <= MIN_LOOKAHEAD - 1 &&
@@ -1030,15 +1071,16 @@
          */
         Assert(more >= 2, "more < 2");
 
-        n = read_buf(s->strm, s->window + s->strstart + s->lookahead, more);
+		n = read_buf(s->strm, s->window + s->strstart + s->lookahead,
+			     more);
         s->lookahead += n;
 
         /* Initialize the hash value now that we have some input: */
         if (s->lookahead >= MIN_MATCH) {
             s->ins_h = s->window[s->strstart];
-            UPDATE_HASH(s, s->ins_h, s->window[s->strstart+1]);
+			UPDATE_HASH(s, s->ins_h, s->window[s->strstart + 1]);
 #if MIN_MATCH != 3
-            Call UPDATE_HASH() MIN_MATCH-3 more times
+			Call UPDATE_HASH() MIN_MATCH - 3 more times
 #endif
         }
         /* If the whole input has less than MIN_MATCH bytes, ins_h is garbage,
@@ -1079,8 +1120,8 @@
  * window to pending_buf.
  */
 local block_state deflate_stored(s, flush)
-    deflate_state *s;
-    int flush;
+deflate_state *s;
+int flush;
 {
     /* Stored blocks are limited to 0xffff bytes, pending_buf is limited
      * to pending_buf_size, and each stored block has a 5 byte header:
@@ -1097,13 +1138,16 @@
         /* Fill the window as much as possible: */
         if (s->lookahead <= 1) {
 
-            Assert(s->strstart < s->w_size+MAX_DIST(s) ||
-		   s->block_start >= (long)s->w_size, "slide too late");
+			Assert(s->strstart < s->w_size + MAX_DIST(s) ||
+			       s->block_start >= (long)s->w_size,
+			       "slide too late");
 
             fill_window(s);
-            if (s->lookahead == 0 && flush == Z_NO_FLUSH) return need_more;
+			if (s->lookahead == 0 && flush == Z_NO_FLUSH)
+				return need_more;
 
-            if (s->lookahead == 0) break; /* flush the current block */
+			if (s->lookahead == 0)
+				break;	/* flush the current block */
         }
 	Assert(s->block_start >= 0L, "block gone");
 
@@ -1112,16 +1156,16 @@
 
 	/* Emit a stored block if pending_buf will be full: */
  	max_start = s->block_start + max_block_size;
-        if (s->strstart == 0 || (ulg)s->strstart >= max_start) {
+		if (s->strstart == 0 || (ulg) s->strstart >= max_start) {
 	    /* strstart == 0 is possible when wraparound on 16-bit machine */
-	    s->lookahead = (uInt)(s->strstart - max_start);
-	    s->strstart = (uInt)max_start;
+			s->lookahead = (uInt) (s->strstart - max_start);
+			s->strstart = (uInt) max_start;
             FLUSH_BLOCK(s, 0);
 	}
 	/* Flush if we may have to slide, otherwise block_start may become
          * negative and the data will be gone:
          */
-        if (s->strstart - (uInt)s->block_start >= MAX_DIST(s)) {
+		if (s->strstart - (uInt) s->block_start >= MAX_DIST(s)) {
             FLUSH_BLOCK(s, 0);
 	}
     }
@@ -1137,8 +1181,8 @@
  * matches. It is used only for the fast compression options.
  */
 local block_state deflate_fast(s, flush)
-    deflate_state *s;
-    int flush;
+deflate_state *s;
+int flush;
 {
     IPos hash_head = NIL; /* head of the hash chain */
     int bflush;           /* set if current block must be flushed */
@@ -1154,7 +1198,8 @@
             if (s->lookahead < MIN_LOOKAHEAD && flush == Z_NO_FLUSH) {
 	        return need_more;
 	    }
-            if (s->lookahead == 0) break; /* flush the current block */
+			if (s->lookahead == 0)
+				break;	/* flush the current block */
         }
 
         /* Insert the string window[strstart .. strstart+2] in the
@@ -1173,12 +1218,13 @@
              * of the string with itself at the start of the input file).
              */
             if (s->strategy != Z_HUFFMAN_ONLY) {
-                s->match_length = longest_match (s, hash_head);
+				s->match_length = longest_match(s, hash_head);
             }
             /* longest_match() sets match_start */
         }
         if (s->match_length >= MIN_MATCH) {
-            check_match(s, s->strstart, s->match_start, s->match_length);
+			check_match(s, s->strstart, s->match_start,
+				    s->match_length);
 
             _tr_tally_dist(s, s->strstart - s->match_start,
                            s->match_length - MIN_MATCH, bflush);
@@ -1194,7 +1240,8 @@
                 s->match_length--; /* string at strstart already in hash table */
                 do {
                     s->strstart++;
-                    INSERT_STRING(s, s->strstart, hash_head);
+					INSERT_STRING(s, s->strstart,
+						      hash_head);
                     /* strstart never exceeds WSIZE-MAX_MATCH, so there are
                      * always MIN_MATCH bytes ahead.
                      */
@@ -1206,9 +1253,10 @@
                 s->strstart += s->match_length;
                 s->match_length = 0;
                 s->ins_h = s->window[s->strstart];
-                UPDATE_HASH(s, s->ins_h, s->window[s->strstart+1]);
+				UPDATE_HASH(s, s->ins_h,
+					    s->window[s->strstart + 1]);
 #if MIN_MATCH != 3
-                Call UPDATE_HASH() MIN_MATCH-3 more times
+				Call UPDATE_HASH() MIN_MATCH - 3 more times
 #endif
                 /* If lookahead < MIN_MATCH, ins_h is garbage, but it does not
                  * matter since it will be recomputed at next deflate call.
@@ -1216,12 +1264,13 @@
             }
         } else {
             /* No match, output a literal byte */
-            Tracevv((stderr,"%c", s->window[s->strstart]));
-            _tr_tally_lit (s, s->window[s->strstart], bflush);
+			Tracevv((stderr, "%c", s->window[s->strstart]));
+			_tr_tally_lit(s, s->window[s->strstart], bflush);
             s->lookahead--;
             s->strstart++; 
         }
-        if (bflush) FLUSH_BLOCK(s, 0);
+		if (bflush)
+			FLUSH_BLOCK(s, 0);
     }
     FLUSH_BLOCK(s, flush == Z_FINISH);
     return flush == Z_FINISH ? finish_done : block_done;
@@ -1233,8 +1282,8 @@
  * no better match at the next window position.
  */
 local block_state deflate_slow(s, flush)
-    deflate_state *s;
-    int flush;
+deflate_state *s;
+int flush;
 {
     IPos hash_head = NIL;    /* head of hash chain */
     int bflush;              /* set if current block must be flushed */
@@ -1251,7 +1300,8 @@
             if (s->lookahead < MIN_LOOKAHEAD && flush == Z_NO_FLUSH) {
 	        return need_more;
 	    }
-            if (s->lookahead == 0) break; /* flush the current block */
+			if (s->lookahead == 0)
+				break;	/* flush the current block */
         }
 
         /* Insert the string window[strstart .. strstart+2] in the
@@ -1263,8 +1313,9 @@
 
         /* Find the longest match, discarding those <= prev_length.
          */
-        s->prev_length = s->match_length, s->prev_match = s->match_start;
-        s->match_length = MIN_MATCH-1;
+		s->prev_length = s->match_length, s->prev_match =
+		    s->match_start;
+		s->match_length = MIN_MATCH - 1;
 
         if (hash_head != NIL && s->prev_length < s->max_lazy_match &&
             s->strstart - hash_head <= MAX_DIST(s)) {
@@ -1273,30 +1324,35 @@
              * of the string with itself at the start of the input file).
              */
             if (s->strategy != Z_HUFFMAN_ONLY) {
-                s->match_length = longest_match (s, hash_head);
+				s->match_length = longest_match(s, hash_head);
             }
             /* longest_match() sets match_start */
 
-            if (s->match_length <= 5 && (s->strategy == Z_FILTERED ||
-                 (s->match_length == MIN_MATCH &&
-                  s->strstart - s->match_start > TOO_FAR))) {
+			if (s->match_length <= 5
+			    && (s->strategy == Z_FILTERED
+				|| (s->match_length == MIN_MATCH
+				    && s->strstart - s->match_start >
+				    TOO_FAR))) {
 
                 /* If prev_match is also MIN_MATCH, match_start is garbage
                  * but we will ignore the current match anyway.
                  */
-                s->match_length = MIN_MATCH-1;
+				s->match_length = MIN_MATCH - 1;
             }
         }
         /* If there was a match at the previous step and the current
          * match is not better, output the previous match:
          */
-        if (s->prev_length >= MIN_MATCH && s->match_length <= s->prev_length) {
-            uInt max_insert = s->strstart + s->lookahead - MIN_MATCH;
+		if (s->prev_length >= MIN_MATCH
+		    && s->match_length <= s->prev_length) {
+			uInt max_insert =
+			    s->strstart + s->lookahead - MIN_MATCH;
             /* Do not insert strings in hash table beyond this. */
 
-            check_match(s, s->strstart-1, s->prev_match, s->prev_length);
+			check_match(s, s->strstart - 1, s->prev_match,
+				    s->prev_length);
 
-            _tr_tally_dist(s, s->strstart -1 - s->prev_match,
+			_tr_tally_dist(s, s->strstart - 1 - s->prev_match,
 			   s->prev_length - MIN_MATCH, bflush);
 
             /* Insert in hash table all strings up to the end of the match.
@@ -1304,32 +1360,35 @@
              * enough lookahead, the last two strings are not inserted in
              * the hash table.
              */
-            s->lookahead -= s->prev_length-1;
+			s->lookahead -= s->prev_length - 1;
             s->prev_length -= 2;
             do {
                 if (++s->strstart <= max_insert) {
-                    INSERT_STRING(s, s->strstart, hash_head);
+					INSERT_STRING(s, s->strstart,
+						      hash_head);
                 }
             } while (--s->prev_length != 0);
             s->match_available = 0;
-            s->match_length = MIN_MATCH-1;
+			s->match_length = MIN_MATCH - 1;
             s->strstart++;
 
-            if (bflush) FLUSH_BLOCK(s, 0);
+			if (bflush)
+				FLUSH_BLOCK(s, 0);
 
         } else if (s->match_available) {
             /* If there was no match at the previous position, output a
              * single literal. If there was a match but the current match
              * is longer, truncate the previous match to a single literal.
              */
-            Tracevv((stderr,"%c", s->window[s->strstart-1]));
-	    _tr_tally_lit(s, s->window[s->strstart-1], bflush);
+			Tracevv((stderr, "%c", s->window[s->strstart - 1]));
+			_tr_tally_lit(s, s->window[s->strstart - 1], bflush);
 	    if (bflush) {
                 FLUSH_BLOCK_ONLY(s, 0);
             }
             s->strstart++;
             s->lookahead--;
-            if (s->strm->avail_out == 0) return need_more;
+			if (s->strm->avail_out == 0)
+				return need_more;
         } else {
             /* There is no previous match to compare with, wait for
              * the next step to decide.
@@ -1339,10 +1398,10 @@
             s->lookahead--;
         }
     }
-    Assert (flush != Z_NO_FLUSH, "no flush?");
+	Assert(flush != Z_NO_FLUSH, "no flush?");
     if (s->match_available) {
-        Tracevv((stderr,"%c", s->window[s->strstart-1]));
-        _tr_tally_lit(s, s->window[s->strstart-1], bflush);
+		Tracevv((stderr, "%c", s->window[s->strstart - 1]));
+		_tr_tally_lit(s, s->window[s->strstart - 1], bflush);
         s->match_available = 0;
     }
     FLUSH_BLOCK(s, flush == Z_FINISH);
--- zlib-1.1.3/deflate.h	1998-07-08 12:30:19.000000000 -0400
+++ zlib-1.1.3/deflate.h	2014-02-07 11:53:21.350326753 -0500
@@ -8,7 +8,7 @@
    subject to change. Applications should only use zlib.h.
  */
 
-/* @(#) $Id$ */
+/* @(#) $Id: deflate.h,v 1.1 2001/11/09 01:48:02 mpl Exp $ */
 
 #ifndef _DEFLATE_H
 #define _DEFLATE_H
@@ -160,14 +159,14 @@
      * smaller than this value. This mechanism is used only for compression
      * levels >= 4.
      */
-#   define max_insert_length  max_lazy_match
+#define max_insert_length  max_lazy_match
     /* Insert new strings in the hash table only if the match length is not
      * greater than this length. This saves time but degrades compression.
      * max_insert_length is used only for compression levels <= 3.
      */
 
     int level;    /* compression level (1..9) */
-    int strategy; /* favor or force Huffman coding*/
+	int strategy;		/* favor or force Huffman coding */
 
     uInt good_match;
     /* Use a faster search when the previous match is longer than this */
@@ -177,24 +176,24 @@
                 /* used by trees.c: */
     /* Didn't use ct_data typedef below to supress compiler warning */
     struct ct_data_s dyn_ltree[HEAP_SIZE];   /* literal and length tree */
-    struct ct_data_s dyn_dtree[2*D_CODES+1]; /* distance tree */
-    struct ct_data_s bl_tree[2*BL_CODES+1];  /* Huffman tree for bit lengths */
+	struct ct_data_s dyn_dtree[2 * D_CODES + 1];	/* distance tree */
+	struct ct_data_s bl_tree[2 * BL_CODES + 1];	/* Huffman tree for bit lengths */
 
     struct tree_desc_s l_desc;               /* desc. for literal tree */
     struct tree_desc_s d_desc;               /* desc. for distance tree */
     struct tree_desc_s bl_desc;              /* desc. for bit length tree */
 
-    ush bl_count[MAX_BITS+1];
+	ush bl_count[MAX_BITS + 1];
     /* number of codes at each bit length for an optimal tree */
 
-    int heap[2*L_CODES+1];      /* heap used to build the Huffman trees */
+	int heap[2 * L_CODES + 1];	/* heap used to build the Huffman trees */
     int heap_len;               /* number of elements in the heap */
     int heap_max;               /* element of largest frequency */
     /* The sons of heap[n] are heap[2*n] and heap[2*n+1]. heap[0] is not used.
      * The same heap array is used to build all trees.
      */
 
-    uch depth[2*L_CODES+1];
+	uch depth[2 * L_CODES + 1];
     /* Depth of each subtree used as tie breaker for trees of equal frequency
      */
 
@@ -266,12 +264,12 @@
  */
 
         /* in trees.c */
-void _tr_init         OF((deflate_state *s));
-int  _tr_tally        OF((deflate_state *s, unsigned dist, unsigned lc));
-void _tr_flush_block  OF((deflate_state *s, charf *buf, ulg stored_len,
+void _tr_init OF((deflate_state * s));
+int _tr_tally OF((deflate_state * s, unsigned dist, unsigned lc));
+void _tr_flush_block OF((deflate_state * s, charf * buf, ulg stored_len,
 			  int eof));
-void _tr_align        OF((deflate_state *s));
-void _tr_stored_block OF((deflate_state *s, charf *buf, ulg stored_len,
+void _tr_align OF((deflate_state * s));
+void _tr_stored_block OF((deflate_state * s, charf * buf, ulg stored_len,
                           int eof));
 
 #define d_code(dist) \
@@ -285,21 +283,21 @@
 /* Inline versions of _tr_tally for speed: */
 
 #if defined(GEN_TREES_H) || !defined(STDC)
-  extern uch _length_code[];
-  extern uch _dist_code[];
+extern uch _length_code[];
+extern uch _dist_code[];
 #else
-  extern const uch _length_code[];
-  extern const uch _dist_code[];
+extern const uch _length_code[];
+extern const uch _dist_code[];
 #endif
 
-# define _tr_tally_lit(s, c, flush) \
+#define _tr_tally_lit(s, c, flush) \
   { uch cc = (c); \
     s->d_buf[s->last_lit] = 0; \
     s->l_buf[s->last_lit++] = cc; \
     s->dyn_ltree[cc].Freq++; \
     flush = (s->last_lit == s->lit_bufsize-1); \
    }
-# define _tr_tally_dist(s, distance, length, flush) \
+#define _tr_tally_dist(s, distance, length, flush) \
   { uch len = (length); \
     ush dist = (distance); \
     s->d_buf[s->last_lit] = dist; \
@@ -310,8 +308,8 @@
     flush = (s->last_lit == s->lit_bufsize-1); \
   }
 #else
-# define _tr_tally_lit(s, c, flush) flush = _tr_tally(s, 0, c)
-# define _tr_tally_dist(s, distance, length, flush) \
+#define _tr_tally_lit(s, c, flush) flush = _tr_tally(s, 0, c)
+#define _tr_tally_dist(s, distance, length, flush) \
               flush = _tr_tally(s, distance, length) 
 #endif
 
--- zlib-1.1.3/example.c	1998-05-12 05:47:35.000000000 -0400
+++ zlib-1.1.3/example.c	2014-02-07 11:53:21.350326753 -0500
@@ -3,22 +3,22 @@
  * For conditions of distribution and use, see copyright notice in zlib.h 
  */
 
-/* @(#) $Id$ */
+/* @(#) $Id: example.c,v 1.1 2001/11/09 01:48:02 mpl Exp $ */
 
 #include <stdio.h>
 #include "zlib.h"
 
 #ifdef STDC
-#  include <string.h>
-#  include <stdlib.h>
+#include <string.h>
+#include <stdlib.h>
 #else
-   extern void exit  OF((int));
+extern void exit OF((int));
 #endif
 
 #if defined(VMS) || defined(RISCOS)
-#  define TESTFILE "foo-gz"
+#define TESTFILE "foo-gz"
 #else
-#  define TESTFILE "foo.gz"
+#define TESTFILE "foo.gz"
 #endif
 
 #define CHECK_ERR(err, msg) { \
@@ -36,44 +36,44 @@
 const char dictionary[] = "hello";
 uLong dictId; /* Adler32 value of the dictionary */
 
-void test_compress      OF((Byte *compr, uLong comprLen,
-		            Byte *uncompr, uLong uncomprLen));
+void test_compress OF((Byte * compr, uLong comprLen,
+		       Byte * uncompr, uLong uncomprLen));
 void test_gzio          OF((const char *out, const char *in, 
-		            Byte *uncompr, int uncomprLen));
-void test_deflate       OF((Byte *compr, uLong comprLen));
-void test_inflate       OF((Byte *compr, uLong comprLen,
-		            Byte *uncompr, uLong uncomprLen));
-void test_large_deflate OF((Byte *compr, uLong comprLen,
-		            Byte *uncompr, uLong uncomprLen));
-void test_large_inflate OF((Byte *compr, uLong comprLen,
-		            Byte *uncompr, uLong uncomprLen));
-void test_flush         OF((Byte *compr, uLong *comprLen));
-void test_sync          OF((Byte *compr, uLong comprLen,
-		            Byte *uncompr, uLong uncomprLen));
-void test_dict_deflate  OF((Byte *compr, uLong comprLen));
-void test_dict_inflate  OF((Byte *compr, uLong comprLen,
-		            Byte *uncompr, uLong uncomprLen));
+		   Byte * uncompr, int uncomprLen));
+void test_deflate OF((Byte * compr, uLong comprLen));
+void test_inflate OF((Byte * compr, uLong comprLen,
+		      Byte * uncompr, uLong uncomprLen));
+void test_large_deflate OF((Byte * compr, uLong comprLen,
+			    Byte * uncompr, uLong uncomprLen));
+void test_large_inflate OF((Byte * compr, uLong comprLen,
+			    Byte * uncompr, uLong uncomprLen));
+void test_flush OF((Byte * compr, uLong * comprLen));
+void test_sync OF((Byte * compr, uLong comprLen,
+		   Byte * uncompr, uLong uncomprLen));
+void test_dict_deflate OF((Byte * compr, uLong comprLen));
+void test_dict_inflate OF((Byte * compr, uLong comprLen,
+			   Byte * uncompr, uLong uncomprLen));
 int  main               OF((int argc, char *argv[]));
 
 /* ===========================================================================
  * Test compress() and uncompress()
  */
 void test_compress(compr, comprLen, uncompr, uncomprLen)
-    Byte *compr, *uncompr;
-    uLong comprLen, uncomprLen;
+Byte *compr, *uncompr;
+uLong comprLen, uncomprLen;
 {
     int err;
-    uLong len = strlen(hello)+1;
+	uLong len = strlen(hello) + 1;
 
-    err = compress(compr, &comprLen, (const Bytef*)hello, len);
+	err = compress(compr, &comprLen, (const Bytef *)hello, len);
     CHECK_ERR(err, "compress");
 
-    strcpy((char*)uncompr, "garbage");
+	strcpy((char *)uncompr, "garbage");
 
     err = uncompress(uncompr, &uncomprLen, compr, comprLen);
     CHECK_ERR(err, "uncompress");
 
-    if (strcmp((char*)uncompr, hello)) {
+	if (strcmp((char *)uncompr, hello)) {
         fprintf(stderr, "bad uncompress\n");
 	exit(1);
     } else {
@@ -85,13 +85,13 @@
  * Test read/write of .gz files
  */
 void test_gzio(out, in, uncompr, uncomprLen)
-    const char *out; /* compressed output file */
-    const char *in;  /* compressed input file */
-    Byte *uncompr;
-    int  uncomprLen;
+const char *out;		/* compressed output file */
+const char *in;			/* compressed input file */
+Byte *uncompr;
+int uncomprLen;
 {
     int err;
-    int len = strlen(hello)+1;
+	int len = strlen(hello) + 1;
     gzFile file;
     z_off_t pos;
 
@@ -116,15 +116,15 @@
     if (file == NULL) {
         fprintf(stderr, "gzopen error\n");
     }
-    strcpy((char*)uncompr, "garbage");
+	strcpy((char *)uncompr, "garbage");
 
     uncomprLen = gzread(file, uncompr, (unsigned)uncomprLen);
     if (uncomprLen != len) {
         fprintf(stderr, "gzread err: %s\n", gzerror(file, &err));
 	exit(1);
     }
-    if (strcmp((char*)uncompr, hello)) {
-        fprintf(stderr, "bad gzread: %s\n", (char*)uncompr);
+	if (strcmp((char *)uncompr, hello)) {
+		fprintf(stderr, "bad gzread: %s\n", (char *)uncompr);
 	exit(1);
     } else {
         printf("gzread(): %s\n", (char *)uncompr);
@@ -142,13 +142,14 @@
 	exit(1);
     }
 
-    gzgets(file, (char*)uncompr, uncomprLen);
-    uncomprLen = strlen((char*)uncompr);
+	gzgets(file, (char *)uncompr, uncomprLen);
+	uncomprLen = strlen((char *)uncompr);
     if (uncomprLen != 6) { /* "hello!" */
-        fprintf(stderr, "gzgets err after gzseek: %s\n", gzerror(file, &err));
+		fprintf(stderr, "gzgets err after gzseek: %s\n",
+			gzerror(file, &err));
 	exit(1);
     }
-    if (strcmp((char*)uncompr, hello+7)) {
+	if (strcmp((char *)uncompr, hello + 7)) {
         fprintf(stderr, "bad gzgets after gzseek\n");
 	exit(1);
     } else {
@@ -162,24 +163,25 @@
  * Test deflate() with small buffers
  */
 void test_deflate(compr, comprLen)
-    Byte *compr;
-    uLong comprLen;
+Byte *compr;
+uLong comprLen;
 {
     z_stream c_stream; /* compression stream */
     int err;
-    int len = strlen(hello)+1;
+	int len = strlen(hello) + 1;
 
-    c_stream.zalloc = (alloc_func)0;
-    c_stream.zfree = (free_func)0;
-    c_stream.opaque = (voidpf)0;
+	c_stream.zalloc = (alloc_func) 0;
+	c_stream.zfree = (free_func) 0;
+	c_stream.opaque = (voidpf) 0;
 
     err = deflateInit(&c_stream, Z_DEFAULT_COMPRESSION);
     CHECK_ERR(err, "deflateInit");
 
-    c_stream.next_in  = (Bytef*)hello;
+	c_stream.next_in = (Bytef *) hello;
     c_stream.next_out = compr;
 
-    while (c_stream.total_in != (uLong)len && c_stream.total_out < comprLen) {
+	while (c_stream.total_in != (uLong) len
+	       && c_stream.total_out < comprLen) {
         c_stream.avail_in = c_stream.avail_out = 1; /* force small buffers */
         err = deflate(&c_stream, Z_NO_FLUSH);
         CHECK_ERR(err, "deflate");
@@ -188,7 +190,8 @@
     for (;;) {
         c_stream.avail_out = 1;
         err = deflate(&c_stream, Z_FINISH);
-        if (err == Z_STREAM_END) break;
+		if (err == Z_STREAM_END)
+			break;
         CHECK_ERR(err, "deflate");
     }
 
@@ -200,17 +203,17 @@
  * Test inflate() with small buffers
  */
 void test_inflate(compr, comprLen, uncompr, uncomprLen)
-    Byte *compr, *uncompr;
-    uLong comprLen, uncomprLen;
+Byte *compr, *uncompr;
+uLong comprLen, uncomprLen;
 {
     int err;
     z_stream d_stream; /* decompression stream */
 
-    strcpy((char*)uncompr, "garbage");
+	strcpy((char *)uncompr, "garbage");
 
-    d_stream.zalloc = (alloc_func)0;
-    d_stream.zfree = (free_func)0;
-    d_stream.opaque = (voidpf)0;
+	d_stream.zalloc = (alloc_func) 0;
+	d_stream.zfree = (free_func) 0;
+	d_stream.opaque = (voidpf) 0;
 
     d_stream.next_in  = compr;
     d_stream.avail_in = 0;
@@ -222,14 +225,15 @@
     while (d_stream.total_out < uncomprLen && d_stream.total_in < comprLen) {
         d_stream.avail_in = d_stream.avail_out = 1; /* force small buffers */
         err = inflate(&d_stream, Z_NO_FLUSH);
-        if (err == Z_STREAM_END) break;
+		if (err == Z_STREAM_END)
+			break;
         CHECK_ERR(err, "inflate");
     }
 
     err = inflateEnd(&d_stream);
     CHECK_ERR(err, "inflateEnd");
 
-    if (strcmp((char*)uncompr, hello)) {
+	if (strcmp((char *)uncompr, hello)) {
         fprintf(stderr, "bad inflate\n");
 	exit(1);
     } else {
@@ -241,27 +245,27 @@
  * Test deflate() with large buffers and dynamic change of compression level
  */
 void test_large_deflate(compr, comprLen, uncompr, uncomprLen)
-    Byte *compr, *uncompr;
-    uLong comprLen, uncomprLen;
+Byte *compr, *uncompr;
+uLong comprLen, uncomprLen;
 {
     z_stream c_stream; /* compression stream */
     int err;
 
-    c_stream.zalloc = (alloc_func)0;
-    c_stream.zfree = (free_func)0;
-    c_stream.opaque = (voidpf)0;
+	c_stream.zalloc = (alloc_func) 0;
+	c_stream.zfree = (free_func) 0;
+	c_stream.opaque = (voidpf) 0;
 
     err = deflateInit(&c_stream, Z_BEST_SPEED);
     CHECK_ERR(err, "deflateInit");
 
     c_stream.next_out = compr;
-    c_stream.avail_out = (uInt)comprLen;
+	c_stream.avail_out = (uInt) comprLen;
 
     /* At this point, uncompr is still mostly zeroes, so it should compress
      * very well:
      */
     c_stream.next_in = uncompr;
-    c_stream.avail_in = (uInt)uncomprLen;
+	c_stream.avail_in = (uInt) uncomprLen;
     err = deflate(&c_stream, Z_NO_FLUSH);
     CHECK_ERR(err, "deflate");
     if (c_stream.avail_in != 0) {
@@ -272,14 +276,14 @@
     /* Feed in already compressed data and switch to no compression: */
     deflateParams(&c_stream, Z_NO_COMPRESSION, Z_DEFAULT_STRATEGY);
     c_stream.next_in = compr;
-    c_stream.avail_in = (uInt)comprLen/2;
+	c_stream.avail_in = (uInt) comprLen / 2;
     err = deflate(&c_stream, Z_NO_FLUSH);
     CHECK_ERR(err, "deflate");
 
     /* Switch back to compressing mode: */
     deflateParams(&c_stream, Z_BEST_COMPRESSION, Z_FILTERED);
     c_stream.next_in = uncompr;
-    c_stream.avail_in = (uInt)uncomprLen;
+	c_stream.avail_in = (uInt) uncomprLen;
     err = deflate(&c_stream, Z_NO_FLUSH);
     CHECK_ERR(err, "deflate");
 
@@ -296,36 +300,37 @@
  * Test inflate() with large buffers
  */
 void test_large_inflate(compr, comprLen, uncompr, uncomprLen)
-    Byte *compr, *uncompr;
-    uLong comprLen, uncomprLen;
+Byte *compr, *uncompr;
+uLong comprLen, uncomprLen;
 {
     int err;
     z_stream d_stream; /* decompression stream */
 
-    strcpy((char*)uncompr, "garbage");
+	strcpy((char *)uncompr, "garbage");
 
-    d_stream.zalloc = (alloc_func)0;
-    d_stream.zfree = (free_func)0;
-    d_stream.opaque = (voidpf)0;
+	d_stream.zalloc = (alloc_func) 0;
+	d_stream.zfree = (free_func) 0;
+	d_stream.opaque = (voidpf) 0;
 
     d_stream.next_in  = compr;
-    d_stream.avail_in = (uInt)comprLen;
+	d_stream.avail_in = (uInt) comprLen;
 
     err = inflateInit(&d_stream);
     CHECK_ERR(err, "inflateInit");
 
     for (;;) {
         d_stream.next_out = uncompr;            /* discard the output */
-	d_stream.avail_out = (uInt)uncomprLen;
+		d_stream.avail_out = (uInt) uncomprLen;
         err = inflate(&d_stream, Z_NO_FLUSH);
-        if (err == Z_STREAM_END) break;
+		if (err == Z_STREAM_END)
+			break;
         CHECK_ERR(err, "large inflate");
     }
 
     err = inflateEnd(&d_stream);
     CHECK_ERR(err, "inflateEnd");
 
-    if (d_stream.total_out != 2*uncomprLen + comprLen/2) {
+	if (d_stream.total_out != 2 * uncomprLen + comprLen / 2) {
         fprintf(stderr, "bad large inflate: %ld\n", d_stream.total_out);
 	exit(1);
     } else {
@@ -337,24 +342,24 @@
  * Test deflate() with full flush
  */
 void test_flush(compr, comprLen)
-    Byte *compr;
-    uLong *comprLen;
+Byte *compr;
+uLong *comprLen;
 {
     z_stream c_stream; /* compression stream */
     int err;
-    int len = strlen(hello)+1;
+	int len = strlen(hello) + 1;
 
-    c_stream.zalloc = (alloc_func)0;
-    c_stream.zfree = (free_func)0;
-    c_stream.opaque = (voidpf)0;
+	c_stream.zalloc = (alloc_func) 0;
+	c_stream.zfree = (free_func) 0;
+	c_stream.opaque = (voidpf) 0;
 
     err = deflateInit(&c_stream, Z_DEFAULT_COMPRESSION);
     CHECK_ERR(err, "deflateInit");
 
-    c_stream.next_in  = (Bytef*)hello;
+	c_stream.next_in = (Bytef *) hello;
     c_stream.next_out = compr;
     c_stream.avail_in = 3;
-    c_stream.avail_out = (uInt)*comprLen;
+	c_stream.avail_out = (uInt) * comprLen;
     err = deflate(&c_stream, Z_FULL_FLUSH);
     CHECK_ERR(err, "deflate");
 
@@ -375,17 +380,17 @@
  * Test inflateSync()
  */
 void test_sync(compr, comprLen, uncompr, uncomprLen)
-    Byte *compr, *uncompr;
-    uLong comprLen, uncomprLen;
+Byte *compr, *uncompr;
+uLong comprLen, uncomprLen;
 {
     int err;
     z_stream d_stream; /* decompression stream */
 
-    strcpy((char*)uncompr, "garbage");
+	strcpy((char *)uncompr, "garbage");
 
-    d_stream.zalloc = (alloc_func)0;
-    d_stream.zfree = (free_func)0;
-    d_stream.opaque = (voidpf)0;
+	d_stream.zalloc = (alloc_func) 0;
+	d_stream.zfree = (free_func) 0;
+	d_stream.opaque = (voidpf) 0;
 
     d_stream.next_in  = compr;
     d_stream.avail_in = 2; /* just read the zlib header */
@@ -394,12 +399,12 @@
     CHECK_ERR(err, "inflateInit");
 
     d_stream.next_out = uncompr;
-    d_stream.avail_out = (uInt)uncomprLen;
+	d_stream.avail_out = (uInt) uncomprLen;
 
     inflate(&d_stream, Z_NO_FLUSH);
     CHECK_ERR(err, "inflate");
 
-    d_stream.avail_in = (uInt)comprLen-2;   /* read all compressed data */
+	d_stream.avail_in = (uInt) comprLen - 2;	/* read all compressed data */
     err = inflateSync(&d_stream);           /* but skip the damaged part */
     CHECK_ERR(err, "inflateSync");
 
@@ -419,29 +424,30 @@
  * Test deflate() with preset dictionary
  */
 void test_dict_deflate(compr, comprLen)
-    Byte *compr;
-    uLong comprLen;
+Byte *compr;
+uLong comprLen;
 {
     z_stream c_stream; /* compression stream */
     int err;
 
-    c_stream.zalloc = (alloc_func)0;
-    c_stream.zfree = (free_func)0;
-    c_stream.opaque = (voidpf)0;
+	c_stream.zalloc = (alloc_func) 0;
+	c_stream.zfree = (free_func) 0;
+	c_stream.opaque = (voidpf) 0;
 
     err = deflateInit(&c_stream, Z_BEST_COMPRESSION);
     CHECK_ERR(err, "deflateInit");
 
     err = deflateSetDictionary(&c_stream,
-			       (const Bytef*)dictionary, sizeof(dictionary));
+				   (const Bytef *)dictionary,
+				   sizeof(dictionary));
     CHECK_ERR(err, "deflateSetDictionary");
 
     dictId = c_stream.adler;
     c_stream.next_out = compr;
-    c_stream.avail_out = (uInt)comprLen;
+	c_stream.avail_out = (uInt) comprLen;
 
-    c_stream.next_in = (Bytef*)hello;
-    c_stream.avail_in = (uInt)strlen(hello)+1;
+	c_stream.next_in = (Bytef *) hello;
+	c_stream.avail_in = (uInt) strlen(hello) + 1;
 
     err = deflate(&c_stream, Z_FINISH);
     if (err != Z_STREAM_END) {
@@ -456,36 +462,39 @@
  * Test inflate() with a preset dictionary
  */
 void test_dict_inflate(compr, comprLen, uncompr, uncomprLen)
-    Byte *compr, *uncompr;
-    uLong comprLen, uncomprLen;
+Byte *compr, *uncompr;
+uLong comprLen, uncomprLen;
 {
     int err;
     z_stream d_stream; /* decompression stream */
 
-    strcpy((char*)uncompr, "garbage");
+	strcpy((char *)uncompr, "garbage");
 
-    d_stream.zalloc = (alloc_func)0;
-    d_stream.zfree = (free_func)0;
-    d_stream.opaque = (voidpf)0;
+	d_stream.zalloc = (alloc_func) 0;
+	d_stream.zfree = (free_func) 0;
+	d_stream.opaque = (voidpf) 0;
 
     d_stream.next_in  = compr;
-    d_stream.avail_in = (uInt)comprLen;
+	d_stream.avail_in = (uInt) comprLen;
 
     err = inflateInit(&d_stream);
     CHECK_ERR(err, "inflateInit");
 
     d_stream.next_out = uncompr;
-    d_stream.avail_out = (uInt)uncomprLen;
+	d_stream.avail_out = (uInt) uncomprLen;
 
     for (;;) {
         err = inflate(&d_stream, Z_NO_FLUSH);
-        if (err == Z_STREAM_END) break;
+		if (err == Z_STREAM_END)
+			break;
 	if (err == Z_NEED_DICT) {
 	    if (d_stream.adler != dictId) {
 		fprintf(stderr, "unexpected dictionary");
 		exit(1);
 	    }
-	    err = inflateSetDictionary(&d_stream, (const Bytef*)dictionary,
+			err =
+			    inflateSetDictionary(&d_stream,
+						 (const Bytef *)dictionary,
 				       sizeof(dictionary));
 	}
         CHECK_ERR(err, "inflate with dict");
@@ -494,7 +503,7 @@
     err = inflateEnd(&d_stream);
     CHECK_ERR(err, "inflateEnd");
 
-    if (strcmp((char*)uncompr, hello)) {
+	if (strcmp((char *)uncompr, hello)) {
         fprintf(stderr, "bad inflate with dict\n");
 	exit(1);
     } else {
@@ -507,13 +516,13 @@
  */
 
 int main(argc, argv)
-    int argc;
-    char *argv[];
+int argc;
+char *argv[];
 {
     Byte *compr, *uncompr;
-    uLong comprLen = 10000*sizeof(int); /* don't overflow on MSDOS */
+	uLong comprLen = 10000 * sizeof(int);	/* don't overflow on MSDOS */
     uLong uncomprLen = comprLen;
-    static const char* myVersion = ZLIB_VERSION;
+	static const char *myVersion = ZLIB_VERSION;
 
     if (zlibVersion()[0] != myVersion[0]) {
         fprintf(stderr, "incompatible zlib version\n");
@@ -523,8 +532,8 @@
         fprintf(stderr, "warning: different zlib version\n");
     }
 
-    compr    = (Byte*)calloc((uInt)comprLen, 1);
-    uncompr  = (Byte*)calloc((uInt)uncomprLen, 1);
+	compr = (Byte *) calloc((uInt) comprLen, 1);
+	uncompr = (Byte *) calloc((uInt) uncomprLen, 1);
     /* compr and uncompr are cleared to avoid reading uninitialized
      * data and to ensure that uncompr compresses well.
      */
@@ -535,8 +544,7 @@
     test_compress(compr, comprLen, uncompr, uncomprLen);
 
     test_gzio((argc > 1 ? argv[1] : TESTFILE),
-              (argc > 2 ? argv[2] : TESTFILE),
-	      uncompr, (int)uncomprLen);
+		  (argc > 2 ? argv[2] : TESTFILE), uncompr, (int)uncomprLen);
 
     test_deflate(compr, comprLen);
     test_inflate(compr, comprLen, uncompr, uncomprLen);
--- zlib-1.1.3/gzio.c	1998-07-06 12:41:25.000000000 -0400
+++ zlib-1.1.3/gzio.c	2014-02-07 11:53:21.350326753 -0500
@@ -5,29 +5,31 @@
  * Compile this file with -DNO_DEFLATE to avoid the compression code.
  */
 
-/* @(#) $Id$ */
+/* @(#) $Id: gzio.c,v 1.1 2001/11/09 01:48:02 mpl Exp $ */
 
 #include <stdio.h>
 
 #include "zutil.h"
 
-struct internal_state {int dummy;}; /* for buggy compilers */
+struct internal_state {
+	int dummy;
+};				/* for buggy compilers */
 
 #ifndef Z_BUFSIZE
-#  ifdef MAXSEG_64K
-#    define Z_BUFSIZE 4096 /* minimize memory usage for 16-bit DOS */
-#  else
-#    define Z_BUFSIZE 16384
-#  endif
+#ifdef MAXSEG_64K
+#define Z_BUFSIZE 4096		/* minimize memory usage for 16-bit DOS */
+#else
+#define Z_BUFSIZE 16384
+#endif
 #endif
 #ifndef Z_PRINTF_BUFSIZE
-#  define Z_PRINTF_BUFSIZE 4096
+#define Z_PRINTF_BUFSIZE 4096
 #endif
 
 #define ALLOC(size) malloc(size)
 #define TRYFREE(p) {if (p) free(p);}
 
-static int gz_magic[2] = {0x1f, 0x8b}; /* gzip magic header */
+static int gz_magic[2] = { 0x1f, 0x8b };	/* gzip magic header */
 
 /* gzip flag byte */
 #define ASCII_FLAG   0x01 /* bit 0 set: file probably ascii text */
@@ -52,14 +54,13 @@
     long     startpos; /* start of compressed data in file (header skipped) */
 } gz_stream;
 
-
 local gzFile gz_open      OF((const char *path, const char *mode, int  fd));
 local int do_flush        OF((gzFile file, int flush));
-local int    get_byte     OF((gz_stream *s));
-local void   check_header OF((gz_stream *s));
-local int    destroy      OF((gz_stream *s));
-local void   putLong      OF((FILE *file, uLong x));
-local uLong  getLong      OF((gz_stream *s));
+local int get_byte OF((gz_stream * s));
+local void check_header OF((gz_stream * s));
+local int destroy OF((gz_stream * s));
+local void putLong OF((FILE * file, uLong x));
+local uLong getLong OF((gz_stream * s));
 
 /* ===========================================================================
      Opens a gzip (.gz) file for reading or writing. The mode parameter
@@ -70,27 +71,29 @@
    can be checked to distinguish the two cases (if errno is zero, the
    zlib error is Z_MEM_ERROR).
 */
-local gzFile gz_open (path, mode, fd)
-    const char *path;
-    const char *mode;
-    int  fd;
+local gzFile gz_open(path, mode, fd)
+const char *path;
+const char *mode;
+int fd;
 {
     int err;
     int level = Z_DEFAULT_COMPRESSION; /* compression level */
     int strategy = Z_DEFAULT_STRATEGY; /* compression strategy */
-    char *p = (char*)mode;
+	char *p = (char *)mode;
     gz_stream *s;
     char fmode[80]; /* copy of mode, without the compression level */
     char *m = fmode;
 
-    if (!path || !mode) return Z_NULL;
+	if (!path || !mode)
+		return Z_NULL;
 
-    s = (gz_stream *)ALLOC(sizeof(gz_stream));
-    if (!s) return Z_NULL;
-
-    s->stream.zalloc = (alloc_func)0;
-    s->stream.zfree = (free_func)0;
-    s->stream.opaque = (voidpf)0;
+	s = (gz_stream *) ALLOC(sizeof(gz_stream));
+	if (!s)
+		return Z_NULL;
+
+	s->stream.zalloc = (alloc_func) 0;
+	s->stream.zfree = (free_func) 0;
+	s->stream.opaque = (voidpf) 0;
     s->stream.next_in = s->inbuf = Z_NULL;
     s->stream.next_out = s->outbuf = Z_NULL;
     s->stream.avail_in = s->stream.avail_out = 0;
@@ -101,16 +104,18 @@
     s->msg = NULL;
     s->transparent = 0;
 
-    s->path = (char*)ALLOC(strlen(path)+1);
+	s->path = (char *)ALLOC(strlen(path) + 1);
     if (s->path == NULL) {
-        return destroy(s), (gzFile)Z_NULL;
+		return destroy(s), (gzFile) Z_NULL;
     }
     strcpy(s->path, path); /* do this early for debugging */
 
     s->mode = '\0';
     do {
-        if (*p == 'r') s->mode = 'r';
-        if (*p == 'w' || *p == 'a') s->mode = 'w';
+		if (*p == 'r')
+			s->mode = 'r';
+		if (*p == 'w' || *p == 'a')
+			s->mode = 'w';
         if (*p >= '0' && *p <= '9') {
 	    level = *p - '0';
 	} else if (*p == 'f') {
@@ -121,23 +126,25 @@
 	    *m++ = *p; /* copy the mode */
 	}
     } while (*p++ && m != fmode + sizeof(fmode));
-    if (s->mode == '\0') return destroy(s), (gzFile)Z_NULL;
+	if (s->mode == '\0')
+		return destroy(s), (gzFile) Z_NULL;
     
     if (s->mode == 'w') {
 #ifdef NO_DEFLATE
         err = Z_STREAM_ERROR;
 #else
         err = deflateInit2(&(s->stream), level,
-                           Z_DEFLATED, -MAX_WBITS, DEF_MEM_LEVEL, strategy);
+				   Z_DEFLATED, -MAX_WBITS, DEF_MEM_LEVEL,
+				   strategy);
         /* windowBits is passed < 0 to suppress zlib header */
 
-        s->stream.next_out = s->outbuf = (Byte*)ALLOC(Z_BUFSIZE);
+		s->stream.next_out = s->outbuf = (Byte *) ALLOC(Z_BUFSIZE);
 #endif
         if (err != Z_OK || s->outbuf == Z_NULL) {
-            return destroy(s), (gzFile)Z_NULL;
+			return destroy(s), (gzFile) Z_NULL;
         }
     } else {
-        s->stream.next_in  = s->inbuf = (Byte*)ALLOC(Z_BUFSIZE);
+		s->stream.next_in = s->inbuf = (Byte *) ALLOC(Z_BUFSIZE);
 
         err = inflateInit2(&(s->stream), -MAX_WBITS);
         /* windowBits is passed < 0 to tell that there is no zlib header.
@@ -147,22 +154,23 @@
          * present after the compressed stream.
          */
         if (err != Z_OK || s->inbuf == Z_NULL) {
-            return destroy(s), (gzFile)Z_NULL;
+			return destroy(s), (gzFile) Z_NULL;
         }
     }
     s->stream.avail_out = Z_BUFSIZE;
 
     errno = 0;
-    s->file = fd < 0 ? F_OPEN(path, fmode) : (FILE*)fdopen(fd, fmode);
+	s->file = fd < 0 ? F_OPEN(path, fmode) : (FILE *) fdopen(fd, fmode);
 
     if (s->file == NULL) {
-        return destroy(s), (gzFile)Z_NULL;
+		return destroy(s), (gzFile) Z_NULL;
     }
     if (s->mode == 'w') {
         /* Write a very simple .gz header:
          */
-        fprintf(s->file, "%c%c%c%c%c%c%c%c%c%c", gz_magic[0], gz_magic[1],
-             Z_DEFLATED, 0 /*flags*/, 0,0,0,0 /*time*/, 0 /*xflags*/, OS_CODE);
+		fprintf(s->file, "%c%c%c%c%c%c%c%c%c%c", gz_magic[0],
+			gz_magic[1], Z_DEFLATED, 0 /*flags */ , 0, 0, 0,
+			0 /*time */ , 0 /*xflags */ , OS_CODE);
 	s->startpos = 10L;
 	/* We use 10L instead of ftell(s->file) to because ftell causes an
          * fflush on some systems. This version of the library doesn't use
@@ -174,46 +182,48 @@
 	s->startpos = (ftell(s->file) - s->stream.avail_in);
     }
     
-    return (gzFile)s;
+	return (gzFile) s;
 }
 
 /* ===========================================================================
      Opens a gzip (.gz) file for reading or writing.
 */
-gzFile ZEXPORT gzopen (path, mode)
-    const char *path;
-    const char *mode;
+gzFile ZEXPORT gzopen(path, mode)
+const char *path;
+const char *mode;
 {
-    return gz_open (path, mode, -1);
+	return gz_open(path, mode, -1);
 }
 
 /* ===========================================================================
      Associate a gzFile with the file descriptor fd. fd is not dup'ed here
    to mimic the behavio(u)r of fdopen.
 */
-gzFile ZEXPORT gzdopen (fd, mode)
-    int fd;
-    const char *mode;
+gzFile ZEXPORT gzdopen(fd, mode)
+int fd;
+const char *mode;
 {
     char name[20];
 
-    if (fd < 0) return (gzFile)Z_NULL;
+	if (fd < 0)
+		return (gzFile) Z_NULL;
     sprintf(name, "<fd:%d>", fd); /* for debugging */
 
-    return gz_open (name, mode, fd);
+	return gz_open(name, mode, fd);
 }
 
 /* ===========================================================================
  * Update the compression level and strategy
  */
-int ZEXPORT gzsetparams (file, level, strategy)
-    gzFile file;
-    int level;
-    int strategy;
+int ZEXPORT gzsetparams(file, level, strategy)
+gzFile file;
+int level;
+int strategy;
 {
-    gz_stream *s = (gz_stream*)file;
+	gz_stream *s = (gz_stream *) file;
 
-    if (s == NULL || s->mode != 'w') return Z_STREAM_ERROR;
+	if (s == NULL || s->mode != 'w')
+		return Z_STREAM_ERROR;
 
     /* Make room to allow flushing */
     if (s->stream.avail_out == 0) {
@@ -225,7 +235,7 @@
 	s->stream.avail_out = Z_BUFSIZE;
     }
 
-    return deflateParams (&(s->stream), level, strategy);
+	return deflateParams(&(s->stream), level, strategy);
 }
 
 /* ===========================================================================
@@ -234,15 +244,17 @@
    IN assertion: the stream s has been sucessfully opened for reading.
 */
 local int get_byte(s)
-    gz_stream *s;
+gz_stream *s;
 {
-    if (s->z_eof) return EOF;
+	if (s->z_eof)
+		return EOF;
     if (s->stream.avail_in == 0) {
 	errno = 0;
 	s->stream.avail_in = fread(s->inbuf, 1, Z_BUFSIZE, s->file);
 	if (s->stream.avail_in == 0) {
 	    s->z_eof = 1;
-	    if (ferror(s->file)) s->z_err = Z_ERRNO;
+			if (ferror(s->file))
+				s->z_err = Z_ERRNO;
 	    return EOF;
 	}
 	s->stream.next_in = s->inbuf;
@@ -261,7 +273,7 @@
        for concatenated .gz files.
 */
 local void check_header(s)
-    gz_stream *s;
+gz_stream *s;
 {
     int method; /* method byte */
     int flags;  /* flags byte */
@@ -272,12 +284,14 @@
     for (len = 0; len < 2; len++) {
 	c = get_byte(s);
 	if (c != gz_magic[len]) {
-	    if (len != 0) s->stream.avail_in++, s->stream.next_in--;
+			if (len != 0)
+				s->stream.avail_in++, s->stream.next_in--;
 	    if (c != EOF) {
 		s->stream.avail_in++, s->stream.next_in--;
 		s->transparent = 1;
 	    }
-	    s->z_err = s->stream.avail_in != 0 ? Z_OK : Z_STREAM_END;
+			s->z_err =
+			    s->stream.avail_in != 0 ? Z_OK : Z_STREAM_END;
 	    return;
 	}
     }
@@ -289,11 +303,12 @@
     }
 
     /* Discard time, xflags and OS code: */
-    for (len = 0; len < 6; len++) (void)get_byte(s);
+	for (len = 0; len < 6; len++)
+		(void)get_byte(s);
 
     if ((flags & EXTRA_FIELD) != 0) { /* skip the extra field */
-	len  =  (uInt)get_byte(s);
-	len += ((uInt)get_byte(s))<<8;
+		len = (uInt) get_byte(s);
+		len += ((uInt) get_byte(s)) << 8;
 	/* len is garbage if EOF but the loop below will quit anyway */
 	while (len-- != 0 && get_byte(s) != EOF) ;
     }
@@ -304,7 +319,8 @@
 	while ((c = get_byte(s)) != 0 && c != EOF) ;
     }
     if ((flags & HEAD_CRC) != 0) {  /* skip the header crc */
-	for (len = 0; len < 2; len++) (void)get_byte(s);
+		for (len = 0; len < 2; len++)
+			(void)get_byte(s);
     }
     s->z_err = s->z_eof ? Z_DATA_ERROR : Z_OK;
 }
@@ -313,12 +329,13 @@
  * Cleanup then free the given gz_stream. Return a zlib error code.
    Try freeing in the reverse order of allocations.
  */
-local int destroy (s)
-    gz_stream *s;
+local int destroy(s)
+gz_stream *s;
 {
     int err = Z_OK;
 
-    if (!s) return Z_STREAM_ERROR;
+	if (!s)
+		return Z_STREAM_ERROR;
 
     TRYFREE(s->msg);
 
@@ -339,7 +356,8 @@
 #endif
 	    err = Z_ERRNO;
     }
-    if (s->z_err < 0) err = s->z_err;
+	if (s->z_err < 0)
+		err = s->z_err;
 
     TRYFREE(s->inbuf);
     TRYFREE(s->outbuf);
@@ -352,22 +370,25 @@
      Reads the given number of uncompressed bytes from the compressed file.
    gzread returns the number of bytes actually read (0 for end of file).
 */
-int ZEXPORT gzread (file, buf, len)
-    gzFile file;
-    voidp buf;
-    unsigned len;
+int ZEXPORT gzread(file, buf, len)
+gzFile file;
+voidp buf;
+unsigned len;
 {
-    gz_stream *s = (gz_stream*)file;
-    Bytef *start = (Bytef*)buf; /* starting point for crc computation */
+	gz_stream *s = (gz_stream *) file;
+	Bytef *start = (Bytef *) buf;	/* starting point for crc computation */
     Byte  *next_out; /* == stream.next_out but not forced far (for MSDOS) */
 
-    if (s == NULL || s->mode != 'r') return Z_STREAM_ERROR;
+	if (s == NULL || s->mode != 'r')
+		return Z_STREAM_ERROR;
 
-    if (s->z_err == Z_DATA_ERROR || s->z_err == Z_ERRNO) return -1;
-    if (s->z_err == Z_STREAM_END) return 0;  /* EOF */
+	if (s->z_err == Z_DATA_ERROR || s->z_err == Z_ERRNO)
+		return -1;
+	if (s->z_err == Z_STREAM_END)
+		return 0;	/* EOF */
 
-    next_out = (Byte*)buf;
-    s->stream.next_out = (Bytef*)buf;
+	next_out = (Byte *) buf;
+	s->stream.next_out = (Bytef *) buf;
     s->stream.avail_out = len;
 
     while (s->stream.avail_out != 0) {
@@ -375,9 +396,11 @@
 	if (s->transparent) {
 	    /* Copy first the lookahead bytes: */
 	    uInt n = s->stream.avail_in;
-	    if (n > s->stream.avail_out) n = s->stream.avail_out;
+			if (n > s->stream.avail_out)
+				n = s->stream.avail_out;
 	    if (n > 0) {
-		zmemcpy(s->stream.next_out, s->stream.next_in, n);
+				zmemcpy(s->stream.next_out, s->stream.next_in,
+					n);
 		next_out += n;
 		s->stream.next_out = next_out;
 		s->stream.next_in   += n;
@@ -385,19 +408,22 @@
 		s->stream.avail_in  -= n;
 	    }
 	    if (s->stream.avail_out > 0) {
-		s->stream.avail_out -= fread(next_out, 1, s->stream.avail_out,
+				s->stream.avail_out -=
+				    fread(next_out, 1, s->stream.avail_out,
 					     s->file);
 	    }
 	    len -= s->stream.avail_out;
-	    s->stream.total_in  += (uLong)len;
-	    s->stream.total_out += (uLong)len;
-            if (len == 0) s->z_eof = 1;
+			s->stream.total_in += (uLong) len;
+			s->stream.total_out += (uLong) len;
+			if (len == 0)
+				s->z_eof = 1;
 	    return (int)len;
 	}
         if (s->stream.avail_in == 0 && !s->z_eof) {
 
             errno = 0;
-            s->stream.avail_in = fread(s->inbuf, 1, Z_BUFSIZE, s->file);
+			s->stream.avail_in =
+			    fread(s->inbuf, 1, Z_BUFSIZE, s->file);
             if (s->stream.avail_in == 0) {
                 s->z_eof = 1;
 		if (ferror(s->file)) {
@@ -411,7 +437,9 @@
 
 	if (s->z_err == Z_STREAM_END) {
 	    /* Check CRC and original size */
-	    s->crc = crc32(s->crc, start, (uInt)(s->stream.next_out - start));
+			s->crc =
+			    crc32(s->crc, start,
+				  (uInt) (s->stream.next_out - start));
 	    start = s->stream.next_out;
 
 	    if (getLong(s) != s->crc) {
@@ -434,9 +462,10 @@
 		}
 	    }
 	}
-	if (s->z_err != Z_OK || s->z_eof) break;
+		if (s->z_err != Z_OK || s->z_eof)
+			break;
     }
-    s->crc = crc32(s->crc, start, (uInt)(s->stream.next_out - start));
+	s->crc = crc32(s->crc, start, (uInt) (s->stream.next_out - start));
 
     return (int)(len - s->stream.avail_out);
 }
@@ -447,7 +475,7 @@
    or -1 in case of end of file or error.
 */
 int ZEXPORT gzgetc(file)
-    gzFile file;
+gzFile file;
 {
     unsigned char c;
 
@@ -464,13 +491,14 @@
 
       The current implementation is not optimized at all.
 */
-char * ZEXPORT gzgets(file, buf, len)
-    gzFile file;
-    char *buf;
-    int len;
+char *ZEXPORT gzgets(file, buf, len)
+gzFile file;
+char *buf;
+int len;
 {
     char *b = buf;
-    if (buf == Z_NULL || len <= 0) return Z_NULL;
+	if (buf == Z_NULL || len <= 0)
+		return Z_NULL;
 
     while (--len > 0 && gzread(file, buf, 1) == 1 && *buf++ != '\n') ;
     *buf = '\0';
@@ -483,16 +510,17 @@
      Writes the given number of uncompressed bytes into the compressed file.
    gzwrite returns the number of bytes actually written (0 in case of error).
 */
-int ZEXPORT gzwrite (file, buf, len)
-    gzFile file;
-    const voidp buf;
-    unsigned len;
+int ZEXPORT gzwrite(file, buf, len)
+gzFile file;
+const voidp buf;
+unsigned len;
 {
-    gz_stream *s = (gz_stream*)file;
+	gz_stream *s = (gz_stream *) file;
 
-    if (s == NULL || s->mode != 'w') return Z_STREAM_ERROR;
+	if (s == NULL || s->mode != 'w')
+		return Z_STREAM_ERROR;
 
-    s->stream.next_in = (Bytef*)buf;
+	s->stream.next_in = (Bytef *) buf;
     s->stream.avail_in = len;
 
     while (s->stream.avail_in != 0) {
@@ -500,14 +528,16 @@
         if (s->stream.avail_out == 0) {
 
             s->stream.next_out = s->outbuf;
-            if (fwrite(s->outbuf, 1, Z_BUFSIZE, s->file) != Z_BUFSIZE) {
+			if (fwrite(s->outbuf, 1, Z_BUFSIZE, s->file) !=
+			    Z_BUFSIZE) {
                 s->z_err = Z_ERRNO;
                 break;
             }
             s->stream.avail_out = Z_BUFSIZE;
         }
         s->z_err = deflate(&(s->stream), Z_NO_FLUSH);
-        if (s->z_err != Z_OK) break;
+		if (s->z_err != Z_OK)
+			break;
     }
     s->crc = crc32(s->crc, (const Bytef *)buf, len);
 
@@ -522,7 +552,7 @@
 #ifdef STDC
 #include <stdarg.h>
 
-int ZEXPORTVA gzprintf (gzFile file, const char *format, /* args */ ...)
+int ZEXPORTVA gzprintf(gzFile file, const char *format, /* args */ ...)
 {
     char buf[Z_PRINTF_BUFSIZE];
     va_list va;
@@ -536,17 +566,18 @@
 #endif
     va_end(va);
     len = strlen(buf); /* some *sprintf don't return the nb of bytes written */
-    if (len <= 0) return 0;
+	if (len <= 0)
+		return 0;
 
     return gzwrite(file, buf, (unsigned)len);
 }
 #else /* not ANSI C */
 
-int ZEXPORTVA gzprintf (file, format, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10,
+int ZEXPORTVA gzprintf(file, format, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10,
 	               a11, a12, a13, a14, a15, a16, a17, a18, a19, a20)
-    gzFile file;
-    const char *format;
-    int a1, a2, a3, a4, a5, a6, a7, a8, a9, a10,
+gzFile file;
+const char *format;
+int a1, a2, a3, a4, a5, a6, a7, a8, a9, a10,
 	a11, a12, a13, a14, a15, a16, a17, a18, a19, a20;
 {
     char buf[Z_PRINTF_BUFSIZE];
@@ -560,7 +591,8 @@
 	    a9, a10, a11, a12, a13, a14, a15, a16, a17, a18, a19, a20);
 #endif
     len = strlen(buf); /* old sprintf doesn't return the nb of bytes written */
-    if (len <= 0) return 0;
+	if (len <= 0)
+		return 0;
 
     return gzwrite(file, buf, len);
 }
@@ -571,10 +603,10 @@
    gzputc returns the value that was written, or -1 in case of error.
 */
 int ZEXPORT gzputc(file, c)
-    gzFile file;
-    int c;
+gzFile file;
+int c;
 {
-    unsigned char cc = (unsigned char) c; /* required for big endian systems */
+	unsigned char cc = (unsigned char)c;	/* required for big endian systems */
 
     return gzwrite(file, &cc, 1) == 1 ? (int)cc : -1;
 }
@@ -586,13 +617,12 @@
       gzputs returns the number of characters written, or -1 in case of error.
 */
 int ZEXPORT gzputs(file, s)
-    gzFile file;
-    const char *s;
+gzFile file;
+const char *s;
 {
-    return gzwrite(file, (char*)s, (unsigned)strlen(s));
+	return gzwrite(file, (char *)s, (unsigned)strlen(s));
 }
 
-
 /* ===========================================================================
      Flushes all pending output into the compressed file. The parameter
    flush is as in the deflate() function.
@@ -597,15 +627,16 @@
      Flushes all pending output into the compressed file. The parameter
    flush is as in the deflate() function.
 */
-local int do_flush (file, flush)
-    gzFile file;
-    int flush;
+local int do_flush(file, flush)
+gzFile file;
+int flush;
 {
     uInt len;
     int done = 0;
-    gz_stream *s = (gz_stream*)file;
+	gz_stream *s = (gz_stream *) file;
 
-    if (s == NULL || s->mode != 'w') return Z_STREAM_ERROR;
+	if (s == NULL || s->mode != 'w')
+		return Z_STREAM_ERROR;
 
     s->stream.avail_in = 0; /* should be zero already anyway */
 
@@ -613,37 +644,41 @@
         len = Z_BUFSIZE - s->stream.avail_out;
 
         if (len != 0) {
-            if ((uInt)fwrite(s->outbuf, 1, len, s->file) != len) {
+			if ((uInt) fwrite(s->outbuf, 1, len, s->file) != len) {
                 s->z_err = Z_ERRNO;
                 return Z_ERRNO;
             }
             s->stream.next_out = s->outbuf;
             s->stream.avail_out = Z_BUFSIZE;
         }
-        if (done) break;
+		if (done)
+			break;
         s->z_err = deflate(&(s->stream), flush);
 
 	/* Ignore the second of two consecutive flushes: */
-	if (len == 0 && s->z_err == Z_BUF_ERROR) s->z_err = Z_OK;
+		if (len == 0 && s->z_err == Z_BUF_ERROR)
+			s->z_err = Z_OK;
 
         /* deflate has finished flushing only when it hasn't used up
          * all the available space in the output buffer: 
          */
         done = (s->stream.avail_out != 0 || s->z_err == Z_STREAM_END);
  
-        if (s->z_err != Z_OK && s->z_err != Z_STREAM_END) break;
+		if (s->z_err != Z_OK && s->z_err != Z_STREAM_END)
+			break;
     }
     return  s->z_err == Z_STREAM_END ? Z_OK : s->z_err;
 }
 
-int ZEXPORT gzflush (file, flush)
-     gzFile file;
-     int flush;
+int ZEXPORT gzflush(file, flush)
+gzFile file;
+int flush;
 {
-    gz_stream *s = (gz_stream*)file;
-    int err = do_flush (file, flush);
+	gz_stream *s = (gz_stream *) file;
+	int err = do_flush(file, flush);
 
-    if (err) return err;
+	if (err)
+		return err;
     fflush(s->file);
     return  s->z_err == Z_STREAM_END ? Z_OK : s->z_err;
 }
@@ -657,12 +692,12 @@
       SEEK_END is not implemented, returns error.
       In this version of the library, gzseek can be extremely slow.
 */
-z_off_t ZEXPORT gzseek (file, offset, whence)
-    gzFile file;
-    z_off_t offset;
-    int whence;
+z_off_t ZEXPORT gzseek(file, offset, whence)
+gzFile file;
+z_off_t offset;
+int whence;
 {
-    gz_stream *s = (gz_stream*)file;
+	gz_stream *s = (gz_stream *) file;
 
     if (s == NULL || whence == SEEK_END ||
 	s->z_err == Z_ERRNO || s->z_err == Z_DATA_ERROR) {
@@ -676,23 +711,26 @@
 	if (whence == SEEK_SET) {
 	    offset -= s->stream.total_in;
 	}
-	if (offset < 0) return -1L;
+		if (offset < 0)
+			return -1L;
 
 	/* At this point, offset is the number of zero bytes to write. */
 	if (s->inbuf == Z_NULL) {
-	    s->inbuf = (Byte*)ALLOC(Z_BUFSIZE); /* for seeking */
+			s->inbuf = (Byte *) ALLOC(Z_BUFSIZE);	/* for seeking */
 	    zmemzero(s->inbuf, Z_BUFSIZE);
 	}
 	while (offset > 0)  {
 	    uInt size = Z_BUFSIZE;
-	    if (offset < Z_BUFSIZE) size = (uInt)offset;
+			if (offset < Z_BUFSIZE)
+				size = (uInt) offset;
 
 	    size = gzwrite(file, s->inbuf, size);
-	    if (size == 0) return -1L;
+			if (size == 0)
+				return -1L;
 
 	    offset -= size;
 	}
-	return (z_off_t)s->stream.total_in;
+		return (z_off_t) s->stream.total_in;
 #endif
     }
     /* Rest of function is for reading only */
@@ -701,20 +739,22 @@
     if (whence == SEEK_CUR) {
 	offset += s->stream.total_out;
     }
-    if (offset < 0) return -1L;
+	if (offset < 0)
+		return -1L;
 
     if (s->transparent) {
 	/* map to fseek */
 	s->stream.avail_in = 0;
 	s->stream.next_in = s->inbuf;
-        if (fseek(s->file, offset, SEEK_SET) < 0) return -1L;
+		if (fseek(s->file, offset, SEEK_SET) < 0)
+			return -1L;
 
-	s->stream.total_in = s->stream.total_out = (uLong)offset;
+		s->stream.total_in = s->stream.total_out = (uLong) offset;
 	return offset;
     }
 
     /* For a negative seek, rewind and use positive seek */
-    if ((uLong)offset >= s->stream.total_out) {
+	if ((uLong) offset >= s->stream.total_out) {
 	offset -= s->stream.total_out;
     } else if (gzrewind(file) < 0) {
 	return -1L;
@@ -722,28 +762,31 @@
     /* offset is now the number of bytes to skip. */
 
     if (offset != 0 && s->outbuf == Z_NULL) {
-	s->outbuf = (Byte*)ALLOC(Z_BUFSIZE);
+		s->outbuf = (Byte *) ALLOC(Z_BUFSIZE);
     }
     while (offset > 0)  {
 	int size = Z_BUFSIZE;
-	if (offset < Z_BUFSIZE) size = (int)offset;
+		if (offset < Z_BUFSIZE)
+			size = (int)offset;
 
-	size = gzread(file, s->outbuf, (uInt)size);
-	if (size <= 0) return -1L;
+		size = gzread(file, s->outbuf, (uInt) size);
+		if (size <= 0)
+			return -1L;
 	offset -= size;
     }
-    return (z_off_t)s->stream.total_out;
+	return (z_off_t) s->stream.total_out;
 }
 
 /* ===========================================================================
      Rewinds input file. 
 */
-int ZEXPORT gzrewind (file)
-    gzFile file;
+int ZEXPORT gzrewind(file)
+gzFile file;
 {
-    gz_stream *s = (gz_stream*)file;
+	gz_stream *s = (gz_stream *) file;
     
-    if (s == NULL || s->mode != 'r') return -1;
+	if (s == NULL || s->mode != 'r')
+		return -1;
 
     s->z_err = Z_OK;
     s->z_eof = 0;
@@ -756,7 +799,7 @@
 	return 0;
     }
 
-    (void) inflateReset(&s->stream);
+	(void)inflateReset(&s->stream);
     return fseek(s->file, s->startpos, SEEK_SET);
 }
 
@@ -765,8 +808,8 @@
    given compressed file. This position represents a number of bytes in the
    uncompressed data stream.
 */
-z_off_t ZEXPORT gztell (file)
-    gzFile file;
+z_off_t ZEXPORT gztell(file)
+gzFile file;
 {
     return gzseek(file, 0L, SEEK_CUR);
 }
@@ -775,10 +818,10 @@
      Returns 1 when EOF has previously been detected reading the given
    input stream, otherwise zero.
 */
-int ZEXPORT gzeof (file)
-    gzFile file;
+int ZEXPORT gzeof(file)
+gzFile file;
 {
-    gz_stream *s = (gz_stream*)file;
+	gz_stream *s = (gz_stream *) file;
     
     return (s == NULL || s->mode != 'r') ? 0 : s->z_eof;
 }
@@ -786,9 +829,9 @@
 /* ===========================================================================
    Outputs a long in LSB order to the given file
 */
-local void putLong (file, x)
-    FILE *file;
-    uLong x;
+local void putLong(file, x)
+FILE *file;
+uLong x;
 {
     int n;
     for (n = 0; n < 4; n++) {
@@ -801,17 +844,18 @@
    Reads a long in LSB order from the given gz_stream. Sets z_err in case
    of error.
 */
-local uLong getLong (s)
-    gz_stream *s;
+local uLong getLong(s)
+gz_stream *s;
 {
-    uLong x = (uLong)get_byte(s);
+	uLong x = (uLong) get_byte(s);
     int c;
 
-    x += ((uLong)get_byte(s))<<8;
-    x += ((uLong)get_byte(s))<<16;
+	x += ((uLong) get_byte(s)) << 8;
+	x += ((uLong) get_byte(s)) << 16;
     c = get_byte(s);
-    if (c == EOF) s->z_err = Z_DATA_ERROR;
-    x += ((uLong)c)<<24;
+	if (c == EOF)
+		s->z_err = Z_DATA_ERROR;
+	x += ((uLong) c) << 24;
     return x;
 }
 
@@ -819,26 +863,28 @@
      Flushes all pending output if necessary, closes the compressed file
    and deallocates all the (de)compression state.
 */
-int ZEXPORT gzclose (file)
-    gzFile file;
+int ZEXPORT gzclose(file)
+gzFile file;
 {
     int err;
-    gz_stream *s = (gz_stream*)file;
+	gz_stream *s = (gz_stream *) file;
 
-    if (s == NULL) return Z_STREAM_ERROR;
+	if (s == NULL)
+		return Z_STREAM_ERROR;
 
     if (s->mode == 'w') {
 #ifdef NO_DEFLATE
 	return Z_STREAM_ERROR;
 #else
-        err = do_flush (file, Z_FINISH);
-        if (err != Z_OK) return destroy((gz_stream*)file);
+		err = do_flush(file, Z_FINISH);
+		if (err != Z_OK)
+			return destroy((gz_stream *) file);
 
-        putLong (s->file, s->crc);
-        putLong (s->file, s->stream.total_in);
+		putLong(s->file, s->crc);
+		putLong(s->file, s->stream.total_in);
 #endif
     }
-    return destroy((gz_stream*)file);
+	return destroy((gz_stream *) file);
 }
 
 /* ===========================================================================
@@ -848,28 +894,30 @@
    errnum is set to Z_ERRNO and the application may consult errno
    to get the exact error code.
 */
-const char*  ZEXPORT gzerror (file, errnum)
-    gzFile file;
-    int *errnum;
+const char *ZEXPORT gzerror(file, errnum)
+gzFile file;
+int *errnum;
 {
     char *m;
-    gz_stream *s = (gz_stream*)file;
+	gz_stream *s = (gz_stream *) file;
 
     if (s == NULL) {
         *errnum = Z_STREAM_ERROR;
-        return (const char*)ERR_MSG(Z_STREAM_ERROR);
+		return (const char *)ERR_MSG(Z_STREAM_ERROR);
     }
     *errnum = s->z_err;
-    if (*errnum == Z_OK) return (const char*)"";
+	if (*errnum == Z_OK)
+		return (const char *)"";
 
-    m =  (char*)(*errnum == Z_ERRNO ? zstrerror(errno) : s->stream.msg);
+	m = (char *)(*errnum == Z_ERRNO ? zstrerror(errno) : s->stream.msg);
 
-    if (m == NULL || *m == '\0') m = (char*)ERR_MSG(s->z_err);
+	if (m == NULL || *m == '\0')
+		m = (char *)ERR_MSG(s->z_err);
 
     TRYFREE(s->msg);
-    s->msg = (char*)ALLOC(strlen(s->path) + strlen(m) + 3);
+	s->msg = (char *)ALLOC(strlen(s->path) + strlen(m) + 3);
     strcpy(s->msg, s->path);
     strcat(s->msg, ": ");
     strcat(s->msg, m);
-    return (const char*)s->msg;
+	return (const char *)s->msg;
 }
--- zlib-1.1.3/infblock.c	1998-06-08 13:06:16.000000000 -0400
+++ zlib-1.1.3/infblock.c	2014-02-07 11:53:21.350326753 -0500
@@ -9,7 +9,9 @@
 #include "infcodes.h"
 #include "infutil.h"
 
-struct inflate_codes_state {int dummy;}; /* for buggy compilers */
+struct inflate_codes_state {
+	int dummy;
+};				/* for buggy compilers */
 
 /* simplify the use of the inflate_huft type with some defines */
 #define exop word.what.Exop
@@ -17,7 +19,8 @@
 
 /* Table for deflate from PKZIP's appnote.txt. */
 local const uInt border[] = { /* Order of the bit length code lengths */
-        16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15};
+	16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15
+};
 
 /*
    Notes beyond the 1.93a appnote.txt:
@@ -81,7 +83,8 @@
   s->bitb = 0;
   s->read = s->write = s->window;
   if (s->checkfn != Z_NULL)
-    z->adler = s->check = (*s->checkfn)(0L, (const Bytef *)Z_NULL, 0);
+		z->adler = s->check =
+		    (*s->checkfn) (0L, (const Bytef *)Z_NULL, 0);
   Tracev((stderr, "inflate:   blocks reset\n"));
 }
 
@@ -93,17 +95,16 @@
 {
   inflate_blocks_statef *s;
 
-  if ((s = (inflate_blocks_statef *)ZALLOC
-       (z,1,sizeof(struct inflate_blocks_state))) == Z_NULL)
+	if ((s = (inflate_blocks_statef *) ZALLOC
+	     (z, 1, sizeof(struct inflate_blocks_state))) == Z_NULL)
     return s;
   if ((s->hufts =
-       (inflate_huft *)ZALLOC(z, sizeof(inflate_huft), MANY)) == Z_NULL)
+	     (inflate_huft *) ZALLOC(z, sizeof(inflate_huft), MANY)) == Z_NULL)
   {
     ZFREE(z, s);
     return Z_NULL;
   }
-  if ((s->window = (Bytef *)ZALLOC(z, 1, w)) == Z_NULL)
-  {
+	if ((s->window = (Bytef *) ZALLOC(z, 1, w)) == Z_NULL) {
     ZFREE(z, s->hufts);
     ZFREE(z, s);
     return Z_NULL;
@@ -132,16 +132,14 @@
 
   /* copy input/output information to locals (UPDATE macro restores) */
   LOAD
-
   /* process input based on current state */
-  while (1) switch (s->mode)
-  {
+	    while (1)
+		switch (s->mode) {
     case TYPE:
       NEEDBITS(3)
-      t = (uInt)b & 7;
+			    t = (uInt) b & 7;
       s->last = t & 1;
-      switch (t >> 1)
-      {
+			switch (t >> 1) {
         case 0:                         /* stored */
           Tracev((stderr, "inflate:     stored block%s\n",
                  s->last ? " (last)" : ""));
@@ -151,25 +149,28 @@
           s->mode = LENS;               /* get length of stored block */
           break;
         case 1:                         /* fixed */
-          Tracev((stderr, "inflate:     fixed codes block%s\n",
+				Tracev((stderr,
+					"inflate:     fixed codes block%s\n",
                  s->last ? " (last)" : ""));
           {
             uInt bl, bd;
             inflate_huft *tl, *td;
 
-            inflate_trees_fixed(&bl, &bd, &tl, &td, z);
-            s->sub.decode.codes = inflate_codes_new(bl, bd, tl, td, z);
-            if (s->sub.decode.codes == Z_NULL)
-            {
+					inflate_trees_fixed(&bl, &bd, &tl, &td,
+							    z);
+					s->sub.decode.codes =
+					    inflate_codes_new(bl, bd, tl, td,
+							      z);
+					if (s->sub.decode.codes == Z_NULL) {
               r = Z_MEM_ERROR;
-              LEAVE
-            }
+					LEAVE}
           }
           DUMPBITS(3)
           s->mode = CODES;
           break;
         case 2:                         /* dynamic */
-          Tracev((stderr, "inflate:     dynamic codes block%s\n",
+				Tracev((stderr,
+					"inflate:     dynamic codes block%s\n",
                  s->last ? " (last)" : ""));
           DUMPBITS(3)
           s->mode = TABLE;
@@ -177,124 +178,131 @@
         case 3:                         /* illegal */
           DUMPBITS(3)
           s->mode = BAD;
-          z->msg = (char*)"invalid block type";
+				z->msg = (char *)"invalid block type";
           r = Z_DATA_ERROR;
-          LEAVE
-      }
+			LEAVE}
       break;
     case LENS:
       NEEDBITS(32)
-      if ((((~b) >> 16) & 0xffff) != (b & 0xffff))
-      {
+			    if ((((~b) >> 16) & 0xffff) != (b & 0xffff)) {
         s->mode = BAD;
-        z->msg = (char*)"invalid stored block lengths";
+				z->msg = (char *)"invalid stored block lengths";
         r = Z_DATA_ERROR;
-        LEAVE
-      }
-      s->sub.left = (uInt)b & 0xffff;
+			LEAVE}
+			s->sub.left = (uInt) b & 0xffff;
       b = k = 0;                      /* dump bits */
-      Tracev((stderr, "inflate:       stored length %u\n", s->sub.left));
+			Tracev((stderr, "inflate:       stored length %u\n",
+				s->sub.left));
       s->mode = s->sub.left ? STORED : (s->last ? DRY : TYPE);
       break;
     case STORED:
       if (n == 0)
-        LEAVE
-      NEEDOUT
-      t = s->sub.left;
-      if (t > n) t = n;
-      if (t > m) t = m;
+				LEAVE NEEDOUT t = s->sub.left;
+			if (t > n)
+				t = n;
+			if (t > m)
+				t = m;
       zmemcpy(q, p, t);
-      p += t;  n -= t;
-      q += t;  m -= t;
+			p += t;
+			n -= t;
+			q += t;
+			m -= t;
       if ((s->sub.left -= t) != 0)
         break;
-      Tracev((stderr, "inflate:       stored end, %lu total out\n",
-              z->total_out + (q >= s->read ? q - s->read :
-              (s->end - s->read) + (q - s->window))));
+			Tracev((stderr,
+				"inflate:       stored end, %lu total out\n",
+				z->total_out + (q >=
+						s->read ? q -
+						s->read : (s->end - s->read) +
+						(q - s->window))));
       s->mode = s->last ? DRY : TYPE;
       break;
     case TABLE:
       NEEDBITS(14)
-      s->sub.trees.table = t = (uInt)b & 0x3fff;
+			    s->sub.trees.table = t = (uInt) b & 0x3fff;
 #ifndef PKZIP_BUG_WORKAROUND
-      if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)
-      {
+			if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {
         s->mode = BAD;
-        z->msg = (char*)"too many length or distance symbols";
+				z->msg = (char *)
+				    "too many length or distance symbols";
         r = Z_DATA_ERROR;
-        LEAVE
-      }
+			LEAVE}
 #endif
       t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);
-      if ((s->sub.trees.blens = (uIntf*)ZALLOC(z, t, sizeof(uInt))) == Z_NULL)
-      {
+			if ((s->sub.trees.blens =
+			     (uIntf *) ZALLOC(z, t, sizeof(uInt))) == Z_NULL) {
         r = Z_MEM_ERROR;
-        LEAVE
-      }
+			LEAVE}
       DUMPBITS(14)
       s->sub.trees.index = 0;
       Tracev((stderr, "inflate:       table sizes ok\n"));
       s->mode = BTREE;
     case BTREE:
-      while (s->sub.trees.index < 4 + (s->sub.trees.table >> 10))
-      {
+			while (s->sub.trees.index <
+			       4 + (s->sub.trees.table >> 10)) {
         NEEDBITS(3)
-        s->sub.trees.blens[border[s->sub.trees.index++]] = (uInt)b & 7;
+				    s->sub.
+				    trees.blens[border[s->sub.trees.index++]] =
+				    (uInt) b & 7;
         DUMPBITS(3)
       }
       while (s->sub.trees.index < 19)
-        s->sub.trees.blens[border[s->sub.trees.index++]] = 0;
+				s->sub.
+				    trees.blens[border[s->sub.trees.index++]] =
+				    0;
       s->sub.trees.bb = 7;
-      t = inflate_trees_bits(s->sub.trees.blens, &s->sub.trees.bb,
+			t = inflate_trees_bits(s->sub.trees.blens,
+					       &s->sub.trees.bb,
                              &s->sub.trees.tb, s->hufts, z);
-      if (t != Z_OK)
-      {
+			if (t != Z_OK) {
         ZFREE(z, s->sub.trees.blens);
         r = t;
         if (r == Z_DATA_ERROR)
           s->mode = BAD;
-        LEAVE
-      }
+			LEAVE}
       s->sub.trees.index = 0;
       Tracev((stderr, "inflate:       bits tree ok\n"));
       s->mode = DTREE;
     case DTREE:
       while (t = s->sub.trees.table,
-             s->sub.trees.index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f))
-      {
+			       s->sub.trees.index <
+			       258 + (t & 0x1f) + ((t >> 5) & 0x1f)) {
         inflate_huft *h;
         uInt i, j, c;
 
         t = s->sub.trees.bb;
         NEEDBITS(t)
-        h = s->sub.trees.tb + ((uInt)b & inflate_mask[t]);
+				    h =
+				    s->sub.trees.tb +
+				    ((uInt) b & inflate_mask[t]);
         t = h->bits;
         c = h->base;
-        if (c < 16)
-        {
+				if (c < 16) {
           DUMPBITS(t)
-          s->sub.trees.blens[s->sub.trees.index++] = c;
-        }
-        else /* c == 16..18 */
-        {
+					    s->sub.trees.blens[s->sub.
+							       trees.index++] =
+					    c;
+				} else {	/* c == 16..18 */
+
           i = c == 18 ? 7 : c - 14;
           j = c == 18 ? 11 : 3;
           NEEDBITS(t + i)
           DUMPBITS(t)
-          j += (uInt)b & inflate_mask[i];
+					    j += (uInt) b & inflate_mask[i];
           DUMPBITS(i)
           i = s->sub.trees.index;
           t = s->sub.trees.table;
-          if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) ||
-              (c == 16 && i < 1))
-          {
+					if (i + j >
+					    258 + (t & 0x1f) + ((t >> 5) & 0x1f)
+					    || (c == 16 && i < 1)) {
             ZFREE(z, s->sub.trees.blens);
             s->mode = BAD;
-            z->msg = (char*)"invalid bit length repeat";
+						z->msg = (char *)
+						    "invalid bit length repeat";
             r = Z_DATA_ERROR;
-            LEAVE
-          }
-          c = c == 16 ? s->sub.trees.blens[i - 1] : 0;
+					LEAVE}
+					c = c ==
+					    16 ? s->sub.trees.blens[i - 1] : 0;
           do {
             s->sub.trees.blens[i++] = c;
           } while (--j);
@@ -310,60 +318,53 @@
         bl = 9;         /* must be <= 9 for lookahead assumptions */
         bd = 6;         /* must be <= 9 for lookahead assumptions */
         t = s->sub.trees.table;
-        t = inflate_trees_dynamic(257 + (t & 0x1f), 1 + ((t >> 5) & 0x1f),
-                                  s->sub.trees.blens, &bl, &bd, &tl, &td,
+				t = inflate_trees_dynamic(257 + (t & 0x1f),
+							  1 + ((t >> 5) & 0x1f),
+							  s->sub.trees.blens,
+							  &bl, &bd, &tl, &td,
                                   s->hufts, z);
         ZFREE(z, s->sub.trees.blens);
-        if (t != Z_OK)
-        {
-          if (t == (uInt)Z_DATA_ERROR)
+				if (t != Z_OK) {
+					if (t == (uInt) Z_DATA_ERROR)
             s->mode = BAD;
           r = t;
-          LEAVE
-        }
+				LEAVE}
         Tracev((stderr, "inflate:       trees ok\n"));
-        if ((c = inflate_codes_new(bl, bd, tl, td, z)) == Z_NULL)
-        {
+				if ((c =
+				     inflate_codes_new(bl, bd, tl, td,
+						       z)) == Z_NULL) {
           r = Z_MEM_ERROR;
-          LEAVE
-        }
+				LEAVE}
         s->sub.decode.codes = c;
       }
       s->mode = CODES;
     case CODES:
-      UPDATE
-      if ((r = inflate_codes(s, z, r)) != Z_STREAM_END)
+			UPDATE if ((r = inflate_codes(s, z, r)) != Z_STREAM_END)
         return inflate_flush(s, z, r);
       r = Z_OK;
       inflate_codes_free(s->sub.decode.codes, z);
-      LOAD
-      Tracev((stderr, "inflate:       codes end, %lu total out\n",
-              z->total_out + (q >= s->read ? q - s->read :
-              (s->end - s->read) + (q - s->window))));
-      if (!s->last)
-      {
+			LOAD Tracev((stderr,
+				     "inflate:       codes end, %lu total out\n",
+				     z->total_out + (q >=
+						     s->read ? q -
+						     s->read : (s->end -
+								s->read) + (q -
+									    s->window))));
+			if (!s->last) {
         s->mode = TYPE;
         break;
       }
       s->mode = DRY;
     case DRY:
-      FLUSH
-      if (s->read != s->write)
-        LEAVE
-      s->mode = DONE;
+			FLUSH if (s->read != s->write)
+				LEAVE s->mode = DONE;
     case DONE:
       r = Z_STREAM_END;
-      LEAVE
-    case BAD:
-      r = Z_DATA_ERROR;
-      LEAVE
-    default:
-      r = Z_STREAM_ERROR;
-      LEAVE
-  }
+			LEAVE case BAD:r = Z_DATA_ERROR;
+			LEAVE default:r = Z_STREAM_ERROR;
+		LEAVE}
 }
 
-
 int inflate_blocks_free(s, z)
 inflate_blocks_statef *s;
 z_streamp z;
--- zlib-1.1.3/infblock.h	1998-01-19 06:09:51.000000000 -0500
+++ zlib-1.1.3/infblock.h	2014-02-07 11:53:21.350326753 -0500
@@ -11,29 +11,16 @@
 struct inflate_blocks_state;
 typedef struct inflate_blocks_state FAR inflate_blocks_statef;
 
-extern inflate_blocks_statef * inflate_blocks_new OF((
-    z_streamp z,
-    check_func c,               /* check function */
+extern inflate_blocks_statef *inflate_blocks_new OF((z_streamp z, check_func c,	/* check function */
     uInt w));                   /* window size */
 
-extern int inflate_blocks OF((
-    inflate_blocks_statef *,
-    z_streamp ,
-    int));                      /* initial return code */
-
-extern void inflate_blocks_reset OF((
-    inflate_blocks_statef *,
-    z_streamp ,
-    uLongf *));                  /* check value on output */
-
-extern int inflate_blocks_free OF((
-    inflate_blocks_statef *,
-    z_streamp));
-
-extern void inflate_set_dictionary OF((
-    inflate_blocks_statef *s,
-    const Bytef *d,  /* dictionary */
+extern int inflate_blocks OF((inflate_blocks_statef *, z_streamp, int));	/* initial return code */
+
+extern void inflate_blocks_reset OF((inflate_blocks_statef *, z_streamp, uLongf *));	/* check value on output */
+
+extern int inflate_blocks_free OF((inflate_blocks_statef *, z_streamp));
+
+extern void inflate_set_dictionary OF((inflate_blocks_statef * s, const Bytef * d,	/* dictionary */
     uInt  n));       /* dictionary length */
 
-extern int inflate_blocks_sync_point OF((
-    inflate_blocks_statef *s));
+extern int inflate_blocks_sync_point OF((inflate_blocks_statef * s));
--- zlib-1.1.3/infcodes.c	1998-06-08 13:06:16.000000000 -0400
+++ zlib-1.1.3/infcodes.c	2014-02-07 11:53:21.350326753 -0500
@@ -24,8 +24,8 @@
       LIT,      /* o: got literal, waiting for output space */
       WASH,     /* o: got eob, possibly still output waiting */
       END,      /* x: got eob and all data flushed */
-      BADCODE}  /* x: got error */
-inflate_codes_mode;
+	BADCODE
+} /* x: got error */ inflate_codes_mode;
 
 /* inflate codes private state */
 struct inflate_codes_state {
@@ -65,11 +64,10 @@
   inflate_codes_statef *c;
 
   if ((c = (inflate_codes_statef *)
-       ZALLOC(z,1,sizeof(struct inflate_codes_state))) != Z_NULL)
-  {
+	     ZALLOC(z, 1, sizeof(struct inflate_codes_state))) != Z_NULL) {
     c->mode = START;
-    c->lbits = (Byte)bl;
-    c->dbits = (Byte)bd;
+		c->lbits = (Byte) bl;
+		c->dbits = (Byte) bd;
     c->ltree = tl;
     c->dtree = td;
     Tracev((stderr, "inflate:       codes new\n"));
@@ -97,20 +94,19 @@
 
   /* copy input/output information to locals (UPDATE macro restores) */
   LOAD
-
   /* process input and output based on current state */
-  while (1) switch (c->mode)
-  {             /* waiting for "i:"=input, "o:"=output, "x:"=nothing */
+	    while (1)
+		switch (c->mode) {	/* waiting for "i:"=input, "o:"=output, "x:"=nothing */
     case START:         /* x: set up for LEN */
 #ifndef SLOW
-      if (m >= 258 && n >= 10)
-      {
+			if (m >= 258 && n >= 10) {
         UPDATE
-        r = inflate_fast(c->lbits, c->dbits, c->ltree, c->dtree, s, z);
-        LOAD
-        if (r != Z_OK)
-        {
-          c->mode = r == Z_STREAM_END ? WASH : BADCODE;
+				    r =
+				    inflate_fast(c->lbits, c->dbits, c->ltree,
+						 c->dtree, s, z);
+				LOAD if (r != Z_OK) {
+					c->mode =
+					    r == Z_STREAM_END ? WASH : BADCODE;
           break;
         }
       }
@@ -121,94 +117,91 @@
     case LEN:           /* i: get length/literal/eob next */
       j = c->sub.code.need;
       NEEDBITS(j)
-      t = c->sub.code.tree + ((uInt)b & inflate_mask[j]);
+			    t = c->sub.code.tree + ((uInt) b & inflate_mask[j]);
       DUMPBITS(t->bits)
-      e = (uInt)(t->exop);
-      if (e == 0)               /* literal */
-      {
+			    e = (uInt) (t->exop);
+			if (e == 0) {	/* literal */
         c->sub.lit = t->base;
-        Tracevv((stderr, t->base >= 0x20 && t->base < 0x7f ?
+				Tracevv((stderr, t->base >= 0x20
+					 && t->base <
+					 0x7f ?
                  "inflate:         literal '%c'\n" :
-                 "inflate:         literal 0x%02x\n", t->base));
+					 "inflate:         literal %#02x\n",
+					 t->base));
         c->mode = LIT;
         break;
       }
-      if (e & 16)               /* length */
-      {
+			if (e & 16) {	/* length */
         c->sub.copy.get = e & 15;
         c->len = t->base;
         c->mode = LENEXT;
         break;
       }
-      if ((e & 64) == 0)        /* next table */
-      {
+			if ((e & 64) == 0) {	/* next table */
         c->sub.code.need = e;
         c->sub.code.tree = t + t->base;
         break;
       }
-      if (e & 32)               /* end of block */
-      {
-        Tracevv((stderr, "inflate:         end of block\n"));
+			if (e & 32) {	/* end of block */
+				Tracevv((stderr,
+					 "inflate:         end of block\n"));
         c->mode = WASH;
         break;
       }
       c->mode = BADCODE;        /* invalid code */
-      z->msg = (char*)"invalid literal/length code";
+			z->msg = (char *)"invalid literal/length code";
       r = Z_DATA_ERROR;
-      LEAVE
-    case LENEXT:        /* i: getting length extra (have base) */
+			LEAVE case LENEXT:	/* i: getting length extra (have base) */
       j = c->sub.copy.get;
       NEEDBITS(j)
-      c->len += (uInt)b & inflate_mask[j];
+			    c->len += (uInt) b & inflate_mask[j];
       DUMPBITS(j)
       c->sub.code.need = c->dbits;
       c->sub.code.tree = c->dtree;
-      Tracevv((stderr, "inflate:         length %u\n", c->len));
+			Tracevv((stderr, "inflate:         length %u\n",
+				 c->len));
       c->mode = DIST;
     case DIST:          /* i: get distance next */
       j = c->sub.code.need;
       NEEDBITS(j)
-      t = c->sub.code.tree + ((uInt)b & inflate_mask[j]);
+			    t = c->sub.code.tree + ((uInt) b & inflate_mask[j]);
       DUMPBITS(t->bits)
-      e = (uInt)(t->exop);
-      if (e & 16)               /* distance */
-      {
+			    e = (uInt) (t->exop);
+			if (e & 16) {	/* distance */
         c->sub.copy.get = e & 15;
         c->sub.copy.dist = t->base;
         c->mode = DISTEXT;
         break;
       }
-      if ((e & 64) == 0)        /* next table */
-      {
+			if ((e & 64) == 0) {	/* next table */
         c->sub.code.need = e;
         c->sub.code.tree = t + t->base;
         break;
       }
       c->mode = BADCODE;        /* invalid code */
-      z->msg = (char*)"invalid distance code";
+			z->msg = (char *)"invalid distance code";
       r = Z_DATA_ERROR;
-      LEAVE
-    case DISTEXT:       /* i: getting distance extra */
+			LEAVE case DISTEXT:	/* i: getting distance extra */
       j = c->sub.copy.get;
       NEEDBITS(j)
-      c->sub.copy.dist += (uInt)b & inflate_mask[j];
+			    c->sub.copy.dist += (uInt) b & inflate_mask[j];
       DUMPBITS(j)
-      Tracevv((stderr, "inflate:         distance %u\n", c->sub.copy.dist));
+			    Tracevv((stderr, "inflate:         distance %u\n",
+				     c->sub.copy.dist));
       c->mode = COPY;
     case COPY:          /* o: copying bytes in window, waiting for space */
 #ifndef __TURBOC__ /* Turbo C bug for following expression */
-      f = (uInt)(q - s->window) < c->sub.copy.dist ?
+			f = (uInt) (q - s->window) < c->sub.copy.dist ?
           s->end - (c->sub.copy.dist - (q - s->window)) :
           q - c->sub.copy.dist;
 #else
       f = q - c->sub.copy.dist;
-      if ((uInt)(q - s->window) < c->sub.copy.dist)
-        f = s->end - (c->sub.copy.dist - (uInt)(q - s->window));
+			if ((uInt) (q - s->window) < c->sub.copy.dist)
+				f = s->end - (c->sub.copy.dist -
+					      (uInt) (q - s->window));
 #endif
-      while (c->len)
-      {
-        NEEDOUT
-        OUTBYTE(*f++)
+			while (c->len) {
+				NEEDOUT OUTBYTE(*f++)
         if (f == s->end)
           f = s->window;
         c->len--;
@@ -216,32 +209,25 @@
       c->mode = START;
       break;
     case LIT:           /* o: got literal, waiting for output space */
-      NEEDOUT
-      OUTBYTE(c->sub.lit)
+			NEEDOUT OUTBYTE(c->sub.lit)
       c->mode = START;
       break;
     case WASH:          /* o: got eob, possibly more output */
-      if (k > 7)        /* return unused byte, if any */
-      {
-        Assert(k < 16, "inflate_codes grabbed too many bytes")
+			if (k > 7) {	/* return unused byte, if any */
+				Assert(k < 16,
+				       "inflate_codes grabbed too many bytes")
         k -= 8;
         n++;
         p--;            /* can always return one */
       }
-      FLUSH
-      if (s->read != s->write)
-        LEAVE
-      c->mode = END;
+			FLUSH if (s->read != s->write)
+				LEAVE c->mode = END;
     case END:
       r = Z_STREAM_END;
-      LEAVE
-    case BADCODE:       /* x: got error */
+			LEAVE case BADCODE:	/* x: got error */
       r = Z_DATA_ERROR;
-      LEAVE
-    default:
-      r = Z_STREAM_ERROR;
-      LEAVE
-  }
+			LEAVE default:r = Z_STREAM_ERROR;
+		LEAVE}
 #ifdef NEED_DUMMY_RETURN
   return Z_STREAM_ERROR;  /* Some dumb compilers complain without this */
 #endif
--- zlib-1.1.3/infcodes.h	1998-01-15 11:16:26.000000000 -0500
+++ zlib-1.1.3/infcodes.h	2014-02-07 11:53:21.350326753 -0500
@@ -11,17 +11,10 @@
 struct inflate_codes_state;
 typedef struct inflate_codes_state FAR inflate_codes_statef;
 
-extern inflate_codes_statef *inflate_codes_new OF((
-    uInt, uInt,
-    inflate_huft *, inflate_huft *,
-    z_streamp ));
+extern inflate_codes_statef *inflate_codes_new OF((uInt, uInt,
+						   inflate_huft *,
+						   inflate_huft *, z_streamp));
 
-extern int inflate_codes OF((
-    inflate_blocks_statef *,
-    z_streamp ,
-    int));
-
-extern void inflate_codes_free OF((
-    inflate_codes_statef *,
-    z_streamp ));
+extern int inflate_codes OF((inflate_blocks_statef *, z_streamp, int));
 
+extern void inflate_codes_free OF((inflate_codes_statef *, z_streamp));
--- zlib-1.1.3/inffast.c	1998-03-16 13:11:26.000000000 -0500
+++ zlib-1.1.3/inffast.c	2014-02-07 11:53:21.350326753 -0500
@@ -10,7 +10,9 @@
 #include "infutil.h"
 #include "inffast.h"
 
-struct inflate_codes_state {int dummy;}; /* for buggy compilers */
+struct inflate_codes_state {
+	int dummy;
+};				/* for buggy compilers */
 
 /* simplify the use of the inflate_huft type with some defines */
 #define exop word.what.Exop
@@ -57,57 +58,62 @@
   do {                          /* assume called with m >= 258 && n >= 10 */
     /* get literal/length code */
     GRABBITS(20)                /* max bits for literal/length code */
-    if ((e = (t = tl + ((uInt)b & ml))->exop) == 0)
-    {
+		    if ((e = (t = tl + ((uInt) b & ml))->exop) == 0) {
       DUMPBITS(t->bits)
       Tracevv((stderr, t->base >= 0x20 && t->base < 0x7f ?
                 "inflate:         * literal '%c'\n" :
-                "inflate:         * literal 0x%02x\n", t->base));
-      *q++ = (Byte)t->base;
+				     "inflate:         * literal %#02x\n",
+				     t->base));
+			*q++ = (Byte) t->base;
       m--;
       continue;
     }
     do {
       DUMPBITS(t->bits)
-      if (e & 16)
-      {
+			    if (e & 16) {
         /* get extra bits for length */
         e &= 15;
-        c = t->base + ((uInt)b & inflate_mask[e]);
+				c = t->base + ((uInt) b & inflate_mask[e]);
         DUMPBITS(e)
-        Tracevv((stderr, "inflate:         * length %u\n", c));
+				    Tracevv((stderr,
+					     "inflate:         * length %u\n",
+					     c));
 
         /* decode distance base of block to copy */
         GRABBITS(15);           /* max bits for distance code */
-        e = (t = td + ((uInt)b & md))->exop;
+				e = (t = td + ((uInt) b & md))->exop;
         do {
           DUMPBITS(t->bits)
-          if (e & 16)
-          {
+					    if (e & 16) {
             /* get extra bits to add to distance base */
             e &= 15;
             GRABBITS(e)         /* get extra bits (up to 13) */
-            d = t->base + ((uInt)b & inflate_mask[e]);
+						    d =
+						    t->base +
+						    ((uInt) b &
+						     inflate_mask[e]);
             DUMPBITS(e)
-            Tracevv((stderr, "inflate:         * distance %u\n", d));
+						    Tracevv((stderr,
+							     "inflate:         * distance %u\n",
+							     d));
 
             /* do the copy */
             m -= c;
-            if ((uInt)(q - s->window) >= d)     /* offset before dest */
-            {                                   /*  just copy */
+						if ((uInt) (q - s->window) >= d) {	/* offset before dest *//*  just copy */
               r = q - d;
-              *q++ = *r++;  c--;        /* minimum count is three, */
-              *q++ = *r++;  c--;        /*  so unroll loop a little */
-            }
-            else                        /* else offset after destination */
-            {
-              e = d - (uInt)(q - s->window); /* bytes from offset to end */
+							*q++ = *r++;
+							c--;	/* minimum count is three, */
+							*q++ = *r++;
+							c--;	/*  so unroll loop a little */
+						} else {	/* else offset after destination */
+
+							e = d - (uInt) (q - s->window);	/* bytes from offset to end */
               r = s->end - e;           /* pointer to offset */
-              if (c > e)                /* if source crosses, */
-              {
+							if (c > e) {	/* if source crosses, */
                 c -= e;                 /* copy to end of window */
                 do {
-                  *q++ = *r++;
+									*q++ =
+									    *r++;
                 } while (--e);
                 r = s->window;          /* copy rest from start of window */
               }
@@ -116,55 +122,49 @@
               *q++ = *r++;
             } while (--c);
             break;
-          }
-          else if ((e & 64) == 0)
-          {
+					} else if ((e & 64) == 0) {
             t += t->base;
-            e = (t += ((uInt)b & inflate_mask[e]))->exop;
-          }
-          else
-          {
-            z->msg = (char*)"invalid distance code";
-            UNGRAB
-            UPDATE
-            return Z_DATA_ERROR;
+						e = (t +=
+						     ((uInt) b &
+						      inflate_mask[e]))->exop;
+					} else {
+						z->msg = (char *)
+						    "invalid distance code";
+						UNGRAB UPDATE return
+						    Z_DATA_ERROR;
           }
         } while (1);
         break;
       }
-      if ((e & 64) == 0)
-      {
+			if ((e & 64) == 0) {
         t += t->base;
-        if ((e = (t += ((uInt)b & inflate_mask[e]))->exop) == 0)
-        {
+				if ((e =
+				     (t +=
+				      ((uInt) b & inflate_mask[e]))->exop) ==
+				    0) {
           DUMPBITS(t->bits)
-          Tracevv((stderr, t->base >= 0x20 && t->base < 0x7f ?
-                    "inflate:         * literal '%c'\n" :
-                    "inflate:         * literal 0x%02x\n", t->base));
-          *q++ = (Byte)t->base;
+					    Tracevv((stderr, t->base >= 0x20
+						     && t->base <
+						     0x7f ?
+						     "inflate:         * literal '%c'\n"
+						     :
+						     "inflate:         * literal %#02x\n",
+						     t->base));
+					*q++ = (Byte) t->base;
           m--;
           break;
         }
-      }
-      else if (e & 32)
-      {
-        Tracevv((stderr, "inflate:         * end of block\n"));
-        UNGRAB
-        UPDATE
-        return Z_STREAM_END;
-      }
-      else
-      {
-        z->msg = (char*)"invalid literal/length code";
-        UNGRAB
-        UPDATE
-        return Z_DATA_ERROR;
+			} else if (e & 32) {
+				Tracevv((stderr,
+					 "inflate:         * end of block\n"));
+				UNGRAB UPDATE return Z_STREAM_END;
+			} else {
+				z->msg = (char *)"invalid literal/length code";
+				UNGRAB UPDATE return Z_DATA_ERROR;
       }
     } while (1);
   } while (m >= 258 && n >= 10);
 
   /* not enough input or output--restore pointers and return */
-  UNGRAB
-  UPDATE
-  return Z_OK;
+	UNGRAB UPDATE return Z_OK;
 }
--- zlib-1.1.3/inffast.h	1998-01-15 11:16:26.000000000 -0500
+++ zlib-1.1.3/inffast.h	2014-02-07 11:53:21.350326753 -0500
@@ -8,10 +8,8 @@
    subject to change. Applications should only use zlib.h.
  */
 
-extern int inflate_fast OF((
-    uInt,
+extern int inflate_fast OF((uInt,
     uInt,
     inflate_huft *,
     inflate_huft *,
-    inflate_blocks_statef *,
-    z_streamp ));
+			    inflate_blocks_statef *, z_streamp));
--- zlib-1.1.3/inffixed.h	1998-06-16 07:29:49.000000000 -0400
+++ zlib-1.1.3/inffixed.h	2014-02-07 11:53:21.351328165 -0500
@@ -10,142 +10,1773 @@
 local uInt fixed_bl = 9;
 local uInt fixed_bd = 5;
 local inflate_huft fixed_tl[] = {
-    {{{96,7}},256}, {{{0,8}},80}, {{{0,8}},16}, {{{84,8}},115},
-    {{{82,7}},31}, {{{0,8}},112}, {{{0,8}},48}, {{{0,9}},192},
-    {{{80,7}},10}, {{{0,8}},96}, {{{0,8}},32}, {{{0,9}},160},
-    {{{0,8}},0}, {{{0,8}},128}, {{{0,8}},64}, {{{0,9}},224},
-    {{{80,7}},6}, {{{0,8}},88}, {{{0,8}},24}, {{{0,9}},144},
-    {{{83,7}},59}, {{{0,8}},120}, {{{0,8}},56}, {{{0,9}},208},
-    {{{81,7}},17}, {{{0,8}},104}, {{{0,8}},40}, {{{0,9}},176},
-    {{{0,8}},8}, {{{0,8}},136}, {{{0,8}},72}, {{{0,9}},240},
-    {{{80,7}},4}, {{{0,8}},84}, {{{0,8}},20}, {{{85,8}},227},
-    {{{83,7}},43}, {{{0,8}},116}, {{{0,8}},52}, {{{0,9}},200},
-    {{{81,7}},13}, {{{0,8}},100}, {{{0,8}},36}, {{{0,9}},168},
-    {{{0,8}},4}, {{{0,8}},132}, {{{0,8}},68}, {{{0,9}},232},
-    {{{80,7}},8}, {{{0,8}},92}, {{{0,8}},28}, {{{0,9}},152},
-    {{{84,7}},83}, {{{0,8}},124}, {{{0,8}},60}, {{{0,9}},216},
-    {{{82,7}},23}, {{{0,8}},108}, {{{0,8}},44}, {{{0,9}},184},
-    {{{0,8}},12}, {{{0,8}},140}, {{{0,8}},76}, {{{0,9}},248},
-    {{{80,7}},3}, {{{0,8}},82}, {{{0,8}},18}, {{{85,8}},163},
-    {{{83,7}},35}, {{{0,8}},114}, {{{0,8}},50}, {{{0,9}},196},
-    {{{81,7}},11}, {{{0,8}},98}, {{{0,8}},34}, {{{0,9}},164},
-    {{{0,8}},2}, {{{0,8}},130}, {{{0,8}},66}, {{{0,9}},228},
-    {{{80,7}},7}, {{{0,8}},90}, {{{0,8}},26}, {{{0,9}},148},
-    {{{84,7}},67}, {{{0,8}},122}, {{{0,8}},58}, {{{0,9}},212},
-    {{{82,7}},19}, {{{0,8}},106}, {{{0,8}},42}, {{{0,9}},180},
-    {{{0,8}},10}, {{{0,8}},138}, {{{0,8}},74}, {{{0,9}},244},
-    {{{80,7}},5}, {{{0,8}},86}, {{{0,8}},22}, {{{192,8}},0},
-    {{{83,7}},51}, {{{0,8}},118}, {{{0,8}},54}, {{{0,9}},204},
-    {{{81,7}},15}, {{{0,8}},102}, {{{0,8}},38}, {{{0,9}},172},
-    {{{0,8}},6}, {{{0,8}},134}, {{{0,8}},70}, {{{0,9}},236},
-    {{{80,7}},9}, {{{0,8}},94}, {{{0,8}},30}, {{{0,9}},156},
-    {{{84,7}},99}, {{{0,8}},126}, {{{0,8}},62}, {{{0,9}},220},
-    {{{82,7}},27}, {{{0,8}},110}, {{{0,8}},46}, {{{0,9}},188},
-    {{{0,8}},14}, {{{0,8}},142}, {{{0,8}},78}, {{{0,9}},252},
-    {{{96,7}},256}, {{{0,8}},81}, {{{0,8}},17}, {{{85,8}},131},
-    {{{82,7}},31}, {{{0,8}},113}, {{{0,8}},49}, {{{0,9}},194},
-    {{{80,7}},10}, {{{0,8}},97}, {{{0,8}},33}, {{{0,9}},162},
-    {{{0,8}},1}, {{{0,8}},129}, {{{0,8}},65}, {{{0,9}},226},
-    {{{80,7}},6}, {{{0,8}},89}, {{{0,8}},25}, {{{0,9}},146},
-    {{{83,7}},59}, {{{0,8}},121}, {{{0,8}},57}, {{{0,9}},210},
-    {{{81,7}},17}, {{{0,8}},105}, {{{0,8}},41}, {{{0,9}},178},
-    {{{0,8}},9}, {{{0,8}},137}, {{{0,8}},73}, {{{0,9}},242},
-    {{{80,7}},4}, {{{0,8}},85}, {{{0,8}},21}, {{{80,8}},258},
-    {{{83,7}},43}, {{{0,8}},117}, {{{0,8}},53}, {{{0,9}},202},
-    {{{81,7}},13}, {{{0,8}},101}, {{{0,8}},37}, {{{0,9}},170},
-    {{{0,8}},5}, {{{0,8}},133}, {{{0,8}},69}, {{{0,9}},234},
-    {{{80,7}},8}, {{{0,8}},93}, {{{0,8}},29}, {{{0,9}},154},
-    {{{84,7}},83}, {{{0,8}},125}, {{{0,8}},61}, {{{0,9}},218},
-    {{{82,7}},23}, {{{0,8}},109}, {{{0,8}},45}, {{{0,9}},186},
-    {{{0,8}},13}, {{{0,8}},141}, {{{0,8}},77}, {{{0,9}},250},
-    {{{80,7}},3}, {{{0,8}},83}, {{{0,8}},19}, {{{85,8}},195},
-    {{{83,7}},35}, {{{0,8}},115}, {{{0,8}},51}, {{{0,9}},198},
-    {{{81,7}},11}, {{{0,8}},99}, {{{0,8}},35}, {{{0,9}},166},
-    {{{0,8}},3}, {{{0,8}},131}, {{{0,8}},67}, {{{0,9}},230},
-    {{{80,7}},7}, {{{0,8}},91}, {{{0,8}},27}, {{{0,9}},150},
-    {{{84,7}},67}, {{{0,8}},123}, {{{0,8}},59}, {{{0,9}},214},
-    {{{82,7}},19}, {{{0,8}},107}, {{{0,8}},43}, {{{0,9}},182},
-    {{{0,8}},11}, {{{0,8}},139}, {{{0,8}},75}, {{{0,9}},246},
-    {{{80,7}},5}, {{{0,8}},87}, {{{0,8}},23}, {{{192,8}},0},
-    {{{83,7}},51}, {{{0,8}},119}, {{{0,8}},55}, {{{0,9}},206},
-    {{{81,7}},15}, {{{0,8}},103}, {{{0,8}},39}, {{{0,9}},174},
-    {{{0,8}},7}, {{{0,8}},135}, {{{0,8}},71}, {{{0,9}},238},
-    {{{80,7}},9}, {{{0,8}},95}, {{{0,8}},31}, {{{0,9}},158},
-    {{{84,7}},99}, {{{0,8}},127}, {{{0,8}},63}, {{{0,9}},222},
-    {{{82,7}},27}, {{{0,8}},111}, {{{0,8}},47}, {{{0,9}},190},
-    {{{0,8}},15}, {{{0,8}},143}, {{{0,8}},79}, {{{0,9}},254},
-    {{{96,7}},256}, {{{0,8}},80}, {{{0,8}},16}, {{{84,8}},115},
-    {{{82,7}},31}, {{{0,8}},112}, {{{0,8}},48}, {{{0,9}},193},
-    {{{80,7}},10}, {{{0,8}},96}, {{{0,8}},32}, {{{0,9}},161},
-    {{{0,8}},0}, {{{0,8}},128}, {{{0,8}},64}, {{{0,9}},225},
-    {{{80,7}},6}, {{{0,8}},88}, {{{0,8}},24}, {{{0,9}},145},
-    {{{83,7}},59}, {{{0,8}},120}, {{{0,8}},56}, {{{0,9}},209},
-    {{{81,7}},17}, {{{0,8}},104}, {{{0,8}},40}, {{{0,9}},177},
-    {{{0,8}},8}, {{{0,8}},136}, {{{0,8}},72}, {{{0,9}},241},
-    {{{80,7}},4}, {{{0,8}},84}, {{{0,8}},20}, {{{85,8}},227},
-    {{{83,7}},43}, {{{0,8}},116}, {{{0,8}},52}, {{{0,9}},201},
-    {{{81,7}},13}, {{{0,8}},100}, {{{0,8}},36}, {{{0,9}},169},
-    {{{0,8}},4}, {{{0,8}},132}, {{{0,8}},68}, {{{0,9}},233},
-    {{{80,7}},8}, {{{0,8}},92}, {{{0,8}},28}, {{{0,9}},153},
-    {{{84,7}},83}, {{{0,8}},124}, {{{0,8}},60}, {{{0,9}},217},
-    {{{82,7}},23}, {{{0,8}},108}, {{{0,8}},44}, {{{0,9}},185},
-    {{{0,8}},12}, {{{0,8}},140}, {{{0,8}},76}, {{{0,9}},249},
-    {{{80,7}},3}, {{{0,8}},82}, {{{0,8}},18}, {{{85,8}},163},
-    {{{83,7}},35}, {{{0,8}},114}, {{{0,8}},50}, {{{0,9}},197},
-    {{{81,7}},11}, {{{0,8}},98}, {{{0,8}},34}, {{{0,9}},165},
-    {{{0,8}},2}, {{{0,8}},130}, {{{0,8}},66}, {{{0,9}},229},
-    {{{80,7}},7}, {{{0,8}},90}, {{{0,8}},26}, {{{0,9}},149},
-    {{{84,7}},67}, {{{0,8}},122}, {{{0,8}},58}, {{{0,9}},213},
-    {{{82,7}},19}, {{{0,8}},106}, {{{0,8}},42}, {{{0,9}},181},
-    {{{0,8}},10}, {{{0,8}},138}, {{{0,8}},74}, {{{0,9}},245},
-    {{{80,7}},5}, {{{0,8}},86}, {{{0,8}},22}, {{{192,8}},0},
-    {{{83,7}},51}, {{{0,8}},118}, {{{0,8}},54}, {{{0,9}},205},
-    {{{81,7}},15}, {{{0,8}},102}, {{{0,8}},38}, {{{0,9}},173},
-    {{{0,8}},6}, {{{0,8}},134}, {{{0,8}},70}, {{{0,9}},237},
-    {{{80,7}},9}, {{{0,8}},94}, {{{0,8}},30}, {{{0,9}},157},
-    {{{84,7}},99}, {{{0,8}},126}, {{{0,8}},62}, {{{0,9}},221},
-    {{{82,7}},27}, {{{0,8}},110}, {{{0,8}},46}, {{{0,9}},189},
-    {{{0,8}},14}, {{{0,8}},142}, {{{0,8}},78}, {{{0,9}},253},
-    {{{96,7}},256}, {{{0,8}},81}, {{{0,8}},17}, {{{85,8}},131},
-    {{{82,7}},31}, {{{0,8}},113}, {{{0,8}},49}, {{{0,9}},195},
-    {{{80,7}},10}, {{{0,8}},97}, {{{0,8}},33}, {{{0,9}},163},
-    {{{0,8}},1}, {{{0,8}},129}, {{{0,8}},65}, {{{0,9}},227},
-    {{{80,7}},6}, {{{0,8}},89}, {{{0,8}},25}, {{{0,9}},147},
-    {{{83,7}},59}, {{{0,8}},121}, {{{0,8}},57}, {{{0,9}},211},
-    {{{81,7}},17}, {{{0,8}},105}, {{{0,8}},41}, {{{0,9}},179},
-    {{{0,8}},9}, {{{0,8}},137}, {{{0,8}},73}, {{{0,9}},243},
-    {{{80,7}},4}, {{{0,8}},85}, {{{0,8}},21}, {{{80,8}},258},
-    {{{83,7}},43}, {{{0,8}},117}, {{{0,8}},53}, {{{0,9}},203},
-    {{{81,7}},13}, {{{0,8}},101}, {{{0,8}},37}, {{{0,9}},171},
-    {{{0,8}},5}, {{{0,8}},133}, {{{0,8}},69}, {{{0,9}},235},
-    {{{80,7}},8}, {{{0,8}},93}, {{{0,8}},29}, {{{0,9}},155},
-    {{{84,7}},83}, {{{0,8}},125}, {{{0,8}},61}, {{{0,9}},219},
-    {{{82,7}},23}, {{{0,8}},109}, {{{0,8}},45}, {{{0,9}},187},
-    {{{0,8}},13}, {{{0,8}},141}, {{{0,8}},77}, {{{0,9}},251},
-    {{{80,7}},3}, {{{0,8}},83}, {{{0,8}},19}, {{{85,8}},195},
-    {{{83,7}},35}, {{{0,8}},115}, {{{0,8}},51}, {{{0,9}},199},
-    {{{81,7}},11}, {{{0,8}},99}, {{{0,8}},35}, {{{0,9}},167},
-    {{{0,8}},3}, {{{0,8}},131}, {{{0,8}},67}, {{{0,9}},231},
-    {{{80,7}},7}, {{{0,8}},91}, {{{0,8}},27}, {{{0,9}},151},
-    {{{84,7}},67}, {{{0,8}},123}, {{{0,8}},59}, {{{0,9}},215},
-    {{{82,7}},19}, {{{0,8}},107}, {{{0,8}},43}, {{{0,9}},183},
-    {{{0,8}},11}, {{{0,8}},139}, {{{0,8}},75}, {{{0,9}},247},
-    {{{80,7}},5}, {{{0,8}},87}, {{{0,8}},23}, {{{192,8}},0},
-    {{{83,7}},51}, {{{0,8}},119}, {{{0,8}},55}, {{{0,9}},207},
-    {{{81,7}},15}, {{{0,8}},103}, {{{0,8}},39}, {{{0,9}},175},
-    {{{0,8}},7}, {{{0,8}},135}, {{{0,8}},71}, {{{0,9}},239},
-    {{{80,7}},9}, {{{0,8}},95}, {{{0,8}},31}, {{{0,9}},159},
-    {{{84,7}},99}, {{{0,8}},127}, {{{0,8}},63}, {{{0,9}},223},
-    {{{82,7}},27}, {{{0,8}},111}, {{{0,8}},47}, {{{0,9}},191},
-    {{{0,8}},15}, {{{0,8}},143}, {{{0,8}},79}, {{{0,9}},255}
-  };
+	{{{96, 7}
+	  }
+	 , 256}
+	, {{{0, 8}
+	    }
+	   , 80}
+	, {{{0, 8}
+	    }
+	   , 16}
+	, {{{84, 8}
+	    }
+	   , 115}
+	,
+	{{{82, 7}
+	  }
+	 , 31}
+	, {{{0, 8}
+	    }
+	   , 112}
+	, {{{0, 8}
+	    }
+	   , 48}
+	, {{{0, 9}
+	    }
+	   , 192}
+	,
+	{{{80, 7}
+	  }
+	 , 10}
+	, {{{0, 8}
+	    }
+	   , 96}
+	, {{{0, 8}
+	    }
+	   , 32}
+	, {{{0, 9}
+	    }
+	   , 160}
+	,
+	{{{0, 8}
+	  }
+	 , 0}
+	, {{{0, 8}
+	    }
+	   , 128}
+	, {{{0, 8}
+	    }
+	   , 64}
+	, {{{0, 9}
+	    }
+	   , 224}
+	,
+	{{{80, 7}
+	  }
+	 , 6}
+	, {{{0, 8}
+	    }
+	   , 88}
+	, {{{0, 8}
+	    }
+	   , 24}
+	, {{{0, 9}
+	    }
+	   , 144}
+	,
+	{{{83, 7}
+	  }
+	 , 59}
+	, {{{0, 8}
+	    }
+	   , 120}
+	, {{{0, 8}
+	    }
+	   , 56}
+	, {{{0, 9}
+	    }
+	   , 208}
+	,
+	{{{81, 7}
+	  }
+	 , 17}
+	, {{{0, 8}
+	    }
+	   , 104}
+	, {{{0, 8}
+	    }
+	   , 40}
+	, {{{0, 9}
+	    }
+	   , 176}
+	,
+	{{{0, 8}
+	  }
+	 , 8}
+	, {{{0, 8}
+	    }
+	   , 136}
+	, {{{0, 8}
+	    }
+	   , 72}
+	, {{{0, 9}
+	    }
+	   , 240}
+	,
+	{{{80, 7}
+	  }
+	 , 4}
+	, {{{0, 8}
+	    }
+	   , 84}
+	, {{{0, 8}
+	    }
+	   , 20}
+	, {{{85, 8}
+	    }
+	   , 227}
+	,
+	{{{83, 7}
+	  }
+	 , 43}
+	, {{{0, 8}
+	    }
+	   , 116}
+	, {{{0, 8}
+	    }
+	   , 52}
+	, {{{0, 9}
+	    }
+	   , 200}
+	,
+	{{{81, 7}
+	  }
+	 , 13}
+	, {{{0, 8}
+	    }
+	   , 100}
+	, {{{0, 8}
+	    }
+	   , 36}
+	, {{{0, 9}
+	    }
+	   , 168}
+	,
+	{{{0, 8}
+	  }
+	 , 4}
+	, {{{0, 8}
+	    }
+	   , 132}
+	, {{{0, 8}
+	    }
+	   , 68}
+	, {{{0, 9}
+	    }
+	   , 232}
+	,
+	{{{80, 7}
+	  }
+	 , 8}
+	, {{{0, 8}
+	    }
+	   , 92}
+	, {{{0, 8}
+	    }
+	   , 28}
+	, {{{0, 9}
+	    }
+	   , 152}
+	,
+	{{{84, 7}
+	  }
+	 , 83}
+	, {{{0, 8}
+	    }
+	   , 124}
+	, {{{0, 8}
+	    }
+	   , 60}
+	, {{{0, 9}
+	    }
+	   , 216}
+	,
+	{{{82, 7}
+	  }
+	 , 23}
+	, {{{0, 8}
+	    }
+	   , 108}
+	, {{{0, 8}
+	    }
+	   , 44}
+	, {{{0, 9}
+	    }
+	   , 184}
+	,
+	{{{0, 8}
+	  }
+	 , 12}
+	, {{{0, 8}
+	    }
+	   , 140}
+	, {{{0, 8}
+	    }
+	   , 76}
+	, {{{0, 9}
+	    }
+	   , 248}
+	,
+	{{{80, 7}
+	  }
+	 , 3}
+	, {{{0, 8}
+	    }
+	   , 82}
+	, {{{0, 8}
+	    }
+	   , 18}
+	, {{{85, 8}
+	    }
+	   , 163}
+	,
+	{{{83, 7}
+	  }
+	 , 35}
+	, {{{0, 8}
+	    }
+	   , 114}
+	, {{{0, 8}
+	    }
+	   , 50}
+	, {{{0, 9}
+	    }
+	   , 196}
+	,
+	{{{81, 7}
+	  }
+	 , 11}
+	, {{{0, 8}
+	    }
+	   , 98}
+	, {{{0, 8}
+	    }
+	   , 34}
+	, {{{0, 9}
+	    }
+	   , 164}
+	,
+	{{{0, 8}
+	  }
+	 , 2}
+	, {{{0, 8}
+	    }
+	   , 130}
+	, {{{0, 8}
+	    }
+	   , 66}
+	, {{{0, 9}
+	    }
+	   , 228}
+	,
+	{{{80, 7}
+	  }
+	 , 7}
+	, {{{0, 8}
+	    }
+	   , 90}
+	, {{{0, 8}
+	    }
+	   , 26}
+	, {{{0, 9}
+	    }
+	   , 148}
+	,
+	{{{84, 7}
+	  }
+	 , 67}
+	, {{{0, 8}
+	    }
+	   , 122}
+	, {{{0, 8}
+	    }
+	   , 58}
+	, {{{0, 9}
+	    }
+	   , 212}
+	,
+	{{{82, 7}
+	  }
+	 , 19}
+	, {{{0, 8}
+	    }
+	   , 106}
+	, {{{0, 8}
+	    }
+	   , 42}
+	, {{{0, 9}
+	    }
+	   , 180}
+	,
+	{{{0, 8}
+	  }
+	 , 10}
+	, {{{0, 8}
+	    }
+	   , 138}
+	, {{{0, 8}
+	    }
+	   , 74}
+	, {{{0, 9}
+	    }
+	   , 244}
+	,
+	{{{80, 7}
+	  }
+	 , 5}
+	, {{{0, 8}
+	    }
+	   , 86}
+	, {{{0, 8}
+	    }
+	   , 22}
+	, {{{192, 8}
+	    }
+	   , 0}
+	,
+	{{{83, 7}
+	  }
+	 , 51}
+	, {{{0, 8}
+	    }
+	   , 118}
+	, {{{0, 8}
+	    }
+	   , 54}
+	, {{{0, 9}
+	    }
+	   , 204}
+	,
+	{{{81, 7}
+	  }
+	 , 15}
+	, {{{0, 8}
+	    }
+	   , 102}
+	, {{{0, 8}
+	    }
+	   , 38}
+	, {{{0, 9}
+	    }
+	   , 172}
+	,
+	{{{0, 8}
+	  }
+	 , 6}
+	, {{{0, 8}
+	    }
+	   , 134}
+	, {{{0, 8}
+	    }
+	   , 70}
+	, {{{0, 9}
+	    }
+	   , 236}
+	,
+	{{{80, 7}
+	  }
+	 , 9}
+	, {{{0, 8}
+	    }
+	   , 94}
+	, {{{0, 8}
+	    }
+	   , 30}
+	, {{{0, 9}
+	    }
+	   , 156}
+	,
+	{{{84, 7}
+	  }
+	 , 99}
+	, {{{0, 8}
+	    }
+	   , 126}
+	, {{{0, 8}
+	    }
+	   , 62}
+	, {{{0, 9}
+	    }
+	   , 220}
+	,
+	{{{82, 7}
+	  }
+	 , 27}
+	, {{{0, 8}
+	    }
+	   , 110}
+	, {{{0, 8}
+	    }
+	   , 46}
+	, {{{0, 9}
+	    }
+	   , 188}
+	,
+	{{{0, 8}
+	  }
+	 , 14}
+	, {{{0, 8}
+	    }
+	   , 142}
+	, {{{0, 8}
+	    }
+	   , 78}
+	, {{{0, 9}
+	    }
+	   , 252}
+	,
+	{{{96, 7}
+	  }
+	 , 256}
+	, {{{0, 8}
+	    }
+	   , 81}
+	, {{{0, 8}
+	    }
+	   , 17}
+	, {{{85, 8}
+	    }
+	   , 131}
+	,
+	{{{82, 7}
+	  }
+	 , 31}
+	, {{{0, 8}
+	    }
+	   , 113}
+	, {{{0, 8}
+	    }
+	   , 49}
+	, {{{0, 9}
+	    }
+	   , 194}
+	,
+	{{{80, 7}
+	  }
+	 , 10}
+	, {{{0, 8}
+	    }
+	   , 97}
+	, {{{0, 8}
+	    }
+	   , 33}
+	, {{{0, 9}
+	    }
+	   , 162}
+	,
+	{{{0, 8}
+	  }
+	 , 1}
+	, {{{0, 8}
+	    }
+	   , 129}
+	, {{{0, 8}
+	    }
+	   , 65}
+	, {{{0, 9}
+	    }
+	   , 226}
+	,
+	{{{80, 7}
+	  }
+	 , 6}
+	, {{{0, 8}
+	    }
+	   , 89}
+	, {{{0, 8}
+	    }
+	   , 25}
+	, {{{0, 9}
+	    }
+	   , 146}
+	,
+	{{{83, 7}
+	  }
+	 , 59}
+	, {{{0, 8}
+	    }
+	   , 121}
+	, {{{0, 8}
+	    }
+	   , 57}
+	, {{{0, 9}
+	    }
+	   , 210}
+	,
+	{{{81, 7}
+	  }
+	 , 17}
+	, {{{0, 8}
+	    }
+	   , 105}
+	, {{{0, 8}
+	    }
+	   , 41}
+	, {{{0, 9}
+	    }
+	   , 178}
+	,
+	{{{0, 8}
+	  }
+	 , 9}
+	, {{{0, 8}
+	    }
+	   , 137}
+	, {{{0, 8}
+	    }
+	   , 73}
+	, {{{0, 9}
+	    }
+	   , 242}
+	,
+	{{{80, 7}
+	  }
+	 , 4}
+	, {{{0, 8}
+	    }
+	   , 85}
+	, {{{0, 8}
+	    }
+	   , 21}
+	, {{{80, 8}
+	    }
+	   , 258}
+	,
+	{{{83, 7}
+	  }
+	 , 43}
+	, {{{0, 8}
+	    }
+	   , 117}
+	, {{{0, 8}
+	    }
+	   , 53}
+	, {{{0, 9}
+	    }
+	   , 202}
+	,
+	{{{81, 7}
+	  }
+	 , 13}
+	, {{{0, 8}
+	    }
+	   , 101}
+	, {{{0, 8}
+	    }
+	   , 37}
+	, {{{0, 9}
+	    }
+	   , 170}
+	,
+	{{{0, 8}
+	  }
+	 , 5}
+	, {{{0, 8}
+	    }
+	   , 133}
+	, {{{0, 8}
+	    }
+	   , 69}
+	, {{{0, 9}
+	    }
+	   , 234}
+	,
+	{{{80, 7}
+	  }
+	 , 8}
+	, {{{0, 8}
+	    }
+	   , 93}
+	, {{{0, 8}
+	    }
+	   , 29}
+	, {{{0, 9}
+	    }
+	   , 154}
+	,
+	{{{84, 7}
+	  }
+	 , 83}
+	, {{{0, 8}
+	    }
+	   , 125}
+	, {{{0, 8}
+	    }
+	   , 61}
+	, {{{0, 9}
+	    }
+	   , 218}
+	,
+	{{{82, 7}
+	  }
+	 , 23}
+	, {{{0, 8}
+	    }
+	   , 109}
+	, {{{0, 8}
+	    }
+	   , 45}
+	, {{{0, 9}
+	    }
+	   , 186}
+	,
+	{{{0, 8}
+	  }
+	 , 13}
+	, {{{0, 8}
+	    }
+	   , 141}
+	, {{{0, 8}
+	    }
+	   , 77}
+	, {{{0, 9}
+	    }
+	   , 250}
+	,
+	{{{80, 7}
+	  }
+	 , 3}
+	, {{{0, 8}
+	    }
+	   , 83}
+	, {{{0, 8}
+	    }
+	   , 19}
+	, {{{85, 8}
+	    }
+	   , 195}
+	,
+	{{{83, 7}
+	  }
+	 , 35}
+	, {{{0, 8}
+	    }
+	   , 115}
+	, {{{0, 8}
+	    }
+	   , 51}
+	, {{{0, 9}
+	    }
+	   , 198}
+	,
+	{{{81, 7}
+	  }
+	 , 11}
+	, {{{0, 8}
+	    }
+	   , 99}
+	, {{{0, 8}
+	    }
+	   , 35}
+	, {{{0, 9}
+	    }
+	   , 166}
+	,
+	{{{0, 8}
+	  }
+	 , 3}
+	, {{{0, 8}
+	    }
+	   , 131}
+	, {{{0, 8}
+	    }
+	   , 67}
+	, {{{0, 9}
+	    }
+	   , 230}
+	,
+	{{{80, 7}
+	  }
+	 , 7}
+	, {{{0, 8}
+	    }
+	   , 91}
+	, {{{0, 8}
+	    }
+	   , 27}
+	, {{{0, 9}
+	    }
+	   , 150}
+	,
+	{{{84, 7}
+	  }
+	 , 67}
+	, {{{0, 8}
+	    }
+	   , 123}
+	, {{{0, 8}
+	    }
+	   , 59}
+	, {{{0, 9}
+	    }
+	   , 214}
+	,
+	{{{82, 7}
+	  }
+	 , 19}
+	, {{{0, 8}
+	    }
+	   , 107}
+	, {{{0, 8}
+	    }
+	   , 43}
+	, {{{0, 9}
+	    }
+	   , 182}
+	,
+	{{{0, 8}
+	  }
+	 , 11}
+	, {{{0, 8}
+	    }
+	   , 139}
+	, {{{0, 8}
+	    }
+	   , 75}
+	, {{{0, 9}
+	    }
+	   , 246}
+	,
+	{{{80, 7}
+	  }
+	 , 5}
+	, {{{0, 8}
+	    }
+	   , 87}
+	, {{{0, 8}
+	    }
+	   , 23}
+	, {{{192, 8}
+	    }
+	   , 0}
+	,
+	{{{83, 7}
+	  }
+	 , 51}
+	, {{{0, 8}
+	    }
+	   , 119}
+	, {{{0, 8}
+	    }
+	   , 55}
+	, {{{0, 9}
+	    }
+	   , 206}
+	,
+	{{{81, 7}
+	  }
+	 , 15}
+	, {{{0, 8}
+	    }
+	   , 103}
+	, {{{0, 8}
+	    }
+	   , 39}
+	, {{{0, 9}
+	    }
+	   , 174}
+	,
+	{{{0, 8}
+	  }
+	 , 7}
+	, {{{0, 8}
+	    }
+	   , 135}
+	, {{{0, 8}
+	    }
+	   , 71}
+	, {{{0, 9}
+	    }
+	   , 238}
+	,
+	{{{80, 7}
+	  }
+	 , 9}
+	, {{{0, 8}
+	    }
+	   , 95}
+	, {{{0, 8}
+	    }
+	   , 31}
+	, {{{0, 9}
+	    }
+	   , 158}
+	,
+	{{{84, 7}
+	  }
+	 , 99}
+	, {{{0, 8}
+	    }
+	   , 127}
+	, {{{0, 8}
+	    }
+	   , 63}
+	, {{{0, 9}
+	    }
+	   , 222}
+	,
+	{{{82, 7}
+	  }
+	 , 27}
+	, {{{0, 8}
+	    }
+	   , 111}
+	, {{{0, 8}
+	    }
+	   , 47}
+	, {{{0, 9}
+	    }
+	   , 190}
+	,
+	{{{0, 8}
+	  }
+	 , 15}
+	, {{{0, 8}
+	    }
+	   , 143}
+	, {{{0, 8}
+	    }
+	   , 79}
+	, {{{0, 9}
+	    }
+	   , 254}
+	,
+	{{{96, 7}
+	  }
+	 , 256}
+	, {{{0, 8}
+	    }
+	   , 80}
+	, {{{0, 8}
+	    }
+	   , 16}
+	, {{{84, 8}
+	    }
+	   , 115}
+	,
+	{{{82, 7}
+	  }
+	 , 31}
+	, {{{0, 8}
+	    }
+	   , 112}
+	, {{{0, 8}
+	    }
+	   , 48}
+	, {{{0, 9}
+	    }
+	   , 193}
+	,
+	{{{80, 7}
+	  }
+	 , 10}
+	, {{{0, 8}
+	    }
+	   , 96}
+	, {{{0, 8}
+	    }
+	   , 32}
+	, {{{0, 9}
+	    }
+	   , 161}
+	,
+	{{{0, 8}
+	  }
+	 , 0}
+	, {{{0, 8}
+	    }
+	   , 128}
+	, {{{0, 8}
+	    }
+	   , 64}
+	, {{{0, 9}
+	    }
+	   , 225}
+	,
+	{{{80, 7}
+	  }
+	 , 6}
+	, {{{0, 8}
+	    }
+	   , 88}
+	, {{{0, 8}
+	    }
+	   , 24}
+	, {{{0, 9}
+	    }
+	   , 145}
+	,
+	{{{83, 7}
+	  }
+	 , 59}
+	, {{{0, 8}
+	    }
+	   , 120}
+	, {{{0, 8}
+	    }
+	   , 56}
+	, {{{0, 9}
+	    }
+	   , 209}
+	,
+	{{{81, 7}
+	  }
+	 , 17}
+	, {{{0, 8}
+	    }
+	   , 104}
+	, {{{0, 8}
+	    }
+	   , 40}
+	, {{{0, 9}
+	    }
+	   , 177}
+	,
+	{{{0, 8}
+	  }
+	 , 8}
+	, {{{0, 8}
+	    }
+	   , 136}
+	, {{{0, 8}
+	    }
+	   , 72}
+	, {{{0, 9}
+	    }
+	   , 241}
+	,
+	{{{80, 7}
+	  }
+	 , 4}
+	, {{{0, 8}
+	    }
+	   , 84}
+	, {{{0, 8}
+	    }
+	   , 20}
+	, {{{85, 8}
+	    }
+	   , 227}
+	,
+	{{{83, 7}
+	  }
+	 , 43}
+	, {{{0, 8}
+	    }
+	   , 116}
+	, {{{0, 8}
+	    }
+	   , 52}
+	, {{{0, 9}
+	    }
+	   , 201}
+	,
+	{{{81, 7}
+	  }
+	 , 13}
+	, {{{0, 8}
+	    }
+	   , 100}
+	, {{{0, 8}
+	    }
+	   , 36}
+	, {{{0, 9}
+	    }
+	   , 169}
+	,
+	{{{0, 8}
+	  }
+	 , 4}
+	, {{{0, 8}
+	    }
+	   , 132}
+	, {{{0, 8}
+	    }
+	   , 68}
+	, {{{0, 9}
+	    }
+	   , 233}
+	,
+	{{{80, 7}
+	  }
+	 , 8}
+	, {{{0, 8}
+	    }
+	   , 92}
+	, {{{0, 8}
+	    }
+	   , 28}
+	, {{{0, 9}
+	    }
+	   , 153}
+	,
+	{{{84, 7}
+	  }
+	 , 83}
+	, {{{0, 8}
+	    }
+	   , 124}
+	, {{{0, 8}
+	    }
+	   , 60}
+	, {{{0, 9}
+	    }
+	   , 217}
+	,
+	{{{82, 7}
+	  }
+	 , 23}
+	, {{{0, 8}
+	    }
+	   , 108}
+	, {{{0, 8}
+	    }
+	   , 44}
+	, {{{0, 9}
+	    }
+	   , 185}
+	,
+	{{{0, 8}
+	  }
+	 , 12}
+	, {{{0, 8}
+	    }
+	   , 140}
+	, {{{0, 8}
+	    }
+	   , 76}
+	, {{{0, 9}
+	    }
+	   , 249}
+	,
+	{{{80, 7}
+	  }
+	 , 3}
+	, {{{0, 8}
+	    }
+	   , 82}
+	, {{{0, 8}
+	    }
+	   , 18}
+	, {{{85, 8}
+	    }
+	   , 163}
+	,
+	{{{83, 7}
+	  }
+	 , 35}
+	, {{{0, 8}
+	    }
+	   , 114}
+	, {{{0, 8}
+	    }
+	   , 50}
+	, {{{0, 9}
+	    }
+	   , 197}
+	,
+	{{{81, 7}
+	  }
+	 , 11}
+	, {{{0, 8}
+	    }
+	   , 98}
+	, {{{0, 8}
+	    }
+	   , 34}
+	, {{{0, 9}
+	    }
+	   , 165}
+	,
+	{{{0, 8}
+	  }
+	 , 2}
+	, {{{0, 8}
+	    }
+	   , 130}
+	, {{{0, 8}
+	    }
+	   , 66}
+	, {{{0, 9}
+	    }
+	   , 229}
+	,
+	{{{80, 7}
+	  }
+	 , 7}
+	, {{{0, 8}
+	    }
+	   , 90}
+	, {{{0, 8}
+	    }
+	   , 26}
+	, {{{0, 9}
+	    }
+	   , 149}
+	,
+	{{{84, 7}
+	  }
+	 , 67}
+	, {{{0, 8}
+	    }
+	   , 122}
+	, {{{0, 8}
+	    }
+	   , 58}
+	, {{{0, 9}
+	    }
+	   , 213}
+	,
+	{{{82, 7}
+	  }
+	 , 19}
+	, {{{0, 8}
+	    }
+	   , 106}
+	, {{{0, 8}
+	    }
+	   , 42}
+	, {{{0, 9}
+	    }
+	   , 181}
+	,
+	{{{0, 8}
+	  }
+	 , 10}
+	, {{{0, 8}
+	    }
+	   , 138}
+	, {{{0, 8}
+	    }
+	   , 74}
+	, {{{0, 9}
+	    }
+	   , 245}
+	,
+	{{{80, 7}
+	  }
+	 , 5}
+	, {{{0, 8}
+	    }
+	   , 86}
+	, {{{0, 8}
+	    }
+	   , 22}
+	, {{{192, 8}
+	    }
+	   , 0}
+	,
+	{{{83, 7}
+	  }
+	 , 51}
+	, {{{0, 8}
+	    }
+	   , 118}
+	, {{{0, 8}
+	    }
+	   , 54}
+	, {{{0, 9}
+	    }
+	   , 205}
+	,
+	{{{81, 7}
+	  }
+	 , 15}
+	, {{{0, 8}
+	    }
+	   , 102}
+	, {{{0, 8}
+	    }
+	   , 38}
+	, {{{0, 9}
+	    }
+	   , 173}
+	,
+	{{{0, 8}
+	  }
+	 , 6}
+	, {{{0, 8}
+	    }
+	   , 134}
+	, {{{0, 8}
+	    }
+	   , 70}
+	, {{{0, 9}
+	    }
+	   , 237}
+	,
+	{{{80, 7}
+	  }
+	 , 9}
+	, {{{0, 8}
+	    }
+	   , 94}
+	, {{{0, 8}
+	    }
+	   , 30}
+	, {{{0, 9}
+	    }
+	   , 157}
+	,
+	{{{84, 7}
+	  }
+	 , 99}
+	, {{{0, 8}
+	    }
+	   , 126}
+	, {{{0, 8}
+	    }
+	   , 62}
+	, {{{0, 9}
+	    }
+	   , 221}
+	,
+	{{{82, 7}
+	  }
+	 , 27}
+	, {{{0, 8}
+	    }
+	   , 110}
+	, {{{0, 8}
+	    }
+	   , 46}
+	, {{{0, 9}
+	    }
+	   , 189}
+	,
+	{{{0, 8}
+	  }
+	 , 14}
+	, {{{0, 8}
+	    }
+	   , 142}
+	, {{{0, 8}
+	    }
+	   , 78}
+	, {{{0, 9}
+	    }
+	   , 253}
+	,
+	{{{96, 7}
+	  }
+	 , 256}
+	, {{{0, 8}
+	    }
+	   , 81}
+	, {{{0, 8}
+	    }
+	   , 17}
+	, {{{85, 8}
+	    }
+	   , 131}
+	,
+	{{{82, 7}
+	  }
+	 , 31}
+	, {{{0, 8}
+	    }
+	   , 113}
+	, {{{0, 8}
+	    }
+	   , 49}
+	, {{{0, 9}
+	    }
+	   , 195}
+	,
+	{{{80, 7}
+	  }
+	 , 10}
+	, {{{0, 8}
+	    }
+	   , 97}
+	, {{{0, 8}
+	    }
+	   , 33}
+	, {{{0, 9}
+	    }
+	   , 163}
+	,
+	{{{0, 8}
+	  }
+	 , 1}
+	, {{{0, 8}
+	    }
+	   , 129}
+	, {{{0, 8}
+	    }
+	   , 65}
+	, {{{0, 9}
+	    }
+	   , 227}
+	,
+	{{{80, 7}
+	  }
+	 , 6}
+	, {{{0, 8}
+	    }
+	   , 89}
+	, {{{0, 8}
+	    }
+	   , 25}
+	, {{{0, 9}
+	    }
+	   , 147}
+	,
+	{{{83, 7}
+	  }
+	 , 59}
+	, {{{0, 8}
+	    }
+	   , 121}
+	, {{{0, 8}
+	    }
+	   , 57}
+	, {{{0, 9}
+	    }
+	   , 211}
+	,
+	{{{81, 7}
+	  }
+	 , 17}
+	, {{{0, 8}
+	    }
+	   , 105}
+	, {{{0, 8}
+	    }
+	   , 41}
+	, {{{0, 9}
+	    }
+	   , 179}
+	,
+	{{{0, 8}
+	  }
+	 , 9}
+	, {{{0, 8}
+	    }
+	   , 137}
+	, {{{0, 8}
+	    }
+	   , 73}
+	, {{{0, 9}
+	    }
+	   , 243}
+	,
+	{{{80, 7}
+	  }
+	 , 4}
+	, {{{0, 8}
+	    }
+	   , 85}
+	, {{{0, 8}
+	    }
+	   , 21}
+	, {{{80, 8}
+	    }
+	   , 258}
+	,
+	{{{83, 7}
+	  }
+	 , 43}
+	, {{{0, 8}
+	    }
+	   , 117}
+	, {{{0, 8}
+	    }
+	   , 53}
+	, {{{0, 9}
+	    }
+	   , 203}
+	,
+	{{{81, 7}
+	  }
+	 , 13}
+	, {{{0, 8}
+	    }
+	   , 101}
+	, {{{0, 8}
+	    }
+	   , 37}
+	, {{{0, 9}
+	    }
+	   , 171}
+	,
+	{{{0, 8}
+	  }
+	 , 5}
+	, {{{0, 8}
+	    }
+	   , 133}
+	, {{{0, 8}
+	    }
+	   , 69}
+	, {{{0, 9}
+	    }
+	   , 235}
+	,
+	{{{80, 7}
+	  }
+	 , 8}
+	, {{{0, 8}
+	    }
+	   , 93}
+	, {{{0, 8}
+	    }
+	   , 29}
+	, {{{0, 9}
+	    }
+	   , 155}
+	,
+	{{{84, 7}
+	  }
+	 , 83}
+	, {{{0, 8}
+	    }
+	   , 125}
+	, {{{0, 8}
+	    }
+	   , 61}
+	, {{{0, 9}
+	    }
+	   , 219}
+	,
+	{{{82, 7}
+	  }
+	 , 23}
+	, {{{0, 8}
+	    }
+	   , 109}
+	, {{{0, 8}
+	    }
+	   , 45}
+	, {{{0, 9}
+	    }
+	   , 187}
+	,
+	{{{0, 8}
+	  }
+	 , 13}
+	, {{{0, 8}
+	    }
+	   , 141}
+	, {{{0, 8}
+	    }
+	   , 77}
+	, {{{0, 9}
+	    }
+	   , 251}
+	,
+	{{{80, 7}
+	  }
+	 , 3}
+	, {{{0, 8}
+	    }
+	   , 83}
+	, {{{0, 8}
+	    }
+	   , 19}
+	, {{{85, 8}
+	    }
+	   , 195}
+	,
+	{{{83, 7}
+	  }
+	 , 35}
+	, {{{0, 8}
+	    }
+	   , 115}
+	, {{{0, 8}
+	    }
+	   , 51}
+	, {{{0, 9}
+	    }
+	   , 199}
+	,
+	{{{81, 7}
+	  }
+	 , 11}
+	, {{{0, 8}
+	    }
+	   , 99}
+	, {{{0, 8}
+	    }
+	   , 35}
+	, {{{0, 9}
+	    }
+	   , 167}
+	,
+	{{{0, 8}
+	  }
+	 , 3}
+	, {{{0, 8}
+	    }
+	   , 131}
+	, {{{0, 8}
+	    }
+	   , 67}
+	, {{{0, 9}
+	    }
+	   , 231}
+	,
+	{{{80, 7}
+	  }
+	 , 7}
+	, {{{0, 8}
+	    }
+	   , 91}
+	, {{{0, 8}
+	    }
+	   , 27}
+	, {{{0, 9}
+	    }
+	   , 151}
+	,
+	{{{84, 7}
+	  }
+	 , 67}
+	, {{{0, 8}
+	    }
+	   , 123}
+	, {{{0, 8}
+	    }
+	   , 59}
+	, {{{0, 9}
+	    }
+	   , 215}
+	,
+	{{{82, 7}
+	  }
+	 , 19}
+	, {{{0, 8}
+	    }
+	   , 107}
+	, {{{0, 8}
+	    }
+	   , 43}
+	, {{{0, 9}
+	    }
+	   , 183}
+	,
+	{{{0, 8}
+	  }
+	 , 11}
+	, {{{0, 8}
+	    }
+	   , 139}
+	, {{{0, 8}
+	    }
+	   , 75}
+	, {{{0, 9}
+	    }
+	   , 247}
+	,
+	{{{80, 7}
+	  }
+	 , 5}
+	, {{{0, 8}
+	    }
+	   , 87}
+	, {{{0, 8}
+	    }
+	   , 23}
+	, {{{192, 8}
+	    }
+	   , 0}
+	,
+	{{{83, 7}
+	  }
+	 , 51}
+	, {{{0, 8}
+	    }
+	   , 119}
+	, {{{0, 8}
+	    }
+	   , 55}
+	, {{{0, 9}
+	    }
+	   , 207}
+	,
+	{{{81, 7}
+	  }
+	 , 15}
+	, {{{0, 8}
+	    }
+	   , 103}
+	, {{{0, 8}
+	    }
+	   , 39}
+	, {{{0, 9}
+	    }
+	   , 175}
+	,
+	{{{0, 8}
+	  }
+	 , 7}
+	, {{{0, 8}
+	    }
+	   , 135}
+	, {{{0, 8}
+	    }
+	   , 71}
+	, {{{0, 9}
+	    }
+	   , 239}
+	,
+	{{{80, 7}
+	  }
+	 , 9}
+	, {{{0, 8}
+	    }
+	   , 95}
+	, {{{0, 8}
+	    }
+	   , 31}
+	, {{{0, 9}
+	    }
+	   , 159}
+	,
+	{{{84, 7}
+	  }
+	 , 99}
+	, {{{0, 8}
+	    }
+	   , 127}
+	, {{{0, 8}
+	    }
+	   , 63}
+	, {{{0, 9}
+	    }
+	   , 223}
+	,
+	{{{82, 7}
+	  }
+	 , 27}
+	, {{{0, 8}
+	    }
+	   , 111}
+	, {{{0, 8}
+	    }
+	   , 47}
+	, {{{0, 9}
+	    }
+	   , 191}
+	,
+	{{{0, 8}
+	  }
+	 , 15}
+	, {{{0, 8}
+	    }
+	   , 143}
+	, {{{0, 8}
+	    }
+	   , 79}
+	, {{{0, 9}
+	    }
+	   , 255}
+};
+
 local inflate_huft fixed_td[] = {
-    {{{80,5}},1}, {{{87,5}},257}, {{{83,5}},17}, {{{91,5}},4097},
-    {{{81,5}},5}, {{{89,5}},1025}, {{{85,5}},65}, {{{93,5}},16385},
-    {{{80,5}},3}, {{{88,5}},513}, {{{84,5}},33}, {{{92,5}},8193},
-    {{{82,5}},9}, {{{90,5}},2049}, {{{86,5}},129}, {{{192,5}},24577},
-    {{{80,5}},2}, {{{87,5}},385}, {{{83,5}},25}, {{{91,5}},6145},
-    {{{81,5}},7}, {{{89,5}},1537}, {{{85,5}},97}, {{{93,5}},24577},
-    {{{80,5}},4}, {{{88,5}},769}, {{{84,5}},49}, {{{92,5}},12289},
-    {{{82,5}},13}, {{{90,5}},3073}, {{{86,5}},193}, {{{192,5}},24577}
-  };
+	{{{80, 5}
+	  }
+	 , 1}
+	, {{{87, 5}
+	    }
+	   , 257}
+	, {{{83, 5}
+	    }
+	   , 17}
+	, {{{91, 5}
+	    }
+	   , 4097}
+	,
+	{{{81, 5}
+	  }
+	 , 5}
+	, {{{89, 5}
+	    }
+	   , 1025}
+	, {{{85, 5}
+	    }
+	   , 65}
+	, {{{93, 5}
+	    }
+	   , 16385}
+	,
+	{{{80, 5}
+	  }
+	 , 3}
+	, {{{88, 5}
+	    }
+	   , 513}
+	, {{{84, 5}
+	    }
+	   , 33}
+	, {{{92, 5}
+	    }
+	   , 8193}
+	,
+	{{{82, 5}
+	  }
+	 , 9}
+	, {{{90, 5}
+	    }
+	   , 2049}
+	, {{{86, 5}
+	    }
+	   , 129}
+	, {{{192, 5}
+	    }
+	   , 24577}
+	,
+	{{{80, 5}
+	  }
+	 , 2}
+	, {{{87, 5}
+	    }
+	   , 385}
+	, {{{83, 5}
+	    }
+	   , 25}
+	, {{{91, 5}
+	    }
+	   , 6145}
+	,
+	{{{81, 5}
+	  }
+	 , 7}
+	, {{{89, 5}
+	    }
+	   , 1537}
+	, {{{85, 5}
+	    }
+	   , 97}
+	, {{{93, 5}
+	    }
+	   , 24577}
+	,
+	{{{80, 5}
+	  }
+	 , 4}
+	, {{{88, 5}
+	    }
+	   , 769}
+	, {{{84, 5}
+	    }
+	   , 49}
+	, {{{92, 5}
+	    }
+	   , 12289}
+	,
+	{{{82, 5}
+	  }
+	 , 13}
+	, {{{90, 5}
+	    }
+	   , 3073}
+	, {{{86, 5}
+	    }
+	   , 193}
+	, {{{192, 5}
+	    }
+	   , 24577}
+};
--- zlib-1.1.3/inflate.c	1998-02-24 05:20:11.000000000 -0500
+++ zlib-1.1.3/inflate.c	2014-02-07 11:53:21.351328165 -0500
@@ -6,7 +6,9 @@
 #include "zutil.h"
 #include "infblock.h"
 
-struct inflate_blocks_state {int dummy;}; /* for buggy compilers */
+struct inflate_blocks_state {
+	int dummy;
+};				/* for buggy compilers */
 
 typedef enum {
       METHOD,   /* waiting for method byte */
@@ -22,8 +24,8 @@
       CHECK2,   /* two check bytes to go */
       CHECK1,   /* one check byte to go */
       DONE,     /* finished check, done */
-      BAD}      /* got an error--stay here */
-inflate_mode;
+	BAD
+} /* got an error--stay here */ inflate_mode;
 
 /* inflate private state */
 struct internal_state {
@@ -44,8 +46,7 @@
   /* mode independent information */
   int  nowrap;          /* flag for no wrapper */
   uInt wbits;           /* log2(window size)  (8..15, defaults to 15) */
-  inflate_blocks_statef 
-    *blocks;            /* current inflate_blocks state */
+	inflate_blocks_statef *blocks;	/* current inflate_blocks state */
 
 };
 
@@ -92,38 +90,36 @@
   if (z == Z_NULL)
     return Z_STREAM_ERROR;
   z->msg = Z_NULL;
-  if (z->zalloc == Z_NULL)
-  {
+	if (z->zalloc == Z_NULL) {
     z->zalloc = zcalloc;
-    z->opaque = (voidpf)0;
+		z->opaque = (voidpf) 0;
   }
-  if (z->zfree == Z_NULL) z->zfree = zcfree;
+	if (z->zfree == Z_NULL)
+		z->zfree = zcfree;
   if ((z->state = (struct internal_state FAR *)
-       ZALLOC(z,1,sizeof(struct internal_state))) == Z_NULL)
+	     ZALLOC(z, 1, sizeof(struct internal_state))) == Z_NULL)
     return Z_MEM_ERROR;
   z->state->blocks = Z_NULL;
 
   /* handle undocumented nowrap option (no zlib header or check) */
   z->state->nowrap = 0;
-  if (w < 0)
-  {
-    w = - w;
+	if (w < 0) {
+		w = -w;
     z->state->nowrap = 1;
   }
 
   /* set window size */
-  if (w < 8 || w > 15)
-  {
+	if (w < 8 || w > 15) {
     inflateEnd(z);
     return Z_STREAM_ERROR;
   }
-  z->state->wbits = (uInt)w;
+	z->state->wbits = (uInt) w;
 
   /* create inflate_blocks state */
   if ((z->state->blocks =
-      inflate_blocks_new(z, z->state->nowrap ? Z_NULL : adler32, (uInt)1 << w))
-      == Z_NULL)
-  {
+	     inflate_blocks_new(z, z->state->nowrap ? Z_NULL : adler32,
+				(uInt) 1 << w))
+	    == Z_NULL) {
     inflateEnd(z);
     return Z_MEM_ERROR;
   }
@@ -158,69 +152,63 @@
     return Z_STREAM_ERROR;
   f = f == Z_FINISH ? Z_BUF_ERROR : Z_OK;
   r = Z_BUF_ERROR;
-  while (1) switch (z->state->mode)
-  {
+	while (1)
+		switch (z->state->mode) {
     case METHOD:
       NEEDBYTE
-      if (((z->state->sub.method = NEXTBYTE) & 0xf) != Z_DEFLATED)
-      {
+			    if (((z->state->sub.method =
+				  NEXTBYTE) & 0xf) != Z_DEFLATED) {
         z->state->mode = BAD;
-        z->msg = (char*)"unknown compression method";
+				z->msg = (char *)"unknown compression method";
         z->state->sub.marker = 5;       /* can't try inflateSync */
         break;
       }
-      if ((z->state->sub.method >> 4) + 8 > z->state->wbits)
-      {
+			if ((z->state->sub.method >> 4) + 8 > z->state->wbits) {
         z->state->mode = BAD;
-        z->msg = (char*)"invalid window size";
+				z->msg = (char *)"invalid window size";
         z->state->sub.marker = 5;       /* can't try inflateSync */
         break;
       }
       z->state->mode = FLAG;
     case FLAG:
-      NEEDBYTE
-      b = NEXTBYTE;
-      if (((z->state->sub.method << 8) + b) % 31)
-      {
+			NEEDBYTE b = NEXTBYTE;
+			if (((z->state->sub.method << 8) + b) % 31) {
         z->state->mode = BAD;
-        z->msg = (char*)"incorrect header check";
+				z->msg = (char *)"incorrect header check";
         z->state->sub.marker = 5;       /* can't try inflateSync */
         break;
       }
       Tracev((stderr, "inflate: zlib header ok\n"));
-      if (!(b & PRESET_DICT))
-      {
+			if (!(b & PRESET_DICT)) {
         z->state->mode = BLOCKS;
         break;
       }
       z->state->mode = DICT4;
     case DICT4:
       NEEDBYTE
-      z->state->sub.check.need = (uLong)NEXTBYTE << 24;
+			    z->state->sub.check.need = (uLong) NEXTBYTE << 24;
       z->state->mode = DICT3;
     case DICT3:
       NEEDBYTE
-      z->state->sub.check.need += (uLong)NEXTBYTE << 16;
+			    z->state->sub.check.need += (uLong) NEXTBYTE << 16;
       z->state->mode = DICT2;
     case DICT2:
       NEEDBYTE
-      z->state->sub.check.need += (uLong)NEXTBYTE << 8;
+			    z->state->sub.check.need += (uLong) NEXTBYTE << 8;
       z->state->mode = DICT1;
     case DICT1:
-      NEEDBYTE
-      z->state->sub.check.need += (uLong)NEXTBYTE;
+			NEEDBYTE z->state->sub.check.need += (uLong) NEXTBYTE;
       z->adler = z->state->sub.check.need;
       z->state->mode = DICT0;
       return Z_NEED_DICT;
     case DICT0:
       z->state->mode = BAD;
-      z->msg = (char*)"need dictionary";
+			z->msg = (char *)"need dictionary";
       z->state->sub.marker = 0;       /* can try inflateSync */
       return Z_STREAM_ERROR;
     case BLOCKS:
       r = inflate_blocks(z->state->blocks, z, r);
-      if (r == Z_DATA_ERROR)
-      {
+			if (r == Z_DATA_ERROR) {
         z->state->mode = BAD;
         z->state->sub.marker = 0;       /* can try inflateSync */
         break;
@@ -230,33 +218,31 @@
       if (r != Z_STREAM_END)
         return r;
       r = f;
-      inflate_blocks_reset(z->state->blocks, z, &z->state->sub.check.was);
-      if (z->state->nowrap)
-      {
+			inflate_blocks_reset(z->state->blocks, z,
+					     &z->state->sub.check.was);
+			if (z->state->nowrap) {
         z->state->mode = DONE;
         break;
       }
       z->state->mode = CHECK4;
     case CHECK4:
       NEEDBYTE
-      z->state->sub.check.need = (uLong)NEXTBYTE << 24;
+			    z->state->sub.check.need = (uLong) NEXTBYTE << 24;
       z->state->mode = CHECK3;
     case CHECK3:
       NEEDBYTE
-      z->state->sub.check.need += (uLong)NEXTBYTE << 16;
+			    z->state->sub.check.need += (uLong) NEXTBYTE << 16;
       z->state->mode = CHECK2;
     case CHECK2:
       NEEDBYTE
-      z->state->sub.check.need += (uLong)NEXTBYTE << 8;
+			    z->state->sub.check.need += (uLong) NEXTBYTE << 8;
       z->state->mode = CHECK1;
     case CHECK1:
-      NEEDBYTE
-      z->state->sub.check.need += (uLong)NEXTBYTE;
+			NEEDBYTE z->state->sub.check.need += (uLong) NEXTBYTE;
 
-      if (z->state->sub.check.was != z->state->sub.check.need)
-      {
+			if (z->state->sub.check.was != z->state->sub.check.need) {
         z->state->mode = BAD;
-        z->msg = (char*)"incorrect data check";
+				z->msg = (char *)"incorrect data check";
         z->state->sub.marker = 5;       /* can't try inflateSync */
         break;
       }
@@ -285,12 +270,12 @@
   if (z == Z_NULL || z->state == Z_NULL || z->state->mode != DICT0)
     return Z_STREAM_ERROR;
 
-  if (adler32(1L, dictionary, dictLength) != z->adler) return Z_DATA_ERROR;
+	if (adler32(1L, dictionary, dictLength) != z->adler)
+		return Z_DATA_ERROR;
   z->adler = 1L;
 
-  if (length >= ((uInt)1<<z->state->wbits))
-  {
-    length = (1<<z->state->wbits)-1;
+	if (length >= ((uInt) 1 << z->state->wbits)) {
+		length = (1 << z->state->wbits) - 1;
     dictionary += dictLength - length;
   }
   inflate_set_dictionary(z->state->blocks, dictionary, length);
@@ -310,8 +294,7 @@
   /* set up */
   if (z == Z_NULL || z->state == Z_NULL)
     return Z_STREAM_ERROR;
-  if (z->state->mode != BAD)
-  {
+	if (z->state->mode != BAD) {
     z->state->mode = BAD;
     z->state->sub.marker = 0;
   }
@@ -321,9 +304,8 @@
   m = z->state->sub.marker;
 
   /* search */
-  while (n && m < 4)
-  {
-    static const Byte mark[4] = {0, 0, 0xff, 0xff};
+	while (n && m < 4) {
+		static const Byte mark[4] = { 0, 0, 0xff, 0xff };
     if (*p == mark[m])
       m++;
     else if (*p)
@@ -342,9 +324,11 @@
   /* return no joy or set up to restart on a new block */
   if (m != 4)
     return Z_DATA_ERROR;
-  r = z->total_in;  w = z->total_out;
+	r = z->total_in;
+	w = z->total_out;
   inflateReset(z);
-  z->total_in = r;  z->total_out = w;
+	z->total_in = r;
+	z->total_out = w;
   z->state->mode = BLOCKS;
   return Z_OK;
 }
--- zlib-1.1.3/inftrees.c	1998-07-09 12:06:30.000000000 -0400
+++ zlib-1.1.3/inftrees.c	2014-02-07 11:53:21.351328165 -0500
@@ -7,7 +7,7 @@
 #include "inftrees.h"
 
 #if !defined(BUILDFIXED) && !defined(STDC)
-#  define BUILDFIXED   /* non ANSI compilers may not accept inffixed.h */
+#define BUILDFIXED		/* non ANSI compilers may not accept inffixed.h */
 #endif
 
 const char inflate_copyright[] =
@@ -18,41 +18,48 @@
   include such an acknowledgment, I would appreciate that you keep this
   copyright string in the executable of your product.
  */
-struct internal_state  {int dummy;}; /* for buggy compilers */
+struct internal_state {
+	int dummy;
+};				/* for buggy compilers */
 
 /* simplify the use of the inflate_huft type with some defines */
 #define exop word.what.Exop
 #define bits word.what.Bits
 
-
-local int huft_build OF((
-    uIntf *,            /* code lengths in bits */
+local int huft_build OF((uIntf *,	/* code lengths in bits */
     uInt,               /* number of codes */
     uInt,               /* number of "simple" codes */
     const uIntf *,      /* list of base values for non-simple codes */
     const uIntf *,      /* list of extra bits for non-simple codes */
-    inflate_huft * FAR*,/* result: starting table */
+			 inflate_huft * FAR *,	/* result: starting table */
     uIntf *,            /* maximum lookup bits (returns actual) */
     inflate_huft *,     /* space for trees */
     uInt *,             /* hufts used in space */
-    uIntf * ));         /* space for values */
+			 uIntf *));	/* space for values */
 
 /* Tables for deflate from PKZIP's appnote.txt. */
 local const uInt cplens[31] = { /* Copy lengths for literal codes 257..285 */
         3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31,
-        35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0};
+	35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0
+};
+
         /* see note #13 above about 258 */
 local const uInt cplext[31] = { /* Extra bits for literal codes 257..285 */
         0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2,
-        3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, 112, 112}; /* 112==invalid */
+	3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, 112, 112
+};				/* 112==invalid */
+
 local const uInt cpdist[30] = { /* Copy offsets for distance codes 0..29 */
         1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193,
         257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145,
-        8193, 12289, 16385, 24577};
+	8193, 12289, 16385, 24577
+};
+
 local const uInt cpdext[30] = { /* Extra bits for distance codes */
         0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6,
         7, 7, 8, 8, 9, 9, 10, 10, 11, 11,
-        12, 12, 13, 13};
+	12, 12, 13, 13
+};
 
 /*
    Huffman code decoding is performed using a multi-level table lookup.
@@ -96,7 +102,7 @@
 uInt s;                 /* number of simple-valued codes (0..s-1) */
 const uIntf *d;         /* list of base values for non-simple codes */
 const uIntf *e;         /* list of extra bits for non-simple codes */
-inflate_huft * FAR *t;  /* result: starting table */
+inflate_huft *FAR * t;		/* result: starting table */
 uIntf *m;               /* maximum lookup bits, returns actual */
 inflate_huft *hp;       /* space for trees */
 uInt *hn;               /* hufts used in space */
@@ -109,7 +115,7 @@
 {
 
   uInt a;                       /* counter for codes of length k */
-  uInt c[BMAX+1];               /* bit length count table */
+	uInt c[BMAX + 1];	/* bit length count table */
   uInt f;                       /* i repeats in table every f entries */
   int g;                        /* maximum code length */
   int h;                        /* table level */
@@ -123,7 +129,7 @@
   struct inflate_huft_s r;      /* table entry for structure assignment */
   inflate_huft *u[BMAX];        /* table stack */
   register int w;               /* bits before this table == (l * h) */
-  uInt x[BMAX+1];               /* bit offsets, then code stack */
+	uInt x[BMAX + 1];	/* bit offsets, then code stack */
   uIntf *xp;                    /* pointer into x */
   int y;                        /* number of dummy codes added */
   uInt z;                       /* number of entries in current table */
@@ -135,13 +140,13 @@
 #define C2 C0 C0 C0 C0
 #define C4 C2 C2 C2 C2
   C4                            /* clear c[]--assume BMAX+1 is 16 */
-  p = b;  i = n;
+	    p = b;
+	i = n;
   do {
     c[*p++]++;                  /* assume all entries <= BMAX */
   } while (--i);
-  if (c[0] == n)                /* null input--all zero length codes */
-  {
-    *t = (inflate_huft *)Z_NULL;
+	if (c[0] == n) {	/* null input--all zero length codes */
+		*t = (inflate_huft *) Z_NULL;
     *m = 0;
     return Z_OK;
   }
@@ -153,13 +157,13 @@
     if (c[j])
       break;
   k = j;                        /* minimum code length */
-  if ((uInt)l < j)
+	if ((uInt) l < j)
     l = j;
   for (i = BMAX; i; i--)
     if (c[i])
       break;
   g = i;                        /* maximum code length */
-  if ((uInt)l > i)
+	if ((uInt) l > i)
     l = i;
   *m = l;
 
@@ -172,10 +175,10 @@
     return Z_DATA_ERROR;
   c[i] += y;
 
-
   /* Generate starting offsets into the value table for each length */
   x[1] = j = 0;
-  p = c + 1;  xp = x + 2;
+	p = c + 1;
+	xp = x + 2;
   while (--i) {                 /* note that i == g from above */
     *xp++ = (j += *p++);
   }
@@ -180,9 +183,9 @@
     *xp++ = (j += *p++);
   }
 
-
   /* Make a table of values in order of bit lengths */
-  p = b;  i = 0;
+	p = b;
+	i = 0;
   do {
     if ((j = *p++) != 0)
       v[x[j]++] = i;
@@ -195,33 +197,28 @@
   p = v;                        /* grab values in bit order */
   h = -1;                       /* no tables yet--level -1 */
   w = -l;                       /* bits decoded == (l * h) */
-  u[0] = (inflate_huft *)Z_NULL;        /* just to keep compilers happy */
-  q = (inflate_huft *)Z_NULL;   /* ditto */
+	u[0] = (inflate_huft *) Z_NULL;	/* just to keep compilers happy */
+	q = (inflate_huft *) Z_NULL;	/* ditto */
   z = 0;                        /* ditto */
 
   /* go through the bit lengths (k already is bits in shortest code) */
-  for (; k <= g; k++)
-  {
+	for (; k <= g; k++) {
     a = c[k];
-    while (a--)
-    {
+		while (a--) {
       /* here i is the Huffman code of length k bits for value *p */
       /* make tables up to required level */
-      while (k > w + l)
-      {
+			while (k > w + l) {
         h++;
         w += l;                 /* previous table always l bits */
 
         /* compute minimum size table less than or equal to l bits */
         z = g - w;
-        z = z > (uInt)l ? l : z;        /* table size upper limit */
-        if ((f = 1 << (j = k - w)) > a + 1)     /* try a k-w bit table */
-        {                       /* too few codes for k-w bit table */
+				z = z > (uInt) l ? (uInt) l : z;	/* table size upper limit */
+				if ((f = 1 << (j = k - w)) > a + 1) {	/* try a k-w bit table *//* too few codes for k-w bit table */
           f -= a + 1;           /* deduct codes from patterns left */
           xp = c + k;
           if (j < z)
-            while (++j < z)     /* try smaller tables up to z bits */
-            {
+						while (++j < z) {	/* try smaller tables up to z bits */
               if ((f <<= 1) <= *++xp)
                 break;          /* enough codes to use up j bits */
               f -= *xp;         /* else deduct codes from patterns */
@@ -236,31 +233,26 @@
         *hn += z;
 
         /* connect to last table, if there is one */
-        if (h)
-        {
+				if (h) {
           x[h] = i;             /* save pattern for backing up */
-          r.bits = (Byte)l;     /* bits to dump before this table */
-          r.exop = (Byte)j;     /* bits in this table */
+					r.bits = (Byte) l;	/* bits to dump before this table */
+					r.exop = (Byte) j;	/* bits in this table */
           j = i >> (w - l);
-          r.base = (uInt)(q - u[h-1] - j);   /* offset to this table */
-          u[h-1][j] = r;        /* connect to last table */
-        }
-        else
+					r.base = (uInt) (q - u[h - 1] - j);	/* offset to this table */
+					u[h - 1][j] = r;	/* connect to last table */
+				} else
           *t = q;               /* first table is returned result */
       }
 
       /* set up table entry in r */
-      r.bits = (Byte)(k - w);
+			r.bits = (Byte) (k - w);
       if (p >= v + n)
         r.exop = 128 + 64;      /* out of values--invalid code */
-      else if (*p < s)
-      {
-        r.exop = (Byte)(*p < 256 ? 0 : 32 + 64);     /* 256 is end-of-block */
+			else if (*p < s) {
+				r.exop = (Byte) (*p < 256 ? 0 : 32 + 64);	/* 256 is end-of-block */
         r.base = *p++;          /* simple code is just the value */
-      }
-      else
-      {
-        r.exop = (Byte)(e[*p - s] + 16 + 64);/* non-simple--look up in lists */
+			} else {
+				r.exop = (Byte) (e[*p - s] + 16 + 64);	/* non-simple--look up in lists */
         r.base = d[*p++ - s];
       }
 
@@ -276,8 +268,7 @@
 
       /* backup over finished tables */
       mask = (1 << w) - 1;      /* needed on HP, cc -O bug */
-      while ((i & mask) != x[h])
-      {
+			while ((i & mask) != x[h]) {
         h--;                    /* don't need to update q */
         w -= l;
         mask = (1 << w) - 1;
@@ -294,7 +283,7 @@
 int inflate_trees_bits(c, bb, tb, hp, z)
 uIntf *c;               /* 19 code lengths */
 uIntf *bb;              /* bits tree desired/actual depth */
-inflate_huft * FAR *tb; /* bits tree result */
+inflate_huft *FAR * tb;		/* bits tree result */
 inflate_huft *hp;       /* space for trees */
 z_streamp z;            /* for messages */
 {
@@ -302,15 +291,14 @@
   uInt hn = 0;          /* hufts used in space */
   uIntf *v;             /* work area for huft_build */
 
-  if ((v = (uIntf*)ZALLOC(z, 19, sizeof(uInt))) == Z_NULL)
+	if ((v = (uIntf *) ZALLOC(z, 19, sizeof(uInt))) == Z_NULL)
     return Z_MEM_ERROR;
-  r = huft_build(c, 19, 19, (uIntf*)Z_NULL, (uIntf*)Z_NULL,
+	r = huft_build(c, 19, 19, (uIntf *) Z_NULL, (uIntf *) Z_NULL,
                  tb, bb, hp, &hn, v);
   if (r == Z_DATA_ERROR)
-    z->msg = (char*)"oversubscribed dynamic bit lengths tree";
-  else if (r == Z_BUF_ERROR || *bb == 0)
-  {
-    z->msg = (char*)"incomplete dynamic bit lengths tree";
+		z->msg = (char *)"oversubscribed dynamic bit lengths tree";
+	else if (r == Z_BUF_ERROR || *bb == 0) {
+		z->msg = (char *)"incomplete dynamic bit lengths tree";
     r = Z_DATA_ERROR;
   }
   ZFREE(z, v);
@@ -324,8 +311,8 @@
 uIntf *c;               /* that many (total) code lengths */
 uIntf *bl;              /* literal desired/actual bit depth */
 uIntf *bd;              /* distance desired/actual bit depth */
-inflate_huft * FAR *tl; /* literal/length tree result */
-inflate_huft * FAR *td; /* distance tree result */
+inflate_huft *FAR * tl;		/* literal/length tree result */
+inflate_huft *FAR * td;		/* distance tree result */
 inflate_huft *hp;       /* space for trees */
 z_streamp z;            /* for messages */
 {
@@ -334,18 +321,16 @@
   uIntf *v;             /* work area for huft_build */
 
   /* allocate work area */
-  if ((v = (uIntf*)ZALLOC(z, 288, sizeof(uInt))) == Z_NULL)
+	if ((v = (uIntf *) ZALLOC(z, 288, sizeof(uInt))) == Z_NULL)
     return Z_MEM_ERROR;
 
   /* build literal/length tree */
   r = huft_build(c, nl, 257, cplens, cplext, tl, bl, hp, &hn, v);
-  if (r != Z_OK || *bl == 0)
-  {
+	if (r != Z_OK || *bl == 0) {
     if (r == Z_DATA_ERROR)
-      z->msg = (char*)"oversubscribed literal/length tree";
-    else if (r != Z_MEM_ERROR)
-    {
-      z->msg = (char*)"incomplete literal/length tree";
+			z->msg = (char *)"oversubscribed literal/length tree";
+		else if (r != Z_MEM_ERROR) {
+			z->msg = (char *)"incomplete literal/length tree";
       r = Z_DATA_ERROR;
     }
     ZFREE(z, v);
@@ -354,21 +339,18 @@
 
   /* build distance tree */
   r = huft_build(c + nl, nd, 0, cpdist, cpdext, td, bd, hp, &hn, v);
-  if (r != Z_OK || (*bd == 0 && nl > 257))
-  {
+	if (r != Z_OK || (*bd == 0 && nl > 257)) {
     if (r == Z_DATA_ERROR)
-      z->msg = (char*)"oversubscribed distance tree";
+			z->msg = (char *)"oversubscribed distance tree";
     else if (r == Z_BUF_ERROR) {
 #ifdef PKZIP_BUG_WORKAROUND
       r = Z_OK;
     }
 #else
-      z->msg = (char*)"incomplete distance tree";
+			z->msg = (char *)"incomplete distance tree";
       r = Z_DATA_ERROR;
-    }
-    else if (r != Z_MEM_ERROR)
-    {
-      z->msg = (char*)"empty distance tree with lengths";
+		} else if (r != Z_MEM_ERROR) {
+			z->msg = (char *)"empty distance tree with lengths";
       r = Z_DATA_ERROR;
     }
     ZFREE(z, v);
@@ -399,24 +379,22 @@
 int inflate_trees_fixed(bl, bd, tl, td, z)
 uIntf *bl;               /* literal desired/actual bit depth */
 uIntf *bd;               /* distance desired/actual bit depth */
-inflate_huft * FAR *tl;  /* literal/length tree result */
-inflate_huft * FAR *td;  /* distance tree result */
+inflate_huft *FAR * tl;		/* literal/length tree result */
+inflate_huft *FAR * td;		/* distance tree result */
 z_streamp z;             /* for memory allocation */
 {
 #ifdef BUILDFIXED
   /* build fixed tables if not already */
-  if (!fixed_built)
-  {
+	if (!fixed_built) {
     int k;              /* temporary variable */
     uInt f = 0;         /* number of hufts used in fixed_mem */
     uIntf *c;           /* length list for huft_build */
     uIntf *v;           /* work area for huft_build */
 
     /* allocate memory */
-    if ((c = (uIntf*)ZALLOC(z, 288, sizeof(uInt))) == Z_NULL)
+		if ((c = (uIntf *) ZALLOC(z, 288, sizeof(uInt))) == Z_NULL)
       return Z_MEM_ERROR;
-    if ((v = (uIntf*)ZALLOC(z, 288, sizeof(uInt))) == Z_NULL)
-    {
+		if ((v = (uIntf *) ZALLOC(z, 288, sizeof(uInt))) == Z_NULL) {
       ZFREE(z, c);
       return Z_MEM_ERROR;
     }
--- zlib-1.1.3/inftrees.h	1998-03-15 17:25:18.000000000 -0500
+++ zlib-1.1.3/inftrees.h	2014-02-07 11:53:21.351328165 -0500
@@ -32,15 +32,13 @@
    value below is more than safe. */
 #define MANY 1440
 
-extern int inflate_trees_bits OF((
-    uIntf *,                    /* 19 code lengths */
+extern int inflate_trees_bits OF((uIntf *,	/* 19 code lengths */
     uIntf *,                    /* bits tree desired/actual depth */
     inflate_huft * FAR *,       /* bits tree result */
     inflate_huft *,             /* space for trees */
     z_streamp));                /* for messages */
 
-extern int inflate_trees_dynamic OF((
-    uInt,                       /* number of literal/length codes */
+extern int inflate_trees_dynamic OF((uInt,	/* number of literal/length codes */
     uInt,                       /* number of distance codes */
     uIntf *,                    /* that many (total) code lengths */
     uIntf *,                    /* literal desired/actual bit depth */
@@ -50,8 +48,7 @@
     inflate_huft *,             /* space for trees */
     z_streamp));                /* for messages */
 
-extern int inflate_trees_fixed OF((
-    uIntf *,                    /* literal desired/actual bit depth */
+extern int inflate_trees_fixed OF((uIntf *,	/* literal desired/actual bit depth */
     uIntf *,                    /* distance desired/actual bit depth */
     inflate_huft * FAR *,       /* literal/length tree result */
     inflate_huft * FAR *,       /* distance tree result */
--- zlib-1.1.3/infutil.c	1998-01-17 15:36:48.000000000 -0500
+++ zlib-1.1.3/infutil.c	2014-02-07 11:53:21.351328165 -0500
@@ -9,7 +9,9 @@
 #include "infcodes.h"
 #include "infutil.h"
 
-struct inflate_codes_state {int dummy;}; /* for buggy compilers */
+struct inflate_codes_state {
+	int dummy;
+};				/* for buggy compilers */
 
 /* And'ing with mask[n] masks the lower n bits */
 uInt inflate_mask[17] = {
@@ -34,9 +35,11 @@
   q = s->read;
 
   /* compute number of bytes to copy as far as end of window */
-  n = (uInt)((q <= s->write ? s->write : s->end) - q);
-  if (n > z->avail_out) n = z->avail_out;
-  if (n && r == Z_BUF_ERROR) r = Z_OK;
+	n = (uInt) ((q <= s->write ? s->write : s->end) - q);
+	if (n > z->avail_out)
+		n = z->avail_out;
+	if (n && r == Z_BUF_ERROR)
+		r = Z_OK;
 
   /* update counters */
   z->avail_out -= n;
@@ -44,7 +47,7 @@
 
   /* update check information */
   if (s->checkfn != Z_NULL)
-    z->adler = s->check = (*s->checkfn)(s->check, q, n);
+		z->adler = s->check = (*s->checkfn) (s->check, q, n);
 
   /* copy as far as end of window */
   zmemcpy(p, q, n);
@@ -52,17 +55,18 @@
   q += n;
 
   /* see if more to copy at beginning of window */
-  if (q == s->end)
-  {
+	if (q == s->end) {
     /* wrap pointers */
     q = s->window;
     if (s->write == s->end)
       s->write = s->window;
 
     /* compute bytes to copy */
-    n = (uInt)(s->write - q);
-    if (n > z->avail_out) n = z->avail_out;
-    if (n && r == Z_BUF_ERROR) r = Z_OK;
+		n = (uInt) (s->write - q);
+		if (n > z->avail_out)
+			n = z->avail_out;
+		if (n && r == Z_BUF_ERROR)
+			r = Z_OK;
 
     /* update counters */
     z->avail_out -= n;
@@ -70,7 +74,7 @@
 
     /* update check information */
     if (s->checkfn != Z_NULL)
-      z->adler = s->check = (*s->checkfn)(s->check, q, n);
+			z->adler = s->check = (*s->checkfn) (s->check, q, n);
 
     /* copy */
     zmemcpy(p, q, n);
--- zlib-1.1.3/infutil.h	1998-02-17 03:59:12.000000000 -0500
+++ zlib-1.1.3/infutil.h	2014-02-07 11:53:21.351328165 -0500
@@ -21,8 +21,8 @@
       CODES,    /* processing fixed or dynamic block */
       DRY,      /* output remaining window bytes */
       DONE,     /* finished last block, done */
-      BAD}      /* got a data error--stuck here */
-inflate_block_mode;
+	BAD
+} /* got a data error--stuck here */ inflate_block_mode;
 
 /* inflate blocks semi-private state */
 struct inflate_blocks_state {
@@ -41,8 +41,7 @@
       inflate_huft *tb;         /* bit length decoding tree */
     } trees;            /* if DTREE, decoding info for trees */
     struct {
-      inflate_codes_statef 
-         *codes;
+			inflate_codes_statef *codes;
     } decode;           /* if CODES, current state */
   } sub;                /* submode */
   uInt last;            /* true if this block is the last block */
@@ -88,11 +86,10 @@
 extern uInt inflate_mask[17];
 
 /* copy as much as possible from the sliding window to the output area */
-extern int inflate_flush OF((
-    inflate_blocks_statef *,
-    z_streamp ,
-    int));
+extern int inflate_flush OF((inflate_blocks_statef *, z_streamp, int));
 
-struct internal_state      {int dummy;}; /* for buggy compilers */
+struct internal_state {
+	int dummy;
+};				/* for buggy compilers */
 
 #endif
--- zlib-1.1.3/maketree.c	1998-06-16 07:27:00.000000000 -0400
+++ zlib-1.1.3/maketree.c	2014-02-07 11:53:21.351328165 -0500
@@ -25,23 +25,22 @@
 #define bits word.what.Bits
 
 /* generate initialization table for an inflate_huft structure array */
-void maketree(uInt b, inflate_huft *t)
+void maketree(uInt b, inflate_huft * t)
 {
   int i, e;
 
   i = 0;
-  while (1)
-  {
+	while (1) {
     e = t[i].exop;
-    if (e && (e & (16+64)) == 0)        /* table pointer */
-    {
-      fprintf(stderr, "maketree: cannot initialize sub-tables!\n");
+		if (e && (e & (16 + 64)) == 0) {	/* table pointer */
+			fprintf(stderr,
+				"maketree: cannot initialize sub-tables!\n");
       exit(1);
     }
     if (i % 4 == 0)
       printf("\n   ");
     printf(" {{{%u,%u}},%u}", t[i].exop, t[i].bits, t[i].base);
-    if (++i == (1<<b))
+		if (++i == (1 << b))
       break;
     putchar(',');
   }
@@ -57,11 +56,10 @@
   z_stream z;
 
   z.zalloc = zcalloc;
-  z.opaque = (voidpf)0;
+	z.opaque = (voidpf) 0;
   z.zfree = zcfree;
   r = inflate_trees_fixed(&bl, &bd, &tl, &td, &z);
-  if (r)
-  {
+	if (r) {
     fprintf(stderr, "inflate_trees_fixed error %d\n", r);
     return;
   }
--- zlib-1.1.3/minigzip.c	1998-04-07 12:04:18.000000000 -0400
+++ zlib-1.1.3/minigzip.c	2014-02-07 11:53:21.352326892 -0500
@@ -13,51 +13,51 @@
  * or in pipe mode.
  */
 
-/* @(#) $Id$ */
+/* @(#) $Id: minigzip.c,v 1.1 2001/11/09 01:48:02 mpl Exp $ */
 
 #include <stdio.h>
 #include "zlib.h"
 
 #ifdef STDC
-#  include <string.h>
-#  include <stdlib.h>
+#include <string.h>
+#include <stdlib.h>
 #else
-   extern void exit  OF((int));
+extern void exit OF((int));
 #endif
 
 #ifdef USE_MMAP
-#  include <sys/types.h>
-#  include <sys/mman.h>
-#  include <sys/stat.h>
+#include <sys/types.h>
+#include <sys/mman.h>
+#include <sys/stat.h>
 #endif
 
 #if defined(MSDOS) || defined(OS2) || defined(WIN32)
-#  include <fcntl.h>
-#  include <io.h>
-#  define SET_BINARY_MODE(file) setmode(fileno(file), O_BINARY)
+#include <fcntl.h>
+#include <io.h>
+#define SET_BINARY_MODE(file) setmode(fileno(file), O_BINARY)
 #else
-#  define SET_BINARY_MODE(file)
+#define SET_BINARY_MODE(file)
 #endif
 
 #ifdef VMS
-#  define unlink delete
-#  define GZ_SUFFIX "-gz"
+#define unlink delete
+#define GZ_SUFFIX "-gz"
 #endif
 #ifdef RISCOS
-#  define unlink remove
-#  define GZ_SUFFIX "-gz"
-#  define fileno(file) file->__file
+#define unlink remove
+#define GZ_SUFFIX "-gz"
+#define fileno(file) file->__file
 #endif
 #if defined(__MWERKS__) && __dest_os != __be_os && __dest_os != __win32_os
-#  include <unix.h> /* for fileno */
+#include <unix.h>		/* for fileno */
 #endif
 
 #ifndef WIN32 /* unlink already in stdio.h for WIN32 */
-  extern int unlink OF((const char *));
+extern int unlink OF((const char *));
 #endif
 
 #ifndef GZ_SUFFIX
-#  define GZ_SUFFIX ".gz"
+#define GZ_SUFFIX ".gz"
 #endif
 #define SUFFIX_LEN (sizeof(GZ_SUFFIX)-1)
 
@@ -65,20 +65,20 @@
 #define MAX_NAME_LEN 1024
 
 #ifdef MAXSEG_64K
-#  define local static
+#define local static
    /* Needed for systems with limitation on stack size. */
 #else
-#  define local
+#define local
 #endif
 
 char *prog;
 
 void error            OF((const char *msg));
-void gz_compress      OF((FILE   *in, gzFile out));
+void gz_compress OF((FILE * in, gzFile out));
 #ifdef USE_MMAP
-int  gz_compress_mmap OF((FILE   *in, gzFile out));
+int gz_compress_mmap OF((FILE * in, gzFile out));
 #endif
-void gz_uncompress    OF((gzFile in, FILE   *out));
+void gz_uncompress OF((gzFile in, FILE * out));
 void file_compress    OF((char  *file, char *mode));
 void file_uncompress  OF((char  *file));
 int  main             OF((int argc, char *argv[]));
@@ -87,7 +87,7 @@
  * Display error message and exit
  */
 void error(msg)
-    const char *msg;
+const char *msg;
 {
     fprintf(stderr, "%s: %s\n", prog, msg);
     exit(1);
@@ -98,8 +98,8 @@
  */
 
 void gz_compress(in, out)
-    FILE   *in;
-    gzFile out;
+FILE *in;
+gzFile out;
 {
     local char buf[BUFLEN];
     int len;
@@ -109,7 +109,8 @@
     /* Try first compressing with mmap. If mmap fails (minigzip used in a
      * pipe), use the normal fread loop.
      */
-    if (gz_compress_mmap(in, out) == Z_OK) return;
+	if (gz_compress_mmap(in, out) == Z_OK)
+		return;
 #endif
     for (;;) {
         len = fread(buf, 1, sizeof(buf), in);
@@ -117,12 +118,15 @@
             perror("fread");
             exit(1);
         }
-        if (len == 0) break;
+		if (len == 0)
+			break;
 
-        if (gzwrite(out, buf, (unsigned)len) != len) error(gzerror(out, &err));
+		if (gzwrite(out, buf, (unsigned)len) != len)
+			error(gzerror(out, &err));
     }
     fclose(in);
-    if (gzclose(out) != Z_OK) error("failed gzclose");
+	if (gzclose(out) != Z_OK)
+		error("failed gzclose");
 }
 
 #ifdef USE_MMAP /* MMAP version, Miguel Albrecht <malbrech@eso.org> */
@@ -131,8 +135,8 @@
  * if success, Z_ERRNO otherwise.
  */
 int gz_compress_mmap(in, out)
-    FILE   *in;
-    gzFile out;
+FILE *in;
+gzFile out;
 {
     int len;
     int err;
@@ -142,22 +146,27 @@
     struct stat sb;
 
     /* Determine the size of the file, needed for mmap: */
-    if (fstat(ifd, &sb) < 0) return Z_ERRNO;
+	if (fstat(ifd, &sb) < 0)
+		return Z_ERRNO;
     buf_len = sb.st_size;
-    if (buf_len <= 0) return Z_ERRNO;
+	if (buf_len <= 0)
+		return Z_ERRNO;
 
     /* Now do the actual mmap: */
-    buf = mmap((caddr_t) 0, buf_len, PROT_READ, MAP_SHARED, ifd, (off_t)0); 
-    if (buf == (caddr_t)(-1)) return Z_ERRNO;
+	buf = mmap((caddr_t) 0, buf_len, PROT_READ, MAP_SHARED, ifd, (off_t) 0);
+	if (buf == (caddr_t) (-1))
+		return Z_ERRNO;
 
     /* Compress the whole file at once: */
     len = gzwrite(out, (char *)buf, (unsigned)buf_len);
 
-    if (len != (int)buf_len) error(gzerror(out, &err));
+	if (len != (int)buf_len)
+		error(gzerror(out, &err));
 
     munmap(buf, buf_len);
     fclose(in);
-    if (gzclose(out) != Z_OK) error("failed gzclose");
+	if (gzclose(out) != Z_OK)
+		error("failed gzclose");
     return Z_OK;
 }
 #endif /* USE_MMAP */
@@ -166,8 +175,8 @@
  * Uncompress input to output then close both files.
  */
 void gz_uncompress(in, out)
-    gzFile in;
-    FILE   *out;
+gzFile in;
+FILE *out;
 {
     local char buf[BUFLEN];
     int len;
@@ -175,19 +184,22 @@
 
     for (;;) {
         len = gzread(in, buf, sizeof(buf));
-        if (len < 0) error (gzerror(in, &err));
-        if (len == 0) break;
+		if (len < 0)
+			error(gzerror(in, &err));
+		if (len == 0)
+			break;
 
         if ((int)fwrite(buf, 1, (unsigned)len, out) != len) {
 	    error("failed fwrite");
 	}
     }
-    if (fclose(out)) error("failed fclose");
+	if (fclose(out))
+		error("failed fclose");
 
-    if (gzclose(in) != Z_OK) error("failed gzclose");
+	if (gzclose(in) != Z_OK)
+		error("failed gzclose");
 }
 
-
 /* ===========================================================================
  * Compress the given file: create a corresponding .gz file and remove the
  * original.
@@ -193,8 +205,8 @@
  * original.
  */
 void file_compress(file, mode)
-    char  *file;
-    char  *mode;
+char *file;
+char *mode;
 {
     local char outfile[MAX_NAME_LEN];
     FILE  *in;
@@ -223,7 +234,7 @@
  * Uncompress the given file and remove the original.
  */
 void file_uncompress(file)
-    char  *file;
+char *file;
 {
     local char buf[MAX_NAME_LEN];
     char *infile, *outfile;
@@ -233,10 +244,10 @@
 
     strcpy(buf, file);
 
-    if (len > SUFFIX_LEN && strcmp(file+len-SUFFIX_LEN, GZ_SUFFIX) == 0) {
+	if (len > SUFFIX_LEN && strcmp(file + len - SUFFIX_LEN, GZ_SUFFIX) == 0) {
         infile = file;
         outfile = buf;
-        outfile[len-3] = '\0';
+		outfile[len - 3] = '\0';
     } else {
         outfile = file;
         infile = buf;
@@ -268,8 +278,8 @@
  */
 
 int main(argc, argv)
-    int argc;
-    char *argv[];
+int argc;
+char *argv[];
 {
     int uncompr = 0;
     gzFile file;
@@ -287,8 +297,8 @@
 	outmode[3] = 'f';
       else if (strcmp(*argv, "-h") == 0)
 	outmode[3] = 'h';
-      else if ((*argv)[0] == '-' && (*argv)[1] >= '1' && (*argv)[1] <= '9' &&
-	       (*argv)[2] == 0)
+		else if ((*argv)[0] == '-' && (*argv)[1] >= '1'
+			 && (*argv)[1] <= '9' && (*argv)[2] == 0)
 	outmode[2] = (*argv)[1];
       else
 	break;
@@ -299,11 +309,13 @@
         SET_BINARY_MODE(stdout);
         if (uncompr) {
             file = gzdopen(fileno(stdin), "rb");
-            if (file == NULL) error("can't gzdopen stdin");
+			if (file == NULL)
+				error("can't gzdopen stdin");
             gz_uncompress(file, stdout);
         } else {
             file = gzdopen(fileno(stdout), outmode);
-            if (file == NULL) error("can't gzdopen stdout");
+			if (file == NULL)
+				error("can't gzdopen stdout");
             gz_compress(stdin, file);
         }
     } else {
--- zlib-1.1.3/trees.c	1998-07-08 12:32:57.000000000 -0400
+++ zlib-1.1.3/trees.c	2014-02-07 11:53:21.352326892 -0500
@@ -29,14 +29,14 @@
  *          Addison-Wesley, 1983. ISBN 0-201-06672-6.
  */
 
-/* @(#) $Id$ */
+/* @(#) $Id: trees.c,v 1.1 2001/11/09 01:48:02 mpl Exp $ */
 
 /* #define GEN_TREES_H */
 
 #include "deflate.h"
 
 #ifdef DEBUG
-#  include <ctype.h>
+#include <ctype.h>
 #endif
 
 /* ===========================================================================
@@ -59,16 +59,21 @@
 /* repeat a zero length 11-138 times  (7 bits of repeat count) */
 
 local const int extra_lbits[LENGTH_CODES] /* extra bits for each length code */
-   = {0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0};
+    = { 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4,
+	5, 5, 5, 5, 0
+};
 
 local const int extra_dbits[D_CODES] /* extra bits for each distance code */
-   = {0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13};
+    = { 0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10,
+	10, 11, 11, 12, 12, 13, 13
+};
 
-local const int extra_blbits[BL_CODES]/* extra bits for each bit length code */
-   = {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,3,7};
+local const int extra_blbits[BL_CODES]	/* extra bits for each bit length code */
+= { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7 };
 
 local const uch bl_order[BL_CODES]
-   = {16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15};
+= { 16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15 };
+
 /* The lengths of the bit length codes are sent in order of decreasing
  * probability, to avoid transmitting the lengths for unused bit length codes.
  */
@@ -87,7 +92,7 @@
 #if defined(GEN_TREES_H) || !defined(STDC)
 /* non ANSI compilers may not accept trees.h */
 
-local ct_data static_ltree[L_CODES+2];
+local ct_data static_ltree[L_CODES + 2];
 /* The static literal tree. Since the bit lengths are imposed, there is no
  * need for the L_CODES extra codes used during heap construction. However
  * The codes 286 and 287 are needed to build a canonical tree (see _tr_init
@@ -105,7 +110,7 @@
  * the 15 bit distances.
  */
 
-uch _length_code[MAX_MATCH-MIN_MATCH+1];
+uch _length_code[MAX_MATCH - MIN_MATCH + 1];
 /* length code for each normalized match length (0 == MIN_MATCH) */
 
 local int base_length[LENGTH_CODES];
@@ -115,7 +120,7 @@
 /* First normalized distance for each code (0 = distance of 1) */
 
 #else
-#  include "trees.h"
+#include "trees.h"
 #endif /* GEN_TREES_H */
 
 struct static_tree_desc_s {
@@ -127,36 +132,36 @@
 };
 
 local static_tree_desc  static_l_desc =
-{static_ltree, extra_lbits, LITERALS+1, L_CODES, MAX_BITS};
+    { static_ltree, extra_lbits, LITERALS + 1, L_CODES, MAX_BITS };
 
 local static_tree_desc  static_d_desc =
-{static_dtree, extra_dbits, 0,          D_CODES, MAX_BITS};
+    { static_dtree, extra_dbits, 0, D_CODES, MAX_BITS };
 
 local static_tree_desc  static_bl_desc =
-{(const ct_data *)0, extra_blbits, 0,   BL_CODES, MAX_BL_BITS};
+    { (const ct_data *)0, extra_blbits, 0, BL_CODES, MAX_BL_BITS };
 
 /* ===========================================================================
  * Local (static) routines in this file.
  */
 
 local void tr_static_init OF((void));
-local void init_block     OF((deflate_state *s));
-local void pqdownheap     OF((deflate_state *s, ct_data *tree, int k));
-local void gen_bitlen     OF((deflate_state *s, tree_desc *desc));
-local void gen_codes      OF((ct_data *tree, int max_code, ushf *bl_count));
-local void build_tree     OF((deflate_state *s, tree_desc *desc));
-local void scan_tree      OF((deflate_state *s, ct_data *tree, int max_code));
-local void send_tree      OF((deflate_state *s, ct_data *tree, int max_code));
-local int  build_bl_tree  OF((deflate_state *s));
-local void send_all_trees OF((deflate_state *s, int lcodes, int dcodes,
+local void init_block OF((deflate_state * s));
+local void pqdownheap OF((deflate_state * s, ct_data * tree, int k));
+local void gen_bitlen OF((deflate_state * s, tree_desc * desc));
+local void gen_codes OF((ct_data * tree, int max_code, ushf * bl_count));
+local void build_tree OF((deflate_state * s, tree_desc * desc));
+local void scan_tree OF((deflate_state * s, ct_data * tree, int max_code));
+local void send_tree OF((deflate_state * s, ct_data * tree, int max_code));
+local int build_bl_tree OF((deflate_state * s));
+local void send_all_trees OF((deflate_state * s, int lcodes, int dcodes,
                               int blcodes));
-local void compress_block OF((deflate_state *s, ct_data *ltree,
-                              ct_data *dtree));
-local void set_data_type  OF((deflate_state *s));
+local void compress_block OF((deflate_state * s, ct_data * ltree,
+			      ct_data * dtree));
+local void set_data_type OF((deflate_state * s));
 local unsigned bi_reverse OF((unsigned value, int length));
-local void bi_windup      OF((deflate_state *s));
-local void bi_flush       OF((deflate_state *s));
-local void copy_block     OF((deflate_state *s, charf *buf, unsigned len,
+local void bi_windup OF((deflate_state * s));
+local void bi_flush OF((deflate_state * s));
+local void copy_block OF((deflate_state * s, charf * buf, unsigned len,
                               int header));
 
 #ifdef GEN_TREES_H
@@ -164,11 +169,11 @@
 #endif
 
 #ifndef DEBUG
-#  define send_code(s, c, tree) send_bits(s, tree[c].Code, tree[c].Len)
+#define send_code(s, c, tree) send_bits(s, tree[c].Code, tree[c].Len)
    /* Send a code of the given tree. c and tree must not have side effects */
 
 #else /* DEBUG */
-#  define send_code(s, c, tree) \
+#define send_code(s, c, tree) \
      { if (z_verbose>2) fprintf(stderr,"\ncd %3d ",(c)); \
        send_bits(s, tree[c].Code, tree[c].Len); }
 #endif
@@ -187,16 +192,16 @@
  * IN assertion: length <= 16 and value fits in length bits.
  */
 #ifdef DEBUG
-local void send_bits      OF((deflate_state *s, int value, int length));
+local void send_bits OF((deflate_state * s, int value, int length));
 
 local void send_bits(s, value, length)
-    deflate_state *s;
-    int value;  /* value to send */
-    int length; /* number of bits */
+deflate_state *s;
+int value;			/* value to send */
+int length;			/* number of bits */
 {
-    Tracevv((stderr," l %2d v %4x ", length, value));
+	Tracevv((stderr, " l %2d v %4x ", length, value));
     Assert(length > 0 && length <= 15, "invalid length");
-    s->bits_sent += (ulg)length;
+	s->bits_sent += (ulg) length;
 
     /* If not enough room in bi_buf, use (valid) bits from bi_buf and
      * (16 - bi_valid) bits from value, leaving (width - (16-bi_valid))
@@ -205,7 +210,7 @@
     if (s->bi_valid > (int)Buf_size - length) {
         s->bi_buf |= (value << s->bi_valid);
         put_short(s, s->bi_buf);
-        s->bi_buf = (ush)value >> (Buf_size - s->bi_valid);
+		s->bi_buf = (ush) value >> (Buf_size - s->bi_valid);
         s->bi_valid += length - Buf_size;
     } else {
         s->bi_buf |= value << s->bi_valid;
@@ -245,10 +249,11 @@
     int length;   /* length value */
     int code;     /* code value */
     int dist;     /* distance index */
-    ush bl_count[MAX_BITS+1];
+	ush bl_count[MAX_BITS + 1];
     /* number of codes at each bit length for an optimal tree */
 
-    if (static_init_done) return;
+	if (static_init_done)
+		return;
 
     /* For some embedded targets, global variables are not initialized: */
     static_l_desc.static_tree = static_ltree;
@@ -259,49 +264,54 @@
 
     /* Initialize the mapping length (0..255) -> length code (0..28) */
     length = 0;
-    for (code = 0; code < LENGTH_CODES-1; code++) {
+	for (code = 0; code < LENGTH_CODES - 1; code++) {
         base_length[code] = length;
-        for (n = 0; n < (1<<extra_lbits[code]); n++) {
-            _length_code[length++] = (uch)code;
+		for (n = 0; n < (1 << extra_lbits[code]); n++) {
+			_length_code[length++] = (uch) code;
         }
     }
-    Assert (length == 256, "tr_static_init: length != 256");
+	Assert(length == 256, "tr_static_init: length != 256");
     /* Note that the length 255 (match length 258) can be represented
      * in two different ways: code 284 + 5 bits or code 285, so we
      * overwrite length_code[255] to use the best encoding:
      */
-    _length_code[length-1] = (uch)code;
+	_length_code[length - 1] = (uch) code;
 
     /* Initialize the mapping dist (0..32K) -> dist code (0..29) */
     dist = 0;
-    for (code = 0 ; code < 16; code++) {
+	for (code = 0; code < 16; code++) {
         base_dist[code] = dist;
-        for (n = 0; n < (1<<extra_dbits[code]); n++) {
-            _dist_code[dist++] = (uch)code;
+		for (n = 0; n < (1 << extra_dbits[code]); n++) {
+			_dist_code[dist++] = (uch) code;
         }
     }
-    Assert (dist == 256, "tr_static_init: dist != 256");
+	Assert(dist == 256, "tr_static_init: dist != 256");
     dist >>= 7; /* from now on, all distances are divided by 128 */
-    for ( ; code < D_CODES; code++) {
+	for (; code < D_CODES; code++) {
         base_dist[code] = dist << 7;
-        for (n = 0; n < (1<<(extra_dbits[code]-7)); n++) {
-            _dist_code[256 + dist++] = (uch)code;
+		for (n = 0; n < (1 << (extra_dbits[code] - 7)); n++) {
+			_dist_code[256 + dist++] = (uch) code;
         }
     }
-    Assert (dist == 256, "tr_static_init: 256+dist != 512");
+	Assert(dist == 256, "tr_static_init: 256+dist != 512");
 
     /* Construct the codes of the static literal tree */
-    for (bits = 0; bits <= MAX_BITS; bits++) bl_count[bits] = 0;
+	for (bits = 0; bits <= MAX_BITS; bits++)
+		bl_count[bits] = 0;
     n = 0;
-    while (n <= 143) static_ltree[n++].Len = 8, bl_count[8]++;
-    while (n <= 255) static_ltree[n++].Len = 9, bl_count[9]++;
-    while (n <= 279) static_ltree[n++].Len = 7, bl_count[7]++;
-    while (n <= 287) static_ltree[n++].Len = 8, bl_count[8]++;
+	while (n <= 143)
+		static_ltree[n++].Len = 8, bl_count[8]++;
+	while (n <= 255)
+		static_ltree[n++].Len = 9, bl_count[9]++;
+	while (n <= 279)
+		static_ltree[n++].Len = 7, bl_count[7]++;
+	while (n <= 287)
+		static_ltree[n++].Len = 8, bl_count[8]++;
     /* Codes 286 and 287 do not exist, but we must include them in the
      * tree construction to get a canonical Huffman tree (longest code
      * all ones)
      */
-    gen_codes((ct_data *)static_ltree, L_CODES+1, bl_count);
+	gen_codes((ct_data *) static_ltree, L_CODES + 1, bl_count);
 
     /* The static distance tree is trivial: */
     for (n = 0; n < D_CODES; n++) {
@@ -310,9 +320,9 @@
     }
     static_init_done = 1;
 
-#  ifdef GEN_TREES_H
+#ifdef GEN_TREES_H
     gen_trees_header();
-#  endif
+#endif
 #endif /* defined(GEN_TREES_H) || !defined(STDC) */
 }
 
@@ -320,11 +330,11 @@
  * Genererate the file trees.h describing the static trees.
  */
 #ifdef GEN_TREES_H
-#  ifndef DEBUG
-#    include <stdio.h>
-#  endif
+#ifndef DEBUG
+#include <stdio.h>
+#endif
 
-#  define SEPARATOR(i, last, width) \
+#define SEPARATOR(i, last, width) \
       ((i) == (last)? "\n};\n\n" :    \
        ((i) % (width) == (width)-1 ? ",\n" : ", "))
 
@@ -333,44 +343,44 @@
     FILE *header = fopen("trees.h", "w");
     int i;
 
-    Assert (header != NULL, "Can't open trees.h");
+	Assert(header != NULL, "Can't open trees.h");
     fprintf(header,
 	    "/* header created automatically with -DGEN_TREES_H */\n\n");
 
     fprintf(header, "local const ct_data static_ltree[L_CODES+2] = {\n");
-    for (i = 0; i < L_CODES+2; i++) {
+	for (i = 0; i < L_CODES + 2; i++) {
 	fprintf(header, "{{%3u},{%3u}}%s", static_ltree[i].Code,
-		static_ltree[i].Len, SEPARATOR(i, L_CODES+1, 5));
+			static_ltree[i].Len, SEPARATOR(i, L_CODES + 1, 5));
     }
 
     fprintf(header, "local const ct_data static_dtree[D_CODES] = {\n");
     for (i = 0; i < D_CODES; i++) {
 	fprintf(header, "{{%2u},{%2u}}%s", static_dtree[i].Code,
-		static_dtree[i].Len, SEPARATOR(i, D_CODES-1, 5));
+			static_dtree[i].Len, SEPARATOR(i, D_CODES - 1, 5));
     }
 
     fprintf(header, "const uch _dist_code[DIST_CODE_LEN] = {\n");
     for (i = 0; i < DIST_CODE_LEN; i++) {
 	fprintf(header, "%2u%s", _dist_code[i],
-		SEPARATOR(i, DIST_CODE_LEN-1, 20));
+			SEPARATOR(i, DIST_CODE_LEN - 1, 20));
     }
 
     fprintf(header, "const uch _length_code[MAX_MATCH-MIN_MATCH+1]= {\n");
-    for (i = 0; i < MAX_MATCH-MIN_MATCH+1; i++) {
+	for (i = 0; i < MAX_MATCH - MIN_MATCH + 1; i++) {
 	fprintf(header, "%2u%s", _length_code[i],
-		SEPARATOR(i, MAX_MATCH-MIN_MATCH, 20));
+			SEPARATOR(i, MAX_MATCH - MIN_MATCH, 20));
     }
 
     fprintf(header, "local const int base_length[LENGTH_CODES] = {\n");
     for (i = 0; i < LENGTH_CODES; i++) {
 	fprintf(header, "%1u%s", base_length[i],
-		SEPARATOR(i, LENGTH_CODES-1, 20));
+			SEPARATOR(i, LENGTH_CODES - 1, 20));
     }
 
     fprintf(header, "local const int base_dist[D_CODES] = {\n");
     for (i = 0; i < D_CODES; i++) {
 	fprintf(header, "%5u%s", base_dist[i],
-		SEPARATOR(i, D_CODES-1, 10));
+			SEPARATOR(i, D_CODES - 1, 10));
     }
 
     fclose(header);
@@ -381,7 +391,7 @@
  * Initialize the tree data structures for a new zlib stream.
  */
 void _tr_init(s)
-    deflate_state *s;
+deflate_state *s;
 {
     tr_static_init();
 
@@ -410,14 +420,17 @@
  * Initialize a new block.
  */
 local void init_block(s)
-    deflate_state *s;
+deflate_state *s;
 {
     int n; /* iterates over tree elements */
 
     /* Initialize the trees. */
-    for (n = 0; n < L_CODES;  n++) s->dyn_ltree[n].Freq = 0;
-    for (n = 0; n < D_CODES;  n++) s->dyn_dtree[n].Freq = 0;
-    for (n = 0; n < BL_CODES; n++) s->bl_tree[n].Freq = 0;
+	for (n = 0; n < L_CODES; n++)
+		s->dyn_ltree[n].Freq = 0;
+	for (n = 0; n < D_CODES; n++)
+		s->dyn_dtree[n].Freq = 0;
+	for (n = 0; n < BL_CODES; n++)
+		s->bl_tree[n].Freq = 0;
 
     s->dyn_ltree[END_BLOCK].Freq = 1;
     s->opt_len = s->static_len = 0L;
@@ -454,23 +466,25 @@
  * two sons).
  */
 local void pqdownheap(s, tree, k)
-    deflate_state *s;
-    ct_data *tree;  /* the tree to restore */
-    int k;               /* node to move down */
+deflate_state *s;
+ct_data *tree;			/* the tree to restore */
+int k;				/* node to move down */
 {
     int v = s->heap[k];
     int j = k << 1;  /* left son of k */
     while (j <= s->heap_len) {
         /* Set j to the smallest of the two sons: */
         if (j < s->heap_len &&
-            smaller(tree, s->heap[j+1], s->heap[j], s->depth)) {
+		    smaller(tree, s->heap[j + 1], s->heap[j], s->depth)) {
             j++;
         }
         /* Exit if v is smaller than both sons */
-        if (smaller(tree, v, s->heap[j], s->depth)) break;
+		if (smaller(tree, v, s->heap[j], s->depth))
+			break;
 
         /* Exchange v with the smallest son */
-        s->heap[k] = s->heap[j];  k = j;
+		s->heap[k] = s->heap[j];
+		k = j;
 
         /* And continue down the tree, setting j to the left son of k */
         j <<= 1;
@@ -489,8 +503,8 @@
  *     not null.
  */
 local void gen_bitlen(s, desc)
-    deflate_state *s;
-    tree_desc *desc;    /* the tree descriptor */
+deflate_state *s;
+tree_desc *desc;		/* the tree descriptor */
 {
     ct_data *tree        = desc->dyn_tree;
     int max_code         = desc->max_code;
@@ -505,40 +519,47 @@
     ush f;              /* frequency */
     int overflow = 0;   /* number of elements with bit length too large */
 
-    for (bits = 0; bits <= MAX_BITS; bits++) s->bl_count[bits] = 0;
+	for (bits = 0; bits <= MAX_BITS; bits++)
+		s->bl_count[bits] = 0;
 
     /* In a first pass, compute the optimal bit lengths (which may
      * overflow in the case of the bit length tree).
      */
     tree[s->heap[s->heap_max]].Len = 0; /* root of the heap */
 
-    for (h = s->heap_max+1; h < HEAP_SIZE; h++) {
+	for (h = s->heap_max + 1; h < HEAP_SIZE; h++) {
         n = s->heap[h];
         bits = tree[tree[n].Dad].Len + 1;
-        if (bits > max_length) bits = max_length, overflow++;
-        tree[n].Len = (ush)bits;
+		if (bits > max_length)
+			bits = max_length, overflow++;
+		tree[n].Len = (ush) bits;
         /* We overwrite tree[n].Dad which is no longer needed */
 
-        if (n > max_code) continue; /* not a leaf node */
+		if (n > max_code)
+			continue;	/* not a leaf node */
 
         s->bl_count[bits]++;
         xbits = 0;
-        if (n >= base) xbits = extra[n-base];
+		if (n >= base)
+			xbits = extra[n - base];
         f = tree[n].Freq;
-        s->opt_len += (ulg)f * (bits + xbits);
-        if (stree) s->static_len += (ulg)f * (stree[n].Len + xbits);
+		s->opt_len += (ulg) f *(bits + xbits);
+		if (stree)
+			s->static_len += (ulg) f *(stree[n].Len + xbits);
     }
-    if (overflow == 0) return;
+	if (overflow == 0)
+		return;
 
-    Trace((stderr,"\nbit length overflow\n"));
+	Trace((stderr, "\nbit length overflow\n"));
     /* This happens for example on obj2 and pic of the Calgary corpus */
 
     /* Find the first bit length which could increase: */
     do {
-        bits = max_length-1;
-        while (s->bl_count[bits] == 0) bits--;
+		bits = max_length - 1;
+		while (s->bl_count[bits] == 0)
+			bits--;
         s->bl_count[bits]--;      /* move one leaf down the tree */
-        s->bl_count[bits+1] += 2; /* move one overflow item as its brother */
+		s->bl_count[bits + 1] += 2;	/* move one overflow item as its brother */
         s->bl_count[max_length]--;
         /* The brother of the overflow item also moves one step up,
          * but this does not affect bl_count[max_length]
@@ -555,12 +576,14 @@
         n = s->bl_count[bits];
         while (n != 0) {
             m = s->heap[--h];
-            if (m > max_code) continue;
-            if (tree[m].Len != (unsigned) bits) {
-                Trace((stderr,"code %d bits %d->%d\n", m, tree[m].Len, bits));
+			if (m > max_code)
+				continue;
+			if (tree[m].Len != (unsigned)bits) {
+				Trace((stderr, "code %d bits %d->%d\n", m,
+				       tree[m].Len, bits));
                 s->opt_len += ((long)bits - (long)tree[m].Len)
-                              *(long)tree[m].Freq;
-                tree[m].Len = (ush)bits;
+				    * (long)tree[m].Freq;
+				tree[m].Len = (ush) bits;
             }
             n--;
         }
@@ -575,12 +598,12 @@
  * OUT assertion: the field code is set for all tree elements of non
  *     zero code length.
  */
-local void gen_codes (tree, max_code, bl_count)
-    ct_data *tree;             /* the tree to decorate */
-    int max_code;              /* largest code with non zero frequency */
-    ushf *bl_count;            /* number of codes at each bit length */
+local void gen_codes(tree, max_code, bl_count)
+ct_data *tree;			/* the tree to decorate */
+int max_code;			/* largest code with non zero frequency */
+ushf *bl_count;			/* number of codes at each bit length */
 {
-    ush next_code[MAX_BITS+1]; /* next code value for each bit length */
+	ush next_code[MAX_BITS + 1];	/* next code value for each bit length */
     ush code = 0;              /* running code value */
     int bits;                  /* bit index */
     int n;                     /* code index */
@@ -589,23 +612,26 @@
      * without bit reversal.
      */
     for (bits = 1; bits <= MAX_BITS; bits++) {
-        next_code[bits] = code = (code + bl_count[bits-1]) << 1;
+		next_code[bits] = code = (code + bl_count[bits - 1]) << 1;
     }
     /* Check that the bit counts in bl_count are consistent. The last code
      * must be all ones.
      */
-    Assert (code + bl_count[MAX_BITS]-1 == (1<<MAX_BITS)-1,
+	Assert(code + bl_count[MAX_BITS] - 1 == (1 << MAX_BITS) - 1,
             "inconsistent bit counts");
-    Tracev((stderr,"\ngen_codes: max_code %d ", max_code));
+	Tracev((stderr, "\ngen_codes: max_code %d ", max_code));
 
     for (n = 0;  n <= max_code; n++) {
         int len = tree[n].Len;
-        if (len == 0) continue;
+		if (len == 0)
+			continue;
         /* Now reverse the bits */
         tree[n].Code = bi_reverse(next_code[len]++, len);
 
-        Tracecv(tree != static_ltree, (stderr,"\nn %3d %c l %2d c %4x (%x) ",
-             n, (isgraph(n) ? n : ' '), len, tree[n].Code, next_code[len]-1));
+		Tracecv(tree != static_ltree,
+			(stderr, "\nn %3d %c l %2d c %4x (%x) ", n,
+			 (isgraph(n) ? n : ' '), len, tree[n].Code,
+			 next_code[len] - 1));
     }
 }
 
@@ -618,8 +644,8 @@
  *     also updated if stree is not null. The field max_code is set.
  */
 local void build_tree(s, desc)
-    deflate_state *s;
-    tree_desc *desc; /* the tree descriptor */
+deflate_state *s;
+tree_desc *desc;		/* the tree descriptor */
 {
     ct_data *tree         = desc->dyn_tree;
     const ct_data *stree  = desc->stat_desc->static_tree;
@@ -649,10 +675,13 @@
      * two codes of non zero frequency.
      */
     while (s->heap_len < 2) {
-        node = s->heap[++(s->heap_len)] = (max_code < 2 ? ++max_code : 0);
+		node = s->heap[++(s->heap_len)] =
+		    (max_code < 2 ? ++max_code : 0);
         tree[node].Freq = 1;
         s->depth[node] = 0;
-        s->opt_len--; if (stree) s->static_len -= stree[node].Len;
+		s->opt_len--;
+		if (stree)
+			s->static_len -= stree[node].Len;
         /* node is 0 or 1 so it does not have extra bits */
     }
     desc->max_code = max_code;
@@ -660,7 +689,8 @@
     /* The elements heap[heap_len/2+1 .. heap_len] are leaves of the tree,
      * establish sub-heaps of increasing lengths:
      */
-    for (n = s->heap_len/2; n >= 1; n--) pqdownheap(s, tree, n);
+	for (n = s->heap_len / 2; n >= 1; n--)
+		pqdownheap(s, tree, n);
 
     /* Construct the Huffman tree by repeatedly combining the least two
      * frequent nodes.
@@ -676,11 +706,12 @@
         /* Create a new node father of n and m */
         tree[node].Freq = tree[n].Freq + tree[m].Freq;
         s->depth[node] = (uch) (MAX(s->depth[n], s->depth[m]) + 1);
-        tree[n].Dad = tree[m].Dad = (ush)node;
+		tree[n].Dad = tree[m].Dad = (ush) node;
 #ifdef DUMP_BL_TREE
         if (tree == s->bl_tree) {
-            fprintf(stderr,"\nnode %d(%d), sons %d(%d) %d(%d)",
-                    node, tree[node].Freq, n, tree[n].Freq, m, tree[m].Freq);
+			fprintf(stderr, "\nnode %d(%d), sons %d(%d) %d(%d)",
+				node, tree[node].Freq, n, tree[n].Freq, m,
+				tree[m].Freq);
         }
 #endif
         /* and insert the new node in the heap */
@@ -694,20 +725,20 @@
     /* At this point, the fields freq and dad are set. We can now
      * generate the bit lengths.
      */
-    gen_bitlen(s, (tree_desc *)desc);
+	gen_bitlen(s, (tree_desc *) desc);
 
     /* The field len is now set, we can generate the bit codes */
-    gen_codes ((ct_data *)tree, max_code, s->bl_count);
+	gen_codes((ct_data *) tree, max_code, s->bl_count);
 }
 
 /* ===========================================================================
  * Scan a literal or distance tree to determine the frequencies of the codes
  * in the bit length tree.
  */
-local void scan_tree (s, tree, max_code)
-    deflate_state *s;
-    ct_data *tree;   /* the tree to be scanned */
-    int max_code;    /* and its largest code of non zero frequency */
+local void scan_tree(s, tree, max_code)
+deflate_state *s;
+ct_data *tree;			/* the tree to be scanned */
+int max_code;			/* and its largest code of non zero frequency */
 {
     int n;                     /* iterates over all tree elements */
     int prevlen = -1;          /* last emitted length */
@@ -717,24 +748,28 @@
     int max_count = 7;         /* max repeat count */
     int min_count = 4;         /* min repeat count */
 
-    if (nextlen == 0) max_count = 138, min_count = 3;
-    tree[max_code+1].Len = (ush)0xffff; /* guard */
+	if (nextlen == 0)
+		max_count = 138, min_count = 3;
+	tree[max_code + 1].Len = (ush) 0xffff;	/* guard */
 
     for (n = 0; n <= max_code; n++) {
-        curlen = nextlen; nextlen = tree[n+1].Len;
+		curlen = nextlen;
+		nextlen = tree[n + 1].Len;
         if (++count < max_count && curlen == nextlen) {
             continue;
         } else if (count < min_count) {
             s->bl_tree[curlen].Freq += count;
         } else if (curlen != 0) {
-            if (curlen != prevlen) s->bl_tree[curlen].Freq++;
+			if (curlen != prevlen)
+				s->bl_tree[curlen].Freq++;
             s->bl_tree[REP_3_6].Freq++;
         } else if (count <= 10) {
             s->bl_tree[REPZ_3_10].Freq++;
         } else {
             s->bl_tree[REPZ_11_138].Freq++;
         }
-        count = 0; prevlen = curlen;
+		count = 0;
+		prevlen = curlen;
         if (nextlen == 0) {
             max_count = 138, min_count = 3;
         } else if (curlen == nextlen) {
@@ -749,10 +784,10 @@
  * Send a literal or distance tree in compressed form, using the codes in
  * bl_tree.
  */
-local void send_tree (s, tree, max_code)
-    deflate_state *s;
-    ct_data *tree; /* the tree to be scanned */
-    int max_code;       /* and its largest code of non zero frequency */
+local void send_tree(s, tree, max_code)
+deflate_state *s;
+ct_data *tree;			/* the tree to be scanned */
+int max_code;			/* and its largest code of non zero frequency */
 {
     int n;                     /* iterates over all tree elements */
     int prevlen = -1;          /* last emitted length */
@@ -762,30 +797,39 @@
     int max_count = 7;         /* max repeat count */
     int min_count = 4;         /* min repeat count */
 
-    /* tree[max_code+1].Len = -1; */  /* guard already set */
-    if (nextlen == 0) max_count = 138, min_count = 3;
+	/* tree[max_code+1].Len = -1; *//* guard already set */
+	if (nextlen == 0)
+		max_count = 138, min_count = 3;
 
     for (n = 0; n <= max_code; n++) {
-        curlen = nextlen; nextlen = tree[n+1].Len;
+		curlen = nextlen;
+		nextlen = tree[n + 1].Len;
         if (++count < max_count && curlen == nextlen) {
             continue;
         } else if (count < min_count) {
-            do { send_code(s, curlen, s->bl_tree); } while (--count != 0);
+			do {
+				send_code(s, curlen, s->bl_tree);
+			} while (--count != 0);
 
         } else if (curlen != 0) {
             if (curlen != prevlen) {
-                send_code(s, curlen, s->bl_tree); count--;
+				send_code(s, curlen, s->bl_tree);
+				count--;
             }
             Assert(count >= 3 && count <= 6, " 3_6?");
-            send_code(s, REP_3_6, s->bl_tree); send_bits(s, count-3, 2);
+			send_code(s, REP_3_6, s->bl_tree);
+			send_bits(s, count - 3, 2);
 
         } else if (count <= 10) {
-            send_code(s, REPZ_3_10, s->bl_tree); send_bits(s, count-3, 3);
+			send_code(s, REPZ_3_10, s->bl_tree);
+			send_bits(s, count - 3, 3);
 
         } else {
-            send_code(s, REPZ_11_138, s->bl_tree); send_bits(s, count-11, 7);
+			send_code(s, REPZ_11_138, s->bl_tree);
+			send_bits(s, count - 11, 7);
         }
-        count = 0; prevlen = curlen;
+		count = 0;
+		prevlen = curlen;
         if (nextlen == 0) {
             max_count = 138, min_count = 3;
         } else if (curlen == nextlen) {
@@ -801,16 +845,16 @@
  * bl_order of the last bit length code to send.
  */
 local int build_bl_tree(s)
-    deflate_state *s;
+deflate_state *s;
 {
     int max_blindex;  /* index of last bit length code of non zero freq */
 
     /* Determine the bit length frequencies for literal and distance trees */
-    scan_tree(s, (ct_data *)s->dyn_ltree, s->l_desc.max_code);
-    scan_tree(s, (ct_data *)s->dyn_dtree, s->d_desc.max_code);
+	scan_tree(s, (ct_data *) s->dyn_ltree, s->l_desc.max_code);
+	scan_tree(s, (ct_data *) s->dyn_dtree, s->d_desc.max_code);
 
     /* Build the bit length tree: */
-    build_tree(s, (tree_desc *)(&(s->bl_desc)));
+	build_tree(s, (tree_desc *) (&(s->bl_desc)));
     /* opt_len now includes the length of the tree representations, except
      * the lengths of the bit lengths codes and the 5+5+4 bits for the counts.
      */
@@ -819,11 +863,12 @@
      * requires that at least 4 bit length codes be sent. (appnote.txt says
      * 3 but the actual value used is 4.)
      */
-    for (max_blindex = BL_CODES-1; max_blindex >= 3; max_blindex--) {
-        if (s->bl_tree[bl_order[max_blindex]].Len != 0) break;
+	for (max_blindex = BL_CODES - 1; max_blindex >= 3; max_blindex--) {
+		if (s->bl_tree[bl_order[max_blindex]].Len != 0)
+			break;
     }
     /* Update opt_len to include the bit length tree and counts */
-    s->opt_len += 3*(max_blindex+1) + 5+5+4;
+	s->opt_len += 3 * (max_blindex + 1) + 5 + 5 + 4;
     Tracev((stderr, "\ndyn trees: dyn %ld, stat %ld",
             s->opt_len, s->static_len));
 
@@ -836,28 +881,29 @@
  * IN assertion: lcodes >= 257, dcodes >= 1, blcodes >= 4.
  */
 local void send_all_trees(s, lcodes, dcodes, blcodes)
-    deflate_state *s;
-    int lcodes, dcodes, blcodes; /* number of codes for each tree */
+deflate_state *s;
+int lcodes, dcodes, blcodes;	/* number of codes for each tree */
 {
     int rank;                    /* index in bl_order */
 
-    Assert (lcodes >= 257 && dcodes >= 1 && blcodes >= 4, "not enough codes");
-    Assert (lcodes <= L_CODES && dcodes <= D_CODES && blcodes <= BL_CODES,
-            "too many codes");
+	Assert(lcodes >= 257 && dcodes >= 1
+	       && blcodes >= 4, "not enough codes");
+	Assert(lcodes <= L_CODES && dcodes <= D_CODES
+	       && blcodes <= BL_CODES, "too many codes");
     Tracev((stderr, "\nbl counts: "));
-    send_bits(s, lcodes-257, 5); /* not +255 as stated in appnote.txt */
-    send_bits(s, dcodes-1,   5);
-    send_bits(s, blcodes-4,  4); /* not -3 as stated in appnote.txt */
+	send_bits(s, lcodes - 257, 5);	/* not +255 as stated in appnote.txt */
+	send_bits(s, dcodes - 1, 5);
+	send_bits(s, blcodes - 4, 4);	/* not -3 as stated in appnote.txt */
     for (rank = 0; rank < blcodes; rank++) {
         Tracev((stderr, "\nbl code %2d ", bl_order[rank]));
         send_bits(s, s->bl_tree[bl_order[rank]].Len, 3);
     }
     Tracev((stderr, "\nbl tree: sent %ld", s->bits_sent));
 
-    send_tree(s, (ct_data *)s->dyn_ltree, lcodes-1); /* literal tree */
+	send_tree(s, (ct_data *) s->dyn_ltree, lcodes - 1);	/* literal tree */
     Tracev((stderr, "\nlit tree: sent %ld", s->bits_sent));
 
-    send_tree(s, (ct_data *)s->dyn_dtree, dcodes-1); /* distance tree */
+	send_tree(s, (ct_data *) s->dyn_dtree, dcodes - 1);	/* distance tree */
     Tracev((stderr, "\ndist tree: sent %ld", s->bits_sent));
 }
 
@@ -865,14 +911,14 @@
  * Send a stored block
  */
 void _tr_stored_block(s, buf, stored_len, eof)
-    deflate_state *s;
-    charf *buf;       /* input block */
-    ulg stored_len;   /* length of input block */
-    int eof;          /* true if this is the last block for a file */
+deflate_state *s;
+charf *buf;			/* input block */
+ulg stored_len;			/* length of input block */
+int eof;			/* true if this is the last block for a file */
 {
-    send_bits(s, (STORED_BLOCK<<1)+eof, 3);  /* send block type */
+	send_bits(s, (STORED_BLOCK << 1) + eof, 3);	/* send block type */
 #ifdef DEBUG
-    s->compressed_len = (s->compressed_len + 3 + 7) & (ulg)~7L;
+	s->compressed_len = (s->compressed_len + 3 + 7) & (ulg) ~ 7L;
     s->compressed_len += (stored_len + 4) << 3;
 #endif
     copy_block(s, buf, (unsigned)stored_len, 1); /* with header */
@@ -890,9 +936,9 @@
  * on one bit only.
  */
 void _tr_align(s)
-    deflate_state *s;
+deflate_state *s;
 {
-    send_bits(s, STATIC_TREES<<1, 3);
+	send_bits(s, STATIC_TREES << 1, 3);
     send_code(s, END_BLOCK, static_ltree);
 #ifdef DEBUG
     s->compressed_len += 10L; /* 3 for block type, 7 for EOB */
@@ -904,7 +950,7 @@
      * of the EOB plus what we have just sent of the empty static block.
      */
     if (1 + s->last_eob_len + 10 - s->bi_valid < 9) {
-        send_bits(s, STATIC_TREES<<1, 3);
+		send_bits(s, STATIC_TREES << 1, 3);
         send_code(s, END_BLOCK, static_ltree);
 #ifdef DEBUG
         s->compressed_len += 10L;
@@ -919,10 +965,10 @@
  * trees or store, and output the encoded block to the zip file.
  */
 void _tr_flush_block(s, buf, stored_len, eof)
-    deflate_state *s;
-    charf *buf;       /* input block, or NULL if too old */
-    ulg stored_len;   /* length of input block */
-    int eof;          /* true if this is the last block for a file */
+deflate_state *s;
+charf *buf;			/* input block, or NULL if too old */
+ulg stored_len;			/* length of input block */
+int eof;			/* true if this is the last block for a file */
 {
     ulg opt_lenb, static_lenb; /* opt_len and static_len in bytes */
     int max_blindex = 0;  /* index of last bit length code of non zero freq */
@@ -931,14 +977,15 @@
     if (s->level > 0) {
 
 	 /* Check if the file is ascii or binary */
-	if (s->data_type == Z_UNKNOWN) set_data_type(s);
+		if (s->data_type == Z_UNKNOWN)
+			set_data_type(s);
 
 	/* Construct the literal and distance trees */
-	build_tree(s, (tree_desc *)(&(s->l_desc)));
+		build_tree(s, (tree_desc *) (&(s->l_desc)));
 	Tracev((stderr, "\nlit data: dyn %ld, stat %ld", s->opt_len,
 		s->static_len));
 
-	build_tree(s, (tree_desc *)(&(s->d_desc)));
+		build_tree(s, (tree_desc *) (&(s->d_desc)));
 	Tracev((stderr, "\ndist data: dyn %ld, stat %ld", s->opt_len,
 		s->static_len));
 	/* At this point, opt_len and static_len are the total bit lengths of
@@ -950,25 +997,27 @@
 	 */
 	max_blindex = build_bl_tree(s);
 
-	/* Determine the best encoding. Compute first the block length in bytes*/
-	opt_lenb = (s->opt_len+3+7)>>3;
-	static_lenb = (s->static_len+3+7)>>3;
-
-	Tracev((stderr, "\nopt %lu(%lu) stat %lu(%lu) stored %lu lit %u ",
-		opt_lenb, s->opt_len, static_lenb, s->static_len, stored_len,
-		s->last_lit));
+		/* Determine the best encoding. Compute first the block length in bytes */
+		opt_lenb = (s->opt_len + 3 + 7) >> 3;
+		static_lenb = (s->static_len + 3 + 7) >> 3;
+
+		Tracev((stderr,
+			"\nopt %lu(%lu) stat %lu(%lu) stored %lu lit %u ",
+			opt_lenb, s->opt_len, static_lenb, s->static_len,
+			stored_len, s->last_lit));
 
-	if (static_lenb <= opt_lenb) opt_lenb = static_lenb;
+		if (static_lenb <= opt_lenb)
+			opt_lenb = static_lenb;
 
     } else {
-        Assert(buf != (char*)0, "lost buf");
+		Assert(buf != (char *)0, "lost buf");
 	opt_lenb = static_lenb = stored_len + 5; /* force a stored block */
     }
 
 #ifdef FORCE_STORED
-    if (buf != (char*)0) { /* force stored block */
+	if (buf != (char *)0) {	/* force stored block */
 #else
-    if (stored_len+4 <= opt_lenb && buf != (char*)0) {
+	if (stored_len + 4 <= opt_lenb && buf != (char *)0) {
                        /* 4: two words for the lengths */
 #endif
         /* The test buf != NULL is only necessary if LIT_BUFSIZE > WSIZE.
@@ -984,21 +1033,23 @@
 #else
     } else if (static_lenb == opt_lenb) {
 #endif
-        send_bits(s, (STATIC_TREES<<1)+eof, 3);
-        compress_block(s, (ct_data *)static_ltree, (ct_data *)static_dtree);
+		send_bits(s, (STATIC_TREES << 1) + eof, 3);
+		compress_block(s, (ct_data *) static_ltree,
+			       (ct_data *) static_dtree);
 #ifdef DEBUG
         s->compressed_len += 3 + s->static_len;
 #endif
     } else {
-        send_bits(s, (DYN_TREES<<1)+eof, 3);
-        send_all_trees(s, s->l_desc.max_code+1, s->d_desc.max_code+1,
-                       max_blindex+1);
-        compress_block(s, (ct_data *)s->dyn_ltree, (ct_data *)s->dyn_dtree);
+		send_bits(s, (DYN_TREES << 1) + eof, 3);
+		send_all_trees(s, s->l_desc.max_code + 1,
+			       s->d_desc.max_code + 1, max_blindex + 1);
+		compress_block(s, (ct_data *) s->dyn_ltree,
+			       (ct_data *) s->dyn_dtree);
 #ifdef DEBUG
         s->compressed_len += 3 + s->opt_len;
 #endif
     }
-    Assert (s->compressed_len == s->bits_sent, "bad compressed size");
+	Assert(s->compressed_len == s->bits_sent, "bad compressed size");
     /* The above check is made mod 2^32, for files larger than 512 MB
      * and uLong implemented on 32 bits.
      */
@@ -1010,21 +1061,21 @@
         s->compressed_len += 7;  /* align on byte boundary */
 #endif
     }
-    Tracev((stderr,"\ncomprlen %lu(%lu) ", s->compressed_len>>3,
-           s->compressed_len-7*eof));
+	Tracev((stderr, "\ncomprlen %lu(%lu) ", s->compressed_len >> 3,
+		s->compressed_len - 7 * eof));
 }
 
 /* ===========================================================================
  * Save the match info and tally the frequency counts. Return true if
  * the current block must be flushed.
  */
-int _tr_tally (s, dist, lc)
-    deflate_state *s;
-    unsigned dist;  /* distance of matched string */
-    unsigned lc;    /* match length-MIN_MATCH or unmatched char (if dist==0) */
+int _tr_tally(s, dist, lc)
+deflate_state *s;
+unsigned dist;			/* distance of matched string */
+unsigned lc;			/* match length-MIN_MATCH or unmatched char (if dist==0) */
 {
-    s->d_buf[s->last_lit] = (ush)dist;
-    s->l_buf[s->last_lit++] = (uch)lc;
+	s->d_buf[s->last_lit] = (ush) dist;
+	s->l_buf[s->last_lit++] = (uch) lc;
     if (dist == 0) {
         /* lc is the unmatched char */
         s->dyn_ltree[lc].Freq++;
@@ -1032,11 +1083,12 @@
         s->matches++;
         /* Here, lc is the match length - MIN_MATCH */
         dist--;             /* dist = match distance - 1 */
-        Assert((ush)dist < (ush)MAX_DIST(s) &&
-               (ush)lc <= (ush)(MAX_MATCH-MIN_MATCH) &&
-               (ush)d_code(dist) < (ush)D_CODES,  "_tr_tally: bad match");
+		Assert((ush) dist < (ush) MAX_DIST(s) &&
+		       (ush) lc <= (ush) (MAX_MATCH - MIN_MATCH) &&
+		       (ush) d_code(dist) < (ush) D_CODES,
+		       "_tr_tally: bad match");
 
-        s->dyn_ltree[_length_code[lc]+LITERALS+1].Freq++;
+		s->dyn_ltree[_length_code[lc] + LITERALS + 1].Freq++;
         s->dyn_dtree[d_code(dist)].Freq++;
     }
 
@@ -1044,21 +1096,22 @@
     /* Try to guess if it is profitable to stop the current block here */
     if ((s->last_lit & 0x1fff) == 0 && s->level > 2) {
         /* Compute an upper bound for the compressed length */
-        ulg out_length = (ulg)s->last_lit*8L;
-        ulg in_length = (ulg)((long)s->strstart - s->block_start);
+		ulg out_length = (ulg) s->last_lit * 8L;
+		ulg in_length = (ulg) ((long)s->strstart - s->block_start);
         int dcode;
         for (dcode = 0; dcode < D_CODES; dcode++) {
-            out_length += (ulg)s->dyn_dtree[dcode].Freq *
-                (5L+extra_dbits[dcode]);
+			out_length += (ulg) s->dyn_dtree[dcode].Freq *
+			    (5L + extra_dbits[dcode]);
         }
         out_length >>= 3;
-        Tracev((stderr,"\nlast_lit %u, in %ld, out ~%ld(%ld%%) ",
+		Tracev((stderr, "\nlast_lit %u, in %ld, out ~%ld(%ld%%) ",
                s->last_lit, in_length, out_length,
-               100L - out_length*100L/in_length));
-        if (s->matches < s->last_lit/2 && out_length < in_length/2) return 1;
+			100L - out_length * 100L / in_length));
+		if (s->matches < s->last_lit / 2 && out_length < in_length / 2)
+			return 1;
     }
 #endif
-    return (s->last_lit == s->lit_bufsize-1);
+	return (s->last_lit == s->lit_bufsize - 1);
     /* We avoid equality with lit_bufsize because of wraparound at 64K
      * on 16 bit machines and because stored blocks are restricted to
      * 64K-1 bytes.
@@ -1069,9 +1122,9 @@
  * Send the block data compressed using the given Huffman trees
  */
 local void compress_block(s, ltree, dtree)
-    deflate_state *s;
-    ct_data *ltree; /* literal tree */
-    ct_data *dtree; /* distance tree */
+deflate_state *s;
+ct_data *ltree;			/* literal tree */
+ct_data *dtree;			/* distance tree */
 {
     unsigned dist;      /* distance of matched string */
     int lc;             /* match length or unmatched char (if dist == 0) */
@@ -1079,16 +1132,17 @@
     unsigned code;      /* the code to send */
     int extra;          /* number of extra bits to send */
 
-    if (s->last_lit != 0) do {
+	if (s->last_lit != 0)
+		do {
         dist = s->d_buf[lx];
         lc = s->l_buf[lx++];
         if (dist == 0) {
             send_code(s, lc, ltree); /* send a literal byte */
-            Tracecv(isgraph(lc), (stderr," '%c' ", lc));
+				Tracecv(isgraph(lc), (stderr, " '%c' ", lc));
         } else {
             /* Here, lc is the match length - MIN_MATCH */
             code = _length_code[lc];
-            send_code(s, code+LITERALS+1, ltree); /* send the length code */
+				send_code(s, code + LITERALS + 1, ltree);	/* send the length code */
             extra = extra_lbits[code];
             if (extra != 0) {
                 lc -= base_length[code];
@@ -1096,7 +1150,7 @@
             }
             dist--; /* dist is now the match distance - 1 */
             code = d_code(dist);
-            Assert (code < D_CODES, "bad d_code");
+				Assert(code < D_CODES, "bad d_code");
 
             send_code(s, code, dtree);       /* send the distance code */
             extra = extra_dbits[code];
@@ -1107,7 +1161,8 @@
         } /* literal or match pair ? */
 
         /* Check that the overlay between pending_buf and d_buf+l_buf is ok: */
-        Assert(s->pending < s->lit_bufsize + 2*lx, "pendingBuf overflow");
+			Assert(s->pending < s->lit_bufsize + 2 * lx,
+			       "pendingBuf overflow");
 
     } while (lx < s->last_lit);
 
@@ -1122,15 +1177,19 @@
  * frequencies does not exceed 64K (to fit in an int on 16 bit machines).
  */
 local void set_data_type(s)
-    deflate_state *s;
+deflate_state *s;
 {
     int n = 0;
     unsigned ascii_freq = 0;
     unsigned bin_freq = 0;
-    while (n < 7)        bin_freq += s->dyn_ltree[n++].Freq;
-    while (n < 128)    ascii_freq += s->dyn_ltree[n++].Freq;
-    while (n < LITERALS) bin_freq += s->dyn_ltree[n++].Freq;
-    s->data_type = (Byte)(bin_freq > (ascii_freq >> 2) ? Z_BINARY : Z_ASCII);
+	while (n < 7)
+		bin_freq += s->dyn_ltree[n++].Freq;
+	while (n < 128)
+		ascii_freq += s->dyn_ltree[n++].Freq;
+	while (n < LITERALS)
+		bin_freq += s->dyn_ltree[n++].Freq;
+	s->data_type =
+	    (Byte) (bin_freq > (ascii_freq >> 2) ? Z_BINARY : Z_ASCII);
 }
 
 /* ===========================================================================
@@ -1139,8 +1198,8 @@
  * IN assertion: 1 <= len <= 15
  */
 local unsigned bi_reverse(code, len)
-    unsigned code; /* the value to invert */
-    int len;       /* its bit length */
+unsigned code;			/* the value to invert */
+int len;			/* its bit length */
 {
     register unsigned res = 0;
     do {
@@ -1154,14 +1213,14 @@
  * Flush the bit buffer, keeping at most 7 bits in it.
  */
 local void bi_flush(s)
-    deflate_state *s;
+deflate_state *s;
 {
     if (s->bi_valid == 16) {
         put_short(s, s->bi_buf);
         s->bi_buf = 0;
         s->bi_valid = 0;
     } else if (s->bi_valid >= 8) {
-        put_byte(s, (Byte)s->bi_buf);
+		put_byte(s, (Byte) s->bi_buf);
         s->bi_buf >>= 8;
         s->bi_valid -= 8;
     }
@@ -1171,17 +1230,17 @@
  * Flush the bit buffer and align the output on a byte boundary
  */
 local void bi_windup(s)
-    deflate_state *s;
+deflate_state *s;
 {
     if (s->bi_valid > 8) {
         put_short(s, s->bi_buf);
     } else if (s->bi_valid > 0) {
-        put_byte(s, (Byte)s->bi_buf);
+		put_byte(s, (Byte) s->bi_buf);
     }
     s->bi_buf = 0;
     s->bi_valid = 0;
 #ifdef DEBUG
-    s->bits_sent = (s->bits_sent+7) & ~7;
+	s->bits_sent = (s->bits_sent + 7) & ~7;
 #endif
 }
 
@@ -1190,23 +1249,23 @@
  * one's complement if requested.
  */
 local void copy_block(s, buf, len, header)
-    deflate_state *s;
-    charf    *buf;    /* the input data */
-    unsigned len;     /* its length */
-    int      header;  /* true if block header must be written */
+deflate_state *s;
+charf *buf;			/* the input data */
+unsigned len;			/* its length */
+int header;			/* true if block header must be written */
 {
     bi_windup(s);        /* align on byte boundary */
     s->last_eob_len = 8; /* enough lookahead for inflate */
 
     if (header) {
-        put_short(s, (ush)len);   
-        put_short(s, (ush)~len);
+		put_short(s, (ush) len);
+		put_short(s, (ush) ~ len);
 #ifdef DEBUG
-        s->bits_sent += 2*16;
+		s->bits_sent += 2 * 16;
 #endif
     }
 #ifdef DEBUG
-    s->bits_sent += (ulg)len<<3;
+	s->bits_sent += (ulg) len << 3;
 #endif
     while (len--) {
         put_byte(s, *buf++);
--- zlib-1.1.3/trees.h	1998-02-24 07:14:55.000000000 -0500
+++ zlib-1.1.3/trees.h	2014-02-07 11:53:21.352326892 -0500
@@ -1,123 +1,157 @@
 /* header created automatically with -DGEN_TREES_H */
 
-local const ct_data static_ltree[L_CODES+2] = {
-{{ 12},{  8}}, {{140},{  8}}, {{ 76},{  8}}, {{204},{  8}}, {{ 44},{  8}},
-{{172},{  8}}, {{108},{  8}}, {{236},{  8}}, {{ 28},{  8}}, {{156},{  8}},
-{{ 92},{  8}}, {{220},{  8}}, {{ 60},{  8}}, {{188},{  8}}, {{124},{  8}},
-{{252},{  8}}, {{  2},{  8}}, {{130},{  8}}, {{ 66},{  8}}, {{194},{  8}},
-{{ 34},{  8}}, {{162},{  8}}, {{ 98},{  8}}, {{226},{  8}}, {{ 18},{  8}},
-{{146},{  8}}, {{ 82},{  8}}, {{210},{  8}}, {{ 50},{  8}}, {{178},{  8}},
-{{114},{  8}}, {{242},{  8}}, {{ 10},{  8}}, {{138},{  8}}, {{ 74},{  8}},
-{{202},{  8}}, {{ 42},{  8}}, {{170},{  8}}, {{106},{  8}}, {{234},{  8}},
-{{ 26},{  8}}, {{154},{  8}}, {{ 90},{  8}}, {{218},{  8}}, {{ 58},{  8}},
-{{186},{  8}}, {{122},{  8}}, {{250},{  8}}, {{  6},{  8}}, {{134},{  8}},
-{{ 70},{  8}}, {{198},{  8}}, {{ 38},{  8}}, {{166},{  8}}, {{102},{  8}},
-{{230},{  8}}, {{ 22},{  8}}, {{150},{  8}}, {{ 86},{  8}}, {{214},{  8}},
-{{ 54},{  8}}, {{182},{  8}}, {{118},{  8}}, {{246},{  8}}, {{ 14},{  8}},
-{{142},{  8}}, {{ 78},{  8}}, {{206},{  8}}, {{ 46},{  8}}, {{174},{  8}},
-{{110},{  8}}, {{238},{  8}}, {{ 30},{  8}}, {{158},{  8}}, {{ 94},{  8}},
-{{222},{  8}}, {{ 62},{  8}}, {{190},{  8}}, {{126},{  8}}, {{254},{  8}},
-{{  1},{  8}}, {{129},{  8}}, {{ 65},{  8}}, {{193},{  8}}, {{ 33},{  8}},
-{{161},{  8}}, {{ 97},{  8}}, {{225},{  8}}, {{ 17},{  8}}, {{145},{  8}},
-{{ 81},{  8}}, {{209},{  8}}, {{ 49},{  8}}, {{177},{  8}}, {{113},{  8}},
-{{241},{  8}}, {{  9},{  8}}, {{137},{  8}}, {{ 73},{  8}}, {{201},{  8}},
-{{ 41},{  8}}, {{169},{  8}}, {{105},{  8}}, {{233},{  8}}, {{ 25},{  8}},
-{{153},{  8}}, {{ 89},{  8}}, {{217},{  8}}, {{ 57},{  8}}, {{185},{  8}},
-{{121},{  8}}, {{249},{  8}}, {{  5},{  8}}, {{133},{  8}}, {{ 69},{  8}},
-{{197},{  8}}, {{ 37},{  8}}, {{165},{  8}}, {{101},{  8}}, {{229},{  8}},
-{{ 21},{  8}}, {{149},{  8}}, {{ 85},{  8}}, {{213},{  8}}, {{ 53},{  8}},
-{{181},{  8}}, {{117},{  8}}, {{245},{  8}}, {{ 13},{  8}}, {{141},{  8}},
-{{ 77},{  8}}, {{205},{  8}}, {{ 45},{  8}}, {{173},{  8}}, {{109},{  8}},
-{{237},{  8}}, {{ 29},{  8}}, {{157},{  8}}, {{ 93},{  8}}, {{221},{  8}},
-{{ 61},{  8}}, {{189},{  8}}, {{125},{  8}}, {{253},{  8}}, {{ 19},{  9}},
-{{275},{  9}}, {{147},{  9}}, {{403},{  9}}, {{ 83},{  9}}, {{339},{  9}},
-{{211},{  9}}, {{467},{  9}}, {{ 51},{  9}}, {{307},{  9}}, {{179},{  9}},
-{{435},{  9}}, {{115},{  9}}, {{371},{  9}}, {{243},{  9}}, {{499},{  9}},
-{{ 11},{  9}}, {{267},{  9}}, {{139},{  9}}, {{395},{  9}}, {{ 75},{  9}},
-{{331},{  9}}, {{203},{  9}}, {{459},{  9}}, {{ 43},{  9}}, {{299},{  9}},
-{{171},{  9}}, {{427},{  9}}, {{107},{  9}}, {{363},{  9}}, {{235},{  9}},
-{{491},{  9}}, {{ 27},{  9}}, {{283},{  9}}, {{155},{  9}}, {{411},{  9}},
-{{ 91},{  9}}, {{347},{  9}}, {{219},{  9}}, {{475},{  9}}, {{ 59},{  9}},
-{{315},{  9}}, {{187},{  9}}, {{443},{  9}}, {{123},{  9}}, {{379},{  9}},
-{{251},{  9}}, {{507},{  9}}, {{  7},{  9}}, {{263},{  9}}, {{135},{  9}},
-{{391},{  9}}, {{ 71},{  9}}, {{327},{  9}}, {{199},{  9}}, {{455},{  9}},
-{{ 39},{  9}}, {{295},{  9}}, {{167},{  9}}, {{423},{  9}}, {{103},{  9}},
-{{359},{  9}}, {{231},{  9}}, {{487},{  9}}, {{ 23},{  9}}, {{279},{  9}},
-{{151},{  9}}, {{407},{  9}}, {{ 87},{  9}}, {{343},{  9}}, {{215},{  9}},
-{{471},{  9}}, {{ 55},{  9}}, {{311},{  9}}, {{183},{  9}}, {{439},{  9}},
-{{119},{  9}}, {{375},{  9}}, {{247},{  9}}, {{503},{  9}}, {{ 15},{  9}},
-{{271},{  9}}, {{143},{  9}}, {{399},{  9}}, {{ 79},{  9}}, {{335},{  9}},
-{{207},{  9}}, {{463},{  9}}, {{ 47},{  9}}, {{303},{  9}}, {{175},{  9}},
-{{431},{  9}}, {{111},{  9}}, {{367},{  9}}, {{239},{  9}}, {{495},{  9}},
-{{ 31},{  9}}, {{287},{  9}}, {{159},{  9}}, {{415},{  9}}, {{ 95},{  9}},
-{{351},{  9}}, {{223},{  9}}, {{479},{  9}}, {{ 63},{  9}}, {{319},{  9}},
-{{191},{  9}}, {{447},{  9}}, {{127},{  9}}, {{383},{  9}}, {{255},{  9}},
-{{511},{  9}}, {{  0},{  7}}, {{ 64},{  7}}, {{ 32},{  7}}, {{ 96},{  7}},
-{{ 16},{  7}}, {{ 80},{  7}}, {{ 48},{  7}}, {{112},{  7}}, {{  8},{  7}},
-{{ 72},{  7}}, {{ 40},{  7}}, {{104},{  7}}, {{ 24},{  7}}, {{ 88},{  7}},
-{{ 56},{  7}}, {{120},{  7}}, {{  4},{  7}}, {{ 68},{  7}}, {{ 36},{  7}},
-{{100},{  7}}, {{ 20},{  7}}, {{ 84},{  7}}, {{ 52},{  7}}, {{116},{  7}},
-{{  3},{  8}}, {{131},{  8}}, {{ 67},{  8}}, {{195},{  8}}, {{ 35},{  8}},
-{{163},{  8}}, {{ 99},{  8}}, {{227},{  8}}
+local const ct_data static_ltree[L_CODES + 2] = {
+	{{12}, {8}}, {{140}, {8}}, {{76}, {8}}, {{204}, {8}}, {{44}, {8}},
+	{{172}, {8}}, {{108}, {8}}, {{236}, {8}}, {{28}, {8}}, {{156}, {8}},
+	{{92}, {8}}, {{220}, {8}}, {{60}, {8}}, {{188}, {8}}, {{124}, {8}},
+	{{252}, {8}}, {{2}, {8}}, {{130}, {8}}, {{66}, {8}}, {{194}, {8}},
+	{{34}, {8}}, {{162}, {8}}, {{98}, {8}}, {{226}, {8}}, {{18}, {8}},
+	{{146}, {8}}, {{82}, {8}}, {{210}, {8}}, {{50}, {8}}, {{178}, {8}},
+	{{114}, {8}}, {{242}, {8}}, {{10}, {8}}, {{138}, {8}}, {{74}, {8}},
+	{{202}, {8}}, {{42}, {8}}, {{170}, {8}}, {{106}, {8}}, {{234}, {8}},
+	{{26}, {8}}, {{154}, {8}}, {{90}, {8}}, {{218}, {8}}, {{58}, {8}},
+	{{186}, {8}}, {{122}, {8}}, {{250}, {8}}, {{6}, {8}}, {{134}, {8}},
+	{{70}, {8}}, {{198}, {8}}, {{38}, {8}}, {{166}, {8}}, {{102}, {8}},
+	{{230}, {8}}, {{22}, {8}}, {{150}, {8}}, {{86}, {8}}, {{214}, {8}},
+	{{54}, {8}}, {{182}, {8}}, {{118}, {8}}, {{246}, {8}}, {{14}, {8}},
+	{{142}, {8}}, {{78}, {8}}, {{206}, {8}}, {{46}, {8}}, {{174}, {8}},
+	{{110}, {8}}, {{238}, {8}}, {{30}, {8}}, {{158}, {8}}, {{94}, {8}},
+	{{222}, {8}}, {{62}, {8}}, {{190}, {8}}, {{126}, {8}}, {{254}, {8}},
+	{{1}, {8}}, {{129}, {8}}, {{65}, {8}}, {{193}, {8}}, {{33}, {8}},
+	{{161}, {8}}, {{97}, {8}}, {{225}, {8}}, {{17}, {8}}, {{145}, {8}},
+	{{81}, {8}}, {{209}, {8}}, {{49}, {8}}, {{177}, {8}}, {{113}, {8}},
+	{{241}, {8}}, {{9}, {8}}, {{137}, {8}}, {{73}, {8}}, {{201}, {8}},
+	{{41}, {8}}, {{169}, {8}}, {{105}, {8}}, {{233}, {8}}, {{25}, {8}},
+	{{153}, {8}}, {{89}, {8}}, {{217}, {8}}, {{57}, {8}}, {{185}, {8}},
+	{{121}, {8}}, {{249}, {8}}, {{5}, {8}}, {{133}, {8}}, {{69}, {8}},
+	{{197}, {8}}, {{37}, {8}}, {{165}, {8}}, {{101}, {8}}, {{229}, {8}},
+	{{21}, {8}}, {{149}, {8}}, {{85}, {8}}, {{213}, {8}}, {{53}, {8}},
+	{{181}, {8}}, {{117}, {8}}, {{245}, {8}}, {{13}, {8}}, {{141}, {8}},
+	{{77}, {8}}, {{205}, {8}}, {{45}, {8}}, {{173}, {8}}, {{109}, {8}},
+	{{237}, {8}}, {{29}, {8}}, {{157}, {8}}, {{93}, {8}}, {{221}, {8}},
+	{{61}, {8}}, {{189}, {8}}, {{125}, {8}}, {{253}, {8}}, {{19}, {9}},
+	{{275}, {9}}, {{147}, {9}}, {{403}, {9}}, {{83}, {9}}, {{339}, {9}},
+	{{211}, {9}}, {{467}, {9}}, {{51}, {9}}, {{307}, {9}}, {{179}, {9}},
+	{{435}, {9}}, {{115}, {9}}, {{371}, {9}}, {{243}, {9}}, {{499}, {9}},
+	{{11}, {9}}, {{267}, {9}}, {{139}, {9}}, {{395}, {9}}, {{75}, {9}},
+	{{331}, {9}}, {{203}, {9}}, {{459}, {9}}, {{43}, {9}}, {{299}, {9}},
+	{{171}, {9}}, {{427}, {9}}, {{107}, {9}}, {{363}, {9}}, {{235}, {9}},
+	{{491}, {9}}, {{27}, {9}}, {{283}, {9}}, {{155}, {9}}, {{411}, {9}},
+	{{91}, {9}}, {{347}, {9}}, {{219}, {9}}, {{475}, {9}}, {{59}, {9}},
+	{{315}, {9}}, {{187}, {9}}, {{443}, {9}}, {{123}, {9}}, {{379}, {9}},
+	{{251}, {9}}, {{507}, {9}}, {{7}, {9}}, {{263}, {9}}, {{135}, {9}},
+	{{391}, {9}}, {{71}, {9}}, {{327}, {9}}, {{199}, {9}}, {{455}, {9}},
+	{{39}, {9}}, {{295}, {9}}, {{167}, {9}}, {{423}, {9}}, {{103}, {9}},
+	{{359}, {9}}, {{231}, {9}}, {{487}, {9}}, {{23}, {9}}, {{279}, {9}},
+	{{151}, {9}}, {{407}, {9}}, {{87}, {9}}, {{343}, {9}}, {{215}, {9}},
+	{{471}, {9}}, {{55}, {9}}, {{311}, {9}}, {{183}, {9}}, {{439}, {9}},
+	{{119}, {9}}, {{375}, {9}}, {{247}, {9}}, {{503}, {9}}, {{15}, {9}},
+	{{271}, {9}}, {{143}, {9}}, {{399}, {9}}, {{79}, {9}}, {{335}, {9}},
+	{{207}, {9}}, {{463}, {9}}, {{47}, {9}}, {{303}, {9}}, {{175}, {9}},
+	{{431}, {9}}, {{111}, {9}}, {{367}, {9}}, {{239}, {9}}, {{495}, {9}},
+	{{31}, {9}}, {{287}, {9}}, {{159}, {9}}, {{415}, {9}}, {{95}, {9}},
+	{{351}, {9}}, {{223}, {9}}, {{479}, {9}}, {{63}, {9}}, {{319}, {9}},
+	{{191}, {9}}, {{447}, {9}}, {{127}, {9}}, {{383}, {9}}, {{255}, {9}},
+	{{511}, {9}}, {{0}, {7}}, {{64}, {7}}, {{32}, {7}}, {{96}, {7}},
+	{{16}, {7}}, {{80}, {7}}, {{48}, {7}}, {{112}, {7}}, {{8}, {7}},
+	{{72}, {7}}, {{40}, {7}}, {{104}, {7}}, {{24}, {7}}, {{88}, {7}},
+	{{56}, {7}}, {{120}, {7}}, {{4}, {7}}, {{68}, {7}}, {{36}, {7}},
+	{{100}, {7}}, {{20}, {7}}, {{84}, {7}}, {{52}, {7}}, {{116}, {7}},
+	{{3}, {8}}, {{131}, {8}}, {{67}, {8}}, {{195}, {8}}, {{35}, {8}},
+	{{163}, {8}}, {{99}, {8}}, {{227}, {8}}
 };
 
 local const ct_data static_dtree[D_CODES] = {
-{{ 0},{ 5}}, {{16},{ 5}}, {{ 8},{ 5}}, {{24},{ 5}}, {{ 4},{ 5}},
-{{20},{ 5}}, {{12},{ 5}}, {{28},{ 5}}, {{ 2},{ 5}}, {{18},{ 5}},
-{{10},{ 5}}, {{26},{ 5}}, {{ 6},{ 5}}, {{22},{ 5}}, {{14},{ 5}},
-{{30},{ 5}}, {{ 1},{ 5}}, {{17},{ 5}}, {{ 9},{ 5}}, {{25},{ 5}},
-{{ 5},{ 5}}, {{21},{ 5}}, {{13},{ 5}}, {{29},{ 5}}, {{ 3},{ 5}},
-{{19},{ 5}}, {{11},{ 5}}, {{27},{ 5}}, {{ 7},{ 5}}, {{23},{ 5}}
+	{{0}, {5}}, {{16}, {5}}, {{8}, {5}}, {{24}, {5}}, {{4}, {5}},
+	{{20}, {5}}, {{12}, {5}}, {{28}, {5}}, {{2}, {5}}, {{18}, {5}},
+	{{10}, {5}}, {{26}, {5}}, {{6}, {5}}, {{22}, {5}}, {{14}, {5}},
+	{{30}, {5}}, {{1}, {5}}, {{17}, {5}}, {{9}, {5}}, {{25}, {5}},
+	{{5}, {5}}, {{21}, {5}}, {{13}, {5}}, {{29}, {5}}, {{3}, {5}},
+	{{19}, {5}}, {{11}, {5}}, {{27}, {5}}, {{7}, {5}}, {{23}, {5}}
 };
 
 const uch _dist_code[DIST_CODE_LEN] = {
  0,  1,  2,  3,  4,  4,  5,  5,  6,  6,  6,  6,  7,  7,  7,  7,  8,  8,  8,  8,
  8,  8,  8,  8,  9,  9,  9,  9,  9,  9,  9,  9, 10, 10, 10, 10, 10, 10, 10, 10,
-10, 10, 10, 10, 10, 10, 10, 10, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11,
-11, 11, 11, 11, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12,
-12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 13, 13, 13, 13,
-13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,
-13, 13, 13, 13, 13, 13, 13, 13, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,
-14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,
-14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,
-14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 15, 15, 15, 15, 15, 15, 15, 15,
-15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,
-15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,
-15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,  0,  0, 16, 17,
-18, 18, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 22, 22, 22, 22, 22, 22, 22, 22,
-23, 23, 23, 23, 23, 23, 23, 23, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
-24, 24, 24, 24, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25,
-26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26,
-26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 27, 27, 27, 27, 27, 27, 27, 27,
-27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27,
-27, 27, 27, 27, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28,
-28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28,
-28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28,
-28, 28, 28, 28, 28, 28, 28, 28, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
-29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
-29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
-29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29
+	10, 10, 10, 10, 10, 10, 10, 10, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11,
+	11, 11,
+	11, 11, 11, 11, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12,
+	12, 12,
+	12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 13, 13,
+	13, 13,
+	13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,
+	13, 13,
+	13, 13, 13, 13, 13, 13, 13, 13, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,
+	14, 14,
+	14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,
+	14, 14,
+	14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,
+	14, 14,
+	14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 15, 15, 15, 15, 15, 15,
+	15, 15,
+	15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,
+	15, 15,
+	15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,
+	15, 15,
+	15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 0, 0,
+	16, 17,
+	18, 18, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 22, 22, 22, 22, 22, 22,
+	22, 22,
+	23, 23, 23, 23, 23, 23, 23, 23, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
+	24, 24,
+	24, 24, 24, 24, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25,
+	25, 25,
+	26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26,
+	26, 26,
+	26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 27, 27, 27, 27, 27, 27,
+	27, 27,
+	27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27,
+	27, 27,
+	27, 27, 27, 27, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28,
+	28, 28,
+	28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28,
+	28, 28,
+	28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28,
+	28, 28,
+	28, 28, 28, 28, 28, 28, 28, 28, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
+	29, 29,
+	29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
+	29, 29,
+	29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
+	29, 29,
+	29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29
 };
 
-const uch _length_code[MAX_MATCH-MIN_MATCH+1]= {
+const uch _length_code[MAX_MATCH - MIN_MATCH + 1] = {
  0,  1,  2,  3,  4,  5,  6,  7,  8,  8,  9,  9, 10, 10, 11, 11, 12, 12, 12, 12,
-13, 13, 13, 13, 14, 14, 14, 14, 15, 15, 15, 15, 16, 16, 16, 16, 16, 16, 16, 16,
-17, 17, 17, 17, 17, 17, 17, 17, 18, 18, 18, 18, 18, 18, 18, 18, 19, 19, 19, 19,
-19, 19, 19, 19, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20,
-21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 22, 22, 22, 22,
-22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 23, 23, 23, 23, 23, 23, 23, 23,
-23, 23, 23, 23, 23, 23, 23, 23, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
-24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
-25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25,
-25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 26, 26, 26, 26, 26, 26, 26, 26,
-26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26,
-26, 26, 26, 26, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27,
-27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 28
+	13, 13, 13, 13, 14, 14, 14, 14, 15, 15, 15, 15, 16, 16, 16, 16, 16, 16,
+	16, 16,
+	17, 17, 17, 17, 17, 17, 17, 17, 18, 18, 18, 18, 18, 18, 18, 18, 19, 19,
+	19, 19,
+	19, 19, 19, 19, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20,
+	20, 20,
+	21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 22, 22,
+	22, 22,
+	22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 23, 23, 23, 23, 23, 23,
+	23, 23,
+	23, 23, 23, 23, 23, 23, 23, 23, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
+	24, 24,
+	24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
+	24, 24,
+	25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25,
+	25, 25,
+	25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 26, 26, 26, 26, 26, 26,
+	26, 26,
+	26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26,
+	26, 26,
+	26, 26, 26, 26, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27,
+	27, 27,
+	27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 28
 };
 
 local const int base_length[LENGTH_CODES] = {
-0, 1, 2, 3, 4, 5, 6, 7, 8, 10, 12, 14, 16, 20, 24, 28, 32, 40, 48, 56,
-64, 80, 96, 112, 128, 160, 192, 224, 0
+	0, 1, 2, 3, 4, 5, 6, 7, 8, 10, 12, 14, 16, 20, 24, 28, 32, 40, 48, 56,
+	64, 80, 96, 112, 128, 160, 192, 224, 0
 };
 
 local const int base_dist[D_CODES] = {
--- zlib-1.1.3/uncompr.c	1998-02-02 09:12:37.000000000 -0500
+++ zlib-1.1.3/uncompr.c	2014-02-07 11:53:21.352326892 -0500
@@ -3,7 +3,7 @@
  * For conditions of distribution and use, see copyright notice in zlib.h 
  */
 
-/* @(#) $Id$ */
+/* @(#) $Id: uncompr.c,v 1.1 2001/11/09 01:48:02 mpl Exp $ */
 
 #include "zlib.h"
 
@@ -22,29 +22,32 @@
    enough memory, Z_BUF_ERROR if there was not enough room in the output
    buffer, or Z_DATA_ERROR if the input data was corrupted.
 */
-int ZEXPORT uncompress (dest, destLen, source, sourceLen)
-    Bytef *dest;
-    uLongf *destLen;
-    const Bytef *source;
-    uLong sourceLen;
+int ZEXPORT uncompress(dest, destLen, source, sourceLen)
+Bytef *dest;
+uLongf *destLen;
+const Bytef *source;
+uLong sourceLen;
 {
     z_stream stream;
     int err;
 
-    stream.next_in = (Bytef*)source;
-    stream.avail_in = (uInt)sourceLen;
+	stream.next_in = (Bytef *) source;
+	stream.avail_in = (uInt) sourceLen;
     /* Check for source > 64K on 16-bit machine: */
-    if ((uLong)stream.avail_in != sourceLen) return Z_BUF_ERROR;
+	if ((uLong) stream.avail_in != sourceLen)
+		return Z_BUF_ERROR;
 
     stream.next_out = dest;
-    stream.avail_out = (uInt)*destLen;
-    if ((uLong)stream.avail_out != *destLen) return Z_BUF_ERROR;
+	stream.avail_out = (uInt) * destLen;
+	if ((uLong) stream.avail_out != *destLen)
+		return Z_BUF_ERROR;
 
-    stream.zalloc = (alloc_func)0;
-    stream.zfree = (free_func)0;
+	stream.zalloc = (alloc_func) 0;
+	stream.zfree = (free_func) 0;
 
     err = inflateInit(&stream);
-    if (err != Z_OK) return err;
+	if (err != Z_OK)
+		return err;
 
     err = inflate(&stream, Z_FINISH);
     if (err != Z_STREAM_END) {
--- zlib-1.1.3/zutil.c	1998-07-08 13:01:47.000000000 -0400
+++ zlib-1.1.3/zutil.c	2014-02-07 11:53:21.352326892 -0500
@@ -3,43 +3,45 @@
  * For conditions of distribution and use, see copyright notice in zlib.h 
  */
 
-/* @(#) $Id$ */
+/* @(#) $Id: zutil.c,v 1.1 2001/11/09 01:48:02 mpl Exp $ */
 
 #include "zutil.h"
 
-struct internal_state      {int dummy;}; /* for buggy compilers */
+struct internal_state {
+	int dummy;
+};				/* for buggy compilers */
 
 #ifndef STDC
 extern void exit OF((int));
 #endif
 
 const char *z_errmsg[10] = {
-"need dictionary",     /* Z_NEED_DICT       2  */
-"stream end",          /* Z_STREAM_END      1  */
-"",                    /* Z_OK              0  */
-"file error",          /* Z_ERRNO         (-1) */
-"stream error",        /* Z_STREAM_ERROR  (-2) */
-"data error",          /* Z_DATA_ERROR    (-3) */
-"insufficient memory", /* Z_MEM_ERROR     (-4) */
-"buffer error",        /* Z_BUF_ERROR     (-5) */
-"incompatible version",/* Z_VERSION_ERROR (-6) */
-""};
+	"need dictionary",	/* Z_NEED_DICT       2  */
+	"stream end",		/* Z_STREAM_END      1  */
+	"",			/* Z_OK              0  */
+	"file error",		/* Z_ERRNO         (-1) */
+	"stream error",		/* Z_STREAM_ERROR  (-2) */
+	"data error",		/* Z_DATA_ERROR    (-3) */
+	"insufficient memory",	/* Z_MEM_ERROR     (-4) */
+	"buffer error",		/* Z_BUF_ERROR     (-5) */
+	"incompatible version",	/* Z_VERSION_ERROR (-6) */
+	""
+};
 
-
-const char * ZEXPORT zlibVersion()
+const char *ZEXPORT zlibVersion()
 {
     return ZLIB_VERSION;
 }
 
 #ifdef DEBUG
 
-#  ifndef verbose
-#    define verbose 0
-#  endif
+#ifndef verbose
+#define verbose 0
+#endif
 int z_verbose = verbose;
 
-void z_error (m)
-    char *m;
+void z_error(m)
+char *m;
 {
     fprintf(stderr, "%s\n", m);
     exit(1);
@@ -49,8 +51,8 @@
 /* exported to allow conversion of error code to string for compress() and
  * uncompress()
  */
-const char * ZEXPORT zError(err)
-    int err;
+const char *ZEXPORT zError(err)
+int err;
 {
     return ERR_MSG(err);
 }
@@ -59,34 +60,37 @@
 #ifndef HAVE_MEMCPY
 
 void zmemcpy(dest, source, len)
-    Bytef* dest;
-    const Bytef* source;
-    uInt  len;
+Bytef *dest;
+const Bytef *source;
+uInt len;
 {
-    if (len == 0) return;
+	if (len == 0)
+		return;
     do {
         *dest++ = *source++; /* ??? to be unrolled */
     } while (--len != 0);
 }
 
 int zmemcmp(s1, s2, len)
-    const Bytef* s1;
-    const Bytef* s2;
-    uInt  len;
+const Bytef *s1;
+const Bytef *s2;
+uInt len;
 {
     uInt j;
 
     for (j = 0; j < len; j++) {
-        if (s1[j] != s2[j]) return 2*(s1[j] > s2[j])-1;
+		if (s1[j] != s2[j])
+			return 2 * (s1[j] > s2[j]) - 1;
     }
     return 0;
 }
 
 void zmemzero(dest, len)
-    Bytef* dest;
-    uInt  len;
+Bytef *dest;
+uInt len;
 {
-    if (len == 0) return;
+	if (len == 0)
+		return;
     do {
         *dest++ = 0;  /* ??? to be unrolled */
     } while (--len != 0);
@@ -98,7 +102,7 @@
 /* Small and medium model in Turbo C are for now limited to near allocation
  * with reduced MAX_WBITS and MAX_MEM_LEVEL
  */
-#  define MY_ZCALLOC
+#define MY_ZCALLOC
 
 /* Turbo C malloc() does not allow dynamic allocation of 64K bytes
  * and farmalloc(64K) returns a pointer with an offset of 8, so we
@@ -124,44 +128,47 @@
  * a protected system like OS/2. Use Microsoft C instead.
  */
 
-voidpf zcalloc (voidpf opaque, unsigned items, unsigned size)
+voidpf zcalloc(voidpf opaque, unsigned items, unsigned size)
 {
     voidpf buf = opaque; /* just to make some compilers happy */
-    ulg bsize = (ulg)items*size;
+	ulg bsize = (ulg) items * size;
 
     /* If we allocate less than 65520 bytes, we assume that farmalloc
      * will return a usable pointer which doesn't have to be normalized.
      */
     if (bsize < 65520L) {
         buf = farmalloc(bsize);
-        if (*(ush*)&buf != 0) return buf;
+		if (*(ush *) & buf != 0)
+			return buf;
     } else {
         buf = farmalloc(bsize + 16L);
     }
-    if (buf == NULL || next_ptr >= MAX_PTR) return NULL;
+	if (buf == NULL || next_ptr >= MAX_PTR)
+		return NULL;
     table[next_ptr].org_ptr = buf;
 
     /* Normalize the pointer to seg:0 */
-    *((ush*)&buf+1) += ((ush)((uch*)buf-0) + 15) >> 4;
-    *(ush*)&buf = 0;
+	*((ush *) & buf + 1) += ((ush) ((uch *) buf - 0) + 15) >> 4;
+	*(ush *) & buf = 0;
     table[next_ptr++].new_ptr = buf;
     return buf;
 }
 
-void  zcfree (voidpf opaque, voidpf ptr)
+void zcfree(voidpf opaque, voidpf ptr)
 {
     int n;
-    if (*(ush*)&ptr != 0) { /* object < 64K */
+	if (*(ush *) & ptr != 0) {	/* object < 64K */
         farfree(ptr);
         return;
     }
     /* Find the original pointer */
     for (n = 0; n < next_ptr; n++) {
-        if (ptr != table[n].new_ptr) continue;
+		if (ptr != table[n].new_ptr)
+			continue;
 
         farfree(table[n].org_ptr);
         while (++n < next_ptr) {
-            table[n-1] = table[n];
+			table[n - 1] = table[n];
         }
         next_ptr--;
         return;
@@ -176,22 +182,24 @@
 #if defined(M_I86) && !defined(__32BIT__)
 /* Microsoft C in 16-bit mode */
 
-#  define MY_ZCALLOC
+#define MY_ZCALLOC
 
 #if (!defined(_MSC_VER) || (_MSC_VER <= 600))
-#  define _halloc  halloc
-#  define _hfree   hfree
+#define _halloc  halloc
+#define _hfree   hfree
 #endif
 
-voidpf zcalloc (voidpf opaque, unsigned items, unsigned size)
+voidpf zcalloc(voidpf opaque, unsigned items, unsigned size)
 {
-    if (opaque) opaque = 0; /* to make compiler happy */
+	if (opaque)
+		opaque = 0;	/* to make compiler happy */
     return _halloc((long)items, size);
 }
 
-void  zcfree (voidpf opaque, voidpf ptr)
+void zcfree(voidpf opaque, voidpf ptr)
 {
-    if (opaque) opaque = 0; /* to make compiler happy */
+	if (opaque)
+		opaque = 0;	/* to make compiler happy */
     _hfree(ptr);
 }
 
@@ -205,21 +212,23 @@
 extern void   free   OF((voidpf ptr));
 #endif
 
-voidpf zcalloc (opaque, items, size)
-    voidpf opaque;
-    unsigned items;
-    unsigned size;
-{
-    if (opaque) items += size - size; /* make compiler happy */
-    return (voidpf)calloc(items, size);
+voidpf zcalloc(opaque, items, size)
+voidpf opaque;
+unsigned items;
+unsigned size;
+{
+	if (opaque)
+		items += size - size;	/* make compiler happy */
+	return (voidpf) calloc(items, size);
 }
 
-void  zcfree (opaque, ptr)
-    voidpf opaque;
-    voidpf ptr;
+void zcfree(opaque, ptr)
+voidpf opaque;
+voidpf ptr;
 {
     free(ptr);
-    if (opaque) return; /* make compiler happy */
+	if (opaque)
+		return;		/* make compiler happy */
 }
 
 #endif /* MY_ZCALLOC */
--- zlib-1.1.3/zutil.h	1998-07-08 13:01:48.000000000 -0400
+++ zlib-1.1.3/zutil.h	2014-02-07 11:53:21.352326892 -0500
@@ -8,7 +8,7 @@
    subject to change. Applications should only use zlib.h.
  */
 
-/* @(#) $Id$ */
+/* @(#) $Id: zutil.h,v 1.1 2001/11/09 01:48:02 mpl Exp $ */
 
 #ifndef _Z_UTIL_H
 #define _Z_UTIL_H
@@ -16,18 +16,18 @@
 #include "zlib.h"
 
 #ifdef STDC
-#  include <stddef.h>
-#  include <string.h>
-#  include <stdlib.h>
+#include <stddef.h>
+#include <string.h>
+#include <stdlib.h>
 #endif
 #ifdef NO_ERRNO_H
-    extern int errno;
+extern int errno;
 #else
-#   include <errno.h>
+#include <errno.h>
 #endif
 
 #ifndef local
-#  define local static
+#define local static
 #endif
 /* compile with -Dlocal if your debugger can't find static symbols */
 
@@ -49,14 +49,14 @@
         /* common constants */
 
 #ifndef DEF_WBITS
-#  define DEF_WBITS MAX_WBITS
+#define DEF_WBITS MAX_WBITS
 #endif
 /* default windowBits for decompression. MAX_WBITS is for compression only */
 
 #if MAX_MEM_LEVEL >= 8
-#  define DEF_MEM_LEVEL 8
+#define DEF_MEM_LEVEL 8
 #else
-#  define DEF_MEM_LEVEL  MAX_MEM_LEVEL
+#define DEF_MEM_LEVEL  MAX_MEM_LEVEL
 #endif
 /* default memLevel */
 
@@ -74,70 +74,69 @@
         /* target dependencies */
 
 #ifdef MSDOS
-#  define OS_CODE  0x00
-#  if defined(__TURBOC__) || defined(__BORLANDC__)
-#    if(__STDC__ == 1) && (defined(__LARGE__) || defined(__COMPACT__))
+#define OS_CODE  0x00
+#if defined(__TURBOC__) || defined(__BORLANDC__)
+#if(__STDC__ == 1) && (defined(__LARGE__) || defined(__COMPACT__))
        /* Allow compilation with ANSI keywords only enabled */
-       void _Cdecl farfree( void *block );
-       void *_Cdecl farmalloc( unsigned long nbytes );
-#    else
-#     include <alloc.h>
-#    endif
-#  else /* MSC or DJGPP */
-#    include <malloc.h>
-#  endif
+void _Cdecl farfree(void *block);
+void *_Cdecl farmalloc(unsigned long nbytes);
+#else
+#include <alloc.h>
+#endif
+#else /* MSC or DJGPP */
+#include <malloc.h>
+#endif
 #endif
 
 #ifdef OS2
-#  define OS_CODE  0x06
+#define OS_CODE  0x06
 #endif
 
 #ifdef WIN32 /* Window 95 & Windows NT */
-#  define OS_CODE  0x0b
+#define OS_CODE  0x0b
 #endif
 
 #if defined(VAXC) || defined(VMS)
-#  define OS_CODE  0x02
-#  define F_OPEN(name, mode) \
+#define OS_CODE  0x02
+#define F_OPEN(name, mode) \
      fopen((name), (mode), "mbc=60", "ctx=stm", "rfm=fix", "mrs=512")
 #endif
 
 #ifdef AMIGA
-#  define OS_CODE  0x01
+#define OS_CODE  0x01
 #endif
 
 #if defined(ATARI) || defined(atarist)
-#  define OS_CODE  0x05
+#define OS_CODE  0x05
 #endif
 
 #if defined(MACOS) || defined(TARGET_OS_MAC)
-#  define OS_CODE  0x07
-#  if defined(__MWERKS__) && __dest_os != __be_os && __dest_os != __win32_os
-#    include <unix.h> /* for fdopen */
-#  else
-#    ifndef fdopen
-#      define fdopen(fd,mode) NULL /* No fdopen() */
-#    endif
-#  endif
+#define OS_CODE  0x07
+#if defined(__MWERKS__) && __dest_os != __be_os && __dest_os != __win32_os
+#include <unix.h>		/* for fdopen */
+#else
+#ifndef fdopen
+#define fdopen(fd,mode) NULL	/* No fdopen() */
+#endif
+#endif
 #endif
 
 #ifdef __50SERIES /* Prime/PRIMOS */
-#  define OS_CODE  0x0F
+#define OS_CODE  0x0F
 #endif
 
 #ifdef TOPS20
-#  define OS_CODE  0x0a
+#define OS_CODE  0x0a
 #endif
 
 #if defined(_BEOS_) || defined(RISCOS)
-#  define fdopen(fd,mode) NULL /* No fdopen() */
+#define fdopen(fd,mode) NULL	/* No fdopen() */
 #endif
 
 #if (defined(_MSC_VER) && (_MSC_VER > 600))
-#  define fdopen(fd,type)  _fdopen(fd,type)
+#define fdopen(fd,type)  _fdopen(fd,type)
 #endif
 
-
         /* Common defaults */
 
 #ifndef OS_CODE
@@ -141,73 +140,72 @@
         /* Common defaults */
 
 #ifndef OS_CODE
-#  define OS_CODE  0x03  /* assume Unix */
+#define OS_CODE  0x03		/* assume Unix */
 #endif
 
 #ifndef F_OPEN
-#  define F_OPEN(name, mode) fopen((name), (mode))
+#define F_OPEN(name, mode) fopen((name), (mode))
 #endif
 
          /* functions */
 
 #ifdef HAVE_STRERROR
-   extern char *strerror OF((int));
-#  define zstrerror(errnum) strerror(errnum)
+extern char *strerror OF((int));
+#define zstrerror(errnum) strerror(errnum)
 #else
-#  define zstrerror(errnum) ""
+#define zstrerror(errnum) ""
 #endif
 
 #if defined(pyr)
-#  define NO_MEMCPY
+#define NO_MEMCPY
 #endif
 #if defined(SMALL_MEDIUM) && !defined(_MSC_VER) && !defined(__SC__)
  /* Use our own functions for small and medium model with MSC <= 5.0.
   * You may have to use the same strategy for Borland C (untested).
   * The __SC__ check is for Symantec.
   */
-#  define NO_MEMCPY
+#define NO_MEMCPY
 #endif
 #if defined(STDC) && !defined(HAVE_MEMCPY) && !defined(NO_MEMCPY)
-#  define HAVE_MEMCPY
+#define HAVE_MEMCPY
 #endif
 #ifdef HAVE_MEMCPY
-#  ifdef SMALL_MEDIUM /* MSDOS small or medium model */
-#    define zmemcpy _fmemcpy
-#    define zmemcmp _fmemcmp
-#    define zmemzero(dest, len) _fmemset(dest, 0, len)
-#  else
-#    define zmemcpy memcpy
-#    define zmemcmp memcmp
-#    define zmemzero(dest, len) memset(dest, 0, len)
-#  endif
-#else
-   extern void zmemcpy  OF((Bytef* dest, const Bytef* source, uInt len));
-   extern int  zmemcmp  OF((const Bytef* s1, const Bytef* s2, uInt len));
-   extern void zmemzero OF((Bytef* dest, uInt len));
+#ifdef SMALL_MEDIUM		/* MSDOS small or medium model */
+#define zmemcpy _fmemcpy
+#define zmemcmp _fmemcmp
+#define zmemzero(dest, len) _fmemset(dest, 0, len)
+#else
+#define zmemcpy memcpy
+#define zmemcmp memcmp
+#define zmemzero(dest, len) memset(dest, 0, len)
+#endif
+#else
+extern void zmemcpy OF((Bytef * dest, const Bytef * source, uInt len));
+extern int zmemcmp OF((const Bytef * s1, const Bytef * s2, uInt len));
+extern void zmemzero OF((Bytef * dest, uInt len));
 #endif
 
 /* Diagnostic functions */
 #ifdef DEBUG
-#  include <stdio.h>
-   extern int z_verbose;
-   extern void z_error    OF((char *m));
-#  define Assert(cond,msg) {if(!(cond)) z_error(msg);}
-#  define Trace(x) {if (z_verbose>=0) fprintf x ;}
-#  define Tracev(x) {if (z_verbose>0) fprintf x ;}
-#  define Tracevv(x) {if (z_verbose>1) fprintf x ;}
-#  define Tracec(c,x) {if (z_verbose>0 && (c)) fprintf x ;}
-#  define Tracecv(c,x) {if (z_verbose>1 && (c)) fprintf x ;}
-#else
-#  define Assert(cond,msg)
-#  define Trace(x)
-#  define Tracev(x)
-#  define Tracevv(x)
-#  define Tracec(c,x)
-#  define Tracecv(c,x)
+#include <stdio.h>
+extern int z_verbose;
+extern void z_error OF((char *m));
+#define Assert(cond,msg) {if(!(cond)) z_error(msg);}
+#define Trace(x) {if (z_verbose>=0) fprintf x ;}
+#define Tracev(x) {if (z_verbose>0) fprintf x ;}
+#define Tracevv(x) {if (z_verbose>1) fprintf x ;}
+#define Tracec(c,x) {if (z_verbose>0 && (c)) fprintf x ;}
+#define Tracecv(c,x) {if (z_verbose>1 && (c)) fprintf x ;}
+#else
+#define Assert(cond,msg)
+#define Trace(x)
+#define Tracev(x)
+#define Tracevv(x)
+#define Tracec(c,x)
+#define Tracecv(c,x)
 #endif
 
-
-typedef uLong (ZEXPORT *check_func) OF((uLong check, const Bytef *buf,
+typedef uLong(ZEXPORT * check_func) OF((uLong check, const Bytef * buf,
 				       uInt len));
 voidpf zcalloc OF((voidpf opaque, unsigned items, unsigned size));
 void   zcfree  OF((voidpf opaque, voidpf ptr));
--- zlib-1.1.3/zlib.h	1998-07-09 12:06:56.000000000 -0400
zlib-1.1.3/zlib.h	2014-02-07 11:53:21.348326995 -0500
@@ -60,12 +59,12 @@
   crash even in case of corrupted input.
 */
 
-typedef voidpf (*alloc_func) OF((voidpf opaque, uInt items, uInt size));
-typedef void   (*free_func)  OF((voidpf opaque, voidpf address));
+	typedef voidpf(*alloc_func) OF((voidpf opaque, uInt items, uInt size));
+	typedef void (*free_func) OF((voidpf opaque, voidpf address));
 
-struct internal_state;
+	struct internal_state;
 
-typedef struct z_stream_s {
+	typedef struct z_stream_s {
     Bytef    *next_in;  /* next input byte */
     uInt     avail_in;  /* number of bytes available at next_in */
     uLong    total_in;  /* total nb of input bytes read so far */
@@ -84,9 +83,9 @@
     int     data_type;  /* best guess about the data type: ascii or binary */
     uLong   adler;      /* adler32 value of the uncompressed data */
     uLong   reserved;   /* reserved for future use */
-} z_stream;
+	} z_stream;
 
-typedef z_stream FAR *z_streamp;
+	typedef z_stream FAR *z_streamp;
 
 /*
    The application must update next_in and avail_in when avail_in has
@@ -168,7 +167,7 @@
 
                         /* basic functions */
 
-ZEXTERN const char * ZEXPORT zlibVersion OF((void));
+	ZEXTERN const char *ZEXPORT zlibVersion OF((void));
 /* The application can compare zlibVersion and ZLIB_VERSION for consistency.
    If the first character differs, the library code actually used is
    not compatible with the zlib.h header file used by the application.
@@ -197,8 +196,7 @@
    perform any compression: this will be done by deflate().
 */
 
-
-ZEXTERN int ZEXPORT deflate OF((z_streamp strm, int flush));
+	ZEXTERN int ZEXPORT deflate OF((z_streamp strm, int flush));
 /*
     deflate compresses as much data as possible, and stops when the input
   buffer becomes empty or the output buffer becomes full. It may introduce some
@@ -275,8 +273,7 @@
   (for example avail_in or avail_out was zero).
 */
 
-
-ZEXTERN int ZEXPORT deflateEnd OF((z_streamp strm));
+	ZEXTERN int ZEXPORT deflateEnd OF((z_streamp strm));
 /*
      All dynamically allocated data structures for this stream are freed.
    This function discards any unprocessed input and does not flush any
@@ -310,8 +306,7 @@
    avail_in may be modified, but next_out and avail_out are unchanged.)
 */
 
-
-ZEXTERN int ZEXPORT inflate OF((z_streamp strm, int flush));
+	ZEXTERN int ZEXPORT inflate OF((z_streamp strm, int flush));
 /*
     inflate decompresses as much data as possible, and stops when the input
   buffer becomes empty or the output buffer becomes full. It may some
@@ -379,8 +374,7 @@
   compression block.
 */
 
-
-ZEXTERN int ZEXPORT inflateEnd OF((z_streamp strm));
+	ZEXTERN int ZEXPORT inflateEnd OF((z_streamp strm));
 /*
      All dynamically allocated data structures for this stream are freed.
    This function discards any unprocessed input and does not flush any
@@ -441,8 +435,8 @@
    not perform any compression: this will be done by deflate().
 */
                             
-ZEXTERN int ZEXPORT deflateSetDictionary OF((z_streamp strm,
-                                             const Bytef *dictionary,
+	ZEXTERN int ZEXPORT deflateSetDictionary OF((z_streamp strm,
+						     const Bytef * dictionary,
                                              uInt  dictLength));
 /*
      Initializes the compression dictionary from the given byte sequence
@@ -477,8 +471,7 @@
    perform any compression: this will be done by deflate().
 */
 
-ZEXTERN int ZEXPORT deflateCopy OF((z_streamp dest,
-                                    z_streamp source));
+	ZEXTERN int ZEXPORT deflateCopy OF((z_streamp dest, z_streamp source));
 /*
      Sets the destination stream as a complete copy of the source stream.
 
@@ -495,7 +488,7 @@
    destination.
 */
 
-ZEXTERN int ZEXPORT deflateReset OF((z_streamp strm));
+	ZEXTERN int ZEXPORT deflateReset OF((z_streamp strm));
 /*
      This function is equivalent to deflateEnd followed by deflateInit,
    but does not free and reallocate all the internal compression state.
@@ -506,9 +499,8 @@
    stream state was inconsistent (such as zalloc or state being NULL).
 */
 
-ZEXTERN int ZEXPORT deflateParams OF((z_streamp strm,
-				      int level,
-				      int strategy));
+	ZEXTERN int ZEXPORT deflateParams OF((z_streamp strm,
+					      int level, int strategy));
 /*
      Dynamically update the compression level and compression strategy.  The
    interpretation of level and strategy is as in deflateInit2.  This can be
@@ -550,8 +542,8 @@
    modified, but next_out and avail_out are unchanged.)
 */
 
-ZEXTERN int ZEXPORT inflateSetDictionary OF((z_streamp strm,
-                                             const Bytef *dictionary,
+	ZEXTERN int ZEXPORT inflateSetDictionary OF((z_streamp strm,
+						     const Bytef * dictionary,
                                              uInt  dictLength));
 /*
      Initializes the decompression dictionary from the given uncompressed byte
@@ -569,7 +561,7 @@
    inflate().
 */
 
-ZEXTERN int ZEXPORT inflateSync OF((z_streamp strm));
+	ZEXTERN int ZEXPORT inflateSync OF((z_streamp strm));
 /* 
     Skips invalid compressed data until a full flush point (see above the
   description of deflate with Z_FULL_FLUSH) can be found, or until all
@@ -584,7 +576,7 @@
   until success or end of the input data.
 */
 
-ZEXTERN int ZEXPORT inflateReset OF((z_streamp strm));
+	ZEXTERN int ZEXPORT inflateReset OF((z_streamp strm));
 /*
      This function is equivalent to inflateEnd followed by inflateInit,
    but does not free and reallocate all the internal decompression state.
@@ -605,8 +596,9 @@
    utility functions can easily be modified if you need special options.
 */
 
-ZEXTERN int ZEXPORT compress OF((Bytef *dest,   uLongf *destLen,
-                                 const Bytef *source, uLong sourceLen));
+	ZEXTERN int ZEXPORT compress OF((Bytef * dest, uLongf * destLen,
+					 const Bytef * source,
+					 uLong sourceLen));
 /*
      Compresses the source buffer into the destination buffer.  sourceLen is
    the byte length of the source buffer. Upon entry, destLen is the total
@@ -620,8 +612,8 @@
    buffer.
 */
 
-ZEXTERN int ZEXPORT compress2 OF((Bytef *dest,   uLongf *destLen,
-                                  const Bytef *source, uLong sourceLen,
+	ZEXTERN int ZEXPORT compress2 OF((Bytef * dest, uLongf * destLen,
+					  const Bytef * source, uLong sourceLen,
                                   int level));
 /*
      Compresses the source buffer into the destination buffer. The level
@@ -635,8 +627,9 @@
    Z_STREAM_ERROR if the level parameter is invalid.
 */
 
-ZEXTERN int ZEXPORT uncompress OF((Bytef *dest,   uLongf *destLen,
-                                   const Bytef *source, uLong sourceLen));
+	ZEXTERN int ZEXPORT uncompress OF((Bytef * dest, uLongf * destLen,
+					   const Bytef * source,
+					   uLong sourceLen));
 /*
      Decompresses the source buffer into the destination buffer.  sourceLen is
    the byte length of the source buffer. Upon entry, destLen is the total
@@ -653,10 +646,9 @@
    buffer, or Z_DATA_ERROR if the input data was corrupted.
 */
 
+	typedef voidp gzFile;
 
-typedef voidp gzFile;
-
-ZEXTERN gzFile ZEXPORT gzopen  OF((const char *path, const char *mode));
+	ZEXTERN gzFile ZEXPORT gzopen OF((const char *path, const char *mode));
 /*
      Opens a gzip (.gz) file for reading or writing. The mode parameter
    is as in fopen ("rb" or "wb") but can also include a compression level
@@ -672,7 +664,7 @@
    can be checked to distinguish the two cases (if errno is zero, the
    zlib error is Z_MEM_ERROR).  */
 
-ZEXTERN gzFile ZEXPORT gzdopen  OF((int fd, const char *mode));
+	ZEXTERN gzFile ZEXPORT gzdopen OF((int fd, const char *mode));
 /*
      gzdopen() associates a gzFile with the file descriptor fd.  File
    descriptors are obtained from calls like open, dup, creat, pipe or
@@ -685,7 +677,8 @@
    the (de)compression state.
 */
 
-ZEXTERN int ZEXPORT gzsetparams OF((gzFile file, int level, int strategy));
+	ZEXTERN int ZEXPORT gzsetparams
+	    OF((gzFile file, int level, int strategy));
 /*
      Dynamically update the compression level or strategy. See the description
    of deflateInit2 for the meaning of these parameters.
@@ -693,7 +686,7 @@
    opened for writing.
 */
 
-ZEXTERN int ZEXPORT    gzread  OF((gzFile file, voidp buf, unsigned len));
+	ZEXTERN int ZEXPORT gzread OF((gzFile file, voidp buf, unsigned len));
 /*
      Reads the given number of uncompressed bytes from the compressed file.
    If the input file was not in gzip format, gzread copies the given number
@@ -701,7 +694,7 @@
      gzread returns the number of uncompressed bytes actually read (0 for
    end of file, -1 for error). */
 
-ZEXTERN int ZEXPORT    gzwrite OF((gzFile file, 
+	ZEXTERN int ZEXPORT gzwrite OF((gzFile file,
 				   const voidp buf, unsigned len));
 /*
      Writes the given number of uncompressed bytes into the compressed file.
@@ -709,21 +702,22 @@
    (0 in case of error).
 */
 
-ZEXTERN int ZEXPORTVA   gzprintf OF((gzFile file, const char *format, ...));
+	ZEXTERN int ZEXPORTVA gzprintf
+	    OF((gzFile file, const char *format, ...));
 /*
      Converts, formats, and writes the args to the compressed file under
    control of the format string, as in fprintf. gzprintf returns the number of
    uncompressed bytes actually written (0 in case of error).
 */
 
-ZEXTERN int ZEXPORT gzputs OF((gzFile file, const char *s));
+	ZEXTERN int ZEXPORT gzputs OF((gzFile file, const char *s));
 /*
       Writes the given null-terminated string to the compressed file, excluding
    the terminating null character.
       gzputs returns the number of characters written, or -1 in case of error.
 */
 
-ZEXTERN char * ZEXPORT gzgets OF((gzFile file, char *buf, int len));
+	ZEXTERN char *ZEXPORT gzgets OF((gzFile file, char *buf, int len));
 /*
       Reads bytes from the compressed file until len-1 characters are read, or
    a newline character is read and transferred to buf, or an end-of-file
@@ -732,19 +726,19 @@
       gzgets returns buf, or Z_NULL in case of error.
 */
 
-ZEXTERN int ZEXPORT    gzputc OF((gzFile file, int c));
+	ZEXTERN int ZEXPORT gzputc OF((gzFile file, int c));
 /*
       Writes c, converted to an unsigned char, into the compressed file.
    gzputc returns the value that was written, or -1 in case of error.
 */
 
-ZEXTERN int ZEXPORT    gzgetc OF((gzFile file));
+	ZEXTERN int ZEXPORT gzgetc OF((gzFile file));
 /*
       Reads one byte from the compressed file. gzgetc returns this byte
    or -1 in case of end of file or error.
 */
 
-ZEXTERN int ZEXPORT    gzflush OF((gzFile file, int flush));
+	ZEXTERN int ZEXPORT gzflush OF((gzFile file, int flush));
 /*
      Flushes all pending output into the compressed file. The parameter
    flush is as in the deflate() function. The return value is the zlib
@@ -754,7 +748,7 @@
    degrade compression.
 */
 
-ZEXTERN z_off_t ZEXPORT    gzseek OF((gzFile file,
+	ZEXTERN z_off_t ZEXPORT gzseek OF((gzFile file,
 				      z_off_t offset, int whence));
 /* 
       Sets the starting position for the next gzread or gzwrite on the
@@ -772,14 +766,14 @@
    would be before the current position.
 */
 
-ZEXTERN int ZEXPORT    gzrewind OF((gzFile file));
+	ZEXTERN int ZEXPORT gzrewind OF((gzFile file));
 /*
      Rewinds the given file. This function is supported only for reading.
 
    gzrewind(file) is equivalent to (int)gzseek(file, 0L, SEEK_SET)
 */
 
-ZEXTERN z_off_t ZEXPORT    gztell OF((gzFile file));
+	ZEXTERN z_off_t ZEXPORT gztell OF((gzFile file));
 /*
      Returns the starting position for the next gzread or gzwrite on the
    given compressed file. This position represents a number of bytes in the
@@ -788,20 +782,20 @@
    gztell(file) is equivalent to gzseek(file, 0L, SEEK_CUR)
 */
 
-ZEXTERN int ZEXPORT gzeof OF((gzFile file));
+	ZEXTERN int ZEXPORT gzeof OF((gzFile file));
 /*
      Returns 1 when EOF has previously been detected reading the given
    input stream, otherwise zero.
 */
 
-ZEXTERN int ZEXPORT    gzclose OF((gzFile file));
+	ZEXTERN int ZEXPORT gzclose OF((gzFile file));
 /*
      Flushes all pending output if necessary, closes the compressed file
    and deallocates all the (de)compression state. The return value is the zlib
    error number (see function gzerror below).
 */
 
-ZEXTERN const char * ZEXPORT gzerror OF((gzFile file, int *errnum));
+	ZEXTERN const char *ZEXPORT gzerror OF((gzFile file, int *errnum));
 /*
      Returns the error message for the last error which occurred on the
    given compressed file. errnum is set to zlib error number. If an
@@ -818,7 +812,8 @@
    compression library.
 */
 
-ZEXTERN uLong ZEXPORT adler32 OF((uLong adler, const Bytef *buf, uInt len));
+	ZEXTERN uLong ZEXPORT adler32
+	    OF((uLong adler, const Bytef * buf, uInt len));
 
 /*
      Update a running Adler-32 checksum with the bytes buf[0..len-1] and
@@ -835,7 +830,8 @@
      if (adler != original_adler) error();
 */
 
-ZEXTERN uLong ZEXPORT crc32   OF((uLong crc, const Bytef *buf, uInt len));
+	ZEXTERN uLong ZEXPORT crc32
+	    OF((uLong crc, const Bytef * buf, uInt len));
 /*
      Update a running crc with the bytes buf[0..len-1] and return the updated
    crc. If buf is NULL, this function returns the required initial value
@@ -857,16 +852,18 @@
 /* deflateInit and inflateInit are macros to allow checking the zlib version
  * and the compiler's view of z_stream:
  */
-ZEXTERN int ZEXPORT deflateInit_ OF((z_streamp strm, int level,
-                                     const char *version, int stream_size));
-ZEXTERN int ZEXPORT inflateInit_ OF((z_streamp strm,
-                                     const char *version, int stream_size));
-ZEXTERN int ZEXPORT deflateInit2_ OF((z_streamp strm, int  level, int  method,
-                                      int windowBits, int memLevel,
-                                      int strategy, const char *version,
+	ZEXTERN int ZEXPORT deflateInit_ OF((z_streamp strm, int level,
+					     const char *version,
+					     int stream_size));
+	ZEXTERN int ZEXPORT inflateInit_
+	    OF((z_streamp strm, const char *version, int stream_size));
+	ZEXTERN int ZEXPORT deflateInit2_
+	    OF((z_streamp strm, int level, int method, int windowBits,
+		int memLevel, int strategy, const char *version,
+		int stream_size));
+	ZEXTERN int ZEXPORT inflateInit2_
+	    OF((z_streamp strm, int windowBits, const char *version,
                                       int stream_size));
-ZEXTERN int ZEXPORT inflateInit2_ OF((z_streamp strm, int  windowBits,
-                                      const char *version, int stream_size));
 #define deflateInit(strm, level) \
         deflateInit_((strm), (level),       ZLIB_VERSION, sizeof(z_stream))
 #define inflateInit(strm) \
@@ -877,14 +874,15 @@
 #define inflateInit2(strm, windowBits) \
         inflateInit2_((strm), (windowBits), ZLIB_VERSION, sizeof(z_stream))
 
-
 #if !defined(_Z_UTIL_H) && !defined(NO_DUMMY_DECL)
-    struct internal_state {int dummy;}; /* hack for buggy compilers */
+	struct internal_state {
+		int dummy;
+	};			/* hack for buggy compilers */
 #endif
 
-ZEXTERN const char   * ZEXPORT zError           OF((int err));
-ZEXTERN int            ZEXPORT inflateSyncPoint OF((z_streamp z));
-ZEXTERN const uLongf * ZEXPORT get_crc_table    OF((void));
+	ZEXTERN const char *ZEXPORT zError OF((int err));
+	ZEXTERN int ZEXPORT inflateSyncPoint OF((z_streamp z));
+	ZEXTERN const uLongf *ZEXPORT get_crc_table OF((void));
 
 #ifdef __cplusplus
 }
--- zlib-1.1.3/zconf.h	1998-07-08 13:55:27.000000000 -0400
zlib-1.1.3/zconf.h	2014-02-07 11:53:21.348326995 -0500
@@ -3,7 +3,7 @@
  * For conditions of distribution and use, see copyright notice in zlib.h 
  */
 
-/* @(#) $Id$ */
+/* @(#) $Id: zconf.h,v 1.1 2001/11/09 01:48:02 mpl Exp $ */
 
 #ifndef _ZCONF_H
 #define _ZCONF_H
@@ -13,51 +13,51 @@
  * compile with -DZ_PREFIX. The "standard" zlib should be compiled without it.
  */
 #ifdef Z_PREFIX
-#  define deflateInit_	z_deflateInit_
-#  define deflate	z_deflate
-#  define deflateEnd	z_deflateEnd
-#  define inflateInit_ 	z_inflateInit_
-#  define inflate	z_inflate
-#  define inflateEnd	z_inflateEnd
-#  define deflateInit2_	z_deflateInit2_
-#  define deflateSetDictionary z_deflateSetDictionary
-#  define deflateCopy	z_deflateCopy
-#  define deflateReset	z_deflateReset
-#  define deflateParams	z_deflateParams
-#  define inflateInit2_	z_inflateInit2_
-#  define inflateSetDictionary z_inflateSetDictionary
-#  define inflateSync	z_inflateSync
-#  define inflateSyncPoint z_inflateSyncPoint
-#  define inflateReset	z_inflateReset
-#  define compress	z_compress
-#  define compress2	z_compress2
-#  define uncompress	z_uncompress
-#  define adler32	z_adler32
-#  define crc32		z_crc32
-#  define get_crc_table z_get_crc_table
-
-#  define Byte		z_Byte
-#  define uInt		z_uInt
-#  define uLong		z_uLong
-#  define Bytef	        z_Bytef
-#  define charf		z_charf
-#  define intf		z_intf
-#  define uIntf		z_uIntf
-#  define uLongf	z_uLongf
-#  define voidpf	z_voidpf
-#  define voidp		z_voidp
+#define deflateInit_	z_deflateInit_
+#define deflate	z_deflate
+#define deflateEnd	z_deflateEnd
+#define inflateInit_ 	z_inflateInit_
+#define inflate	z_inflate
+#define inflateEnd	z_inflateEnd
+#define deflateInit2_	z_deflateInit2_
+#define deflateSetDictionary z_deflateSetDictionary
+#define deflateCopy	z_deflateCopy
+#define deflateReset	z_deflateReset
+#define deflateParams	z_deflateParams
+#define inflateInit2_	z_inflateInit2_
+#define inflateSetDictionary z_inflateSetDictionary
+#define inflateSync	z_inflateSync
+#define inflateSyncPoint z_inflateSyncPoint
+#define inflateReset	z_inflateReset
+#define compress	z_compress
+#define compress2	z_compress2
+#define uncompress	z_uncompress
+#define adler32	z_adler32
+#define crc32		z_crc32
+#define get_crc_table z_get_crc_table
+
+#define Byte		z_Byte
+#define uInt		z_uInt
+#define uLong		z_uLong
+#define Bytef	        z_Bytef
+#define charf		z_charf
+#define intf		z_intf
+#define uIntf		z_uIntf
+#define uLongf	z_uLongf
+#define voidpf	z_voidpf
+#define voidp		z_voidp
 #endif
 
 #if (defined(_WIN32) || defined(__WIN32__)) && !defined(WIN32)
-#  define WIN32
+#define WIN32
 #endif
 #if defined(__GNUC__) || defined(WIN32) || defined(__386__) || defined(i386)
-#  ifndef __32BIT__
-#    define __32BIT__
-#  endif
+#ifndef __32BIT__
+#define __32BIT__
+#endif
 #endif
 #if defined(__MSDOS__) && !defined(MSDOS)
-#  define MSDOS
+#define MSDOS
 #endif
 
 /*
@@ -65,45 +65,44 @@
  * than 64k bytes at a time (needed on systems with 16-bit int).
  */
 #if defined(MSDOS) && !defined(__32BIT__)
-#  define MAXSEG_64K
+#define MAXSEG_64K
 #endif
 #ifdef MSDOS
-#  define UNALIGNED_OK
+#define UNALIGNED_OK
 #endif
 
 #if (defined(MSDOS) || defined(_WINDOWS) || defined(WIN32))  && !defined(STDC)
-#  define STDC
+#define STDC
 #endif
 #if defined(__STDC__) || defined(__cplusplus) || defined(__OS2__)
-#  ifndef STDC
-#    define STDC
-#  endif
+#ifndef STDC
+#define STDC
+#endif
 #endif
 
 #ifndef STDC
-#  ifndef const /* cannot use !defined(STDC) && !defined(const) on Mac */
-#    define const
-#  endif
+#ifndef const			/* cannot use !defined(STDC) && !defined(const) on Mac */
+#define const
+#endif
 #endif
 
 /* Some Mac compilers merge all .h files incorrectly: */
 #if defined(__MWERKS__) || defined(applec) ||defined(THINK_C) ||defined(__SC__)
-#  define NO_DUMMY_DECL
+#define NO_DUMMY_DECL
 #endif
 
 /* Old Borland C incorrectly complains about missing returns: */
 #if defined(__BORLANDC__) && (__BORLANDC__ < 0x500)
-#  define NEED_DUMMY_RETURN
+#define NEED_DUMMY_RETURN
 #endif
 
-
 /* Maximum value for memLevel in deflateInit2 */
 #ifndef MAX_MEM_LEVEL
-#  ifdef MAXSEG_64K
-#    define MAX_MEM_LEVEL 8
-#  else
-#    define MAX_MEM_LEVEL 9
-#  endif
+#ifdef MAXSEG_64K
+#define MAX_MEM_LEVEL 8
+#else
+#define MAX_MEM_LEVEL 9
+#endif
 #endif
 
 /* Maximum value for windowBits in deflateInit2 and inflateInit2.
@@ -112,7 +111,7 @@
  * gzip.)
  */
 #ifndef MAX_WBITS
-#  define MAX_WBITS   15 /* 32K LZ77 window */
+#define MAX_WBITS   15		/* 32K LZ77 window */
 #endif
 
 /* The memory requirements for deflate are (in bytes):
@@ -131,11 +130,11 @@
                         /* Type declarations */
 
 #ifndef OF /* function prototypes */
-#  ifdef STDC
-#    define OF(args)  args
-#  else
-#    define OF(args)  ()
-#  endif
+#if defined(STDC) || defined(_BOLT_)
+#define OF(args)  args
+#else
+#define OF(args)  ()
+#endif
 #endif
 
 /* The following definitions for FAR are needed only for MSDOS mixed
@@ -146,68 +145,68 @@
  */
 #if (defined(M_I86SM) || defined(M_I86MM)) && !defined(__32BIT__)
    /* MSC small or medium model */
-#  define SMALL_MEDIUM
-#  ifdef _MSC_VER
-#    define FAR _far
-#  else
-#    define FAR far
-#  endif
+#define SMALL_MEDIUM
+#ifdef _MSC_VER
+#define FAR _far
+#else
+#define FAR far
+#endif
 #endif
 #if defined(__BORLANDC__) && (defined(__SMALL__) || defined(__MEDIUM__))
-#  ifndef __32BIT__
-#    define SMALL_MEDIUM
-#    define FAR _far
-#  endif
+#ifndef __32BIT__
+#define SMALL_MEDIUM
+#define FAR _far
+#endif
 #endif
 
 /* Compile with -DZLIB_DLL for Windows DLL support */
 #if defined(ZLIB_DLL)
-#  if defined(_WINDOWS) || defined(WINDOWS)
-#    ifdef FAR
-#      undef FAR
-#    endif
-#    include <windows.h>
-#    define ZEXPORT  WINAPI
-#    ifdef WIN32
-#      define ZEXPORTVA  WINAPIV
-#    else
-#      define ZEXPORTVA  FAR _cdecl _export
-#    endif
-#  endif
-#  if defined (__BORLANDC__)
-#    if (__BORLANDC__ >= 0x0500) && defined (WIN32)
-#      include <windows.h>
-#      define ZEXPORT __declspec(dllexport) WINAPI
-#      define ZEXPORTRVA __declspec(dllexport) WINAPIV
-#    else
-#      if defined (_Windows) && defined (__DLL__)
-#        define ZEXPORT _export
-#        define ZEXPORTVA _export
-#      endif
-#    endif
-#  endif
+#if defined(_WINDOWS) || defined(WINDOWS)
+#ifdef FAR
+#undef FAR
+#endif
+#include <windows.h>
+#define ZEXPORT  WINAPI
+#ifdef WIN32
+#define ZEXPORTVA  WINAPIV
+#else
+#define ZEXPORTVA  FAR _cdecl _export
+#endif
+#endif
+#if defined (__BORLANDC__)
+#if (__BORLANDC__ >= 0x0500) && defined (WIN32)
+#include <windows.h>
+#define ZEXPORT __declspec(dllexport) WINAPI
+#define ZEXPORTRVA __declspec(dllexport) WINAPIV
+#else
+#if defined (_Windows) && defined (__DLL__)
+#define ZEXPORT _export
+#define ZEXPORTVA _export
+#endif
+#endif
+#endif
 #endif
 
 #if defined (__BEOS__)
-#  if defined (ZLIB_DLL)
-#    define ZEXTERN extern __declspec(dllexport)
-#  else
-#    define ZEXTERN extern __declspec(dllimport)
-#  endif
+#if defined (ZLIB_DLL)
+#define ZEXTERN extern __declspec(dllexport)
+#else
+#define ZEXTERN extern __declspec(dllimport)
+#endif
 #endif
 
 #ifndef ZEXPORT
-#  define ZEXPORT
+#define ZEXPORT
 #endif
 #ifndef ZEXPORTVA
-#  define ZEXPORTVA
+#define ZEXPORTVA
 #endif
 #ifndef ZEXTERN
-#  define ZEXTERN extern
+#define ZEXTERN extern
 #endif
 
 #ifndef FAR
-#   define FAR
+#define FAR
 #endif
 
 #if !defined(MACOS) && !defined(TARGET_OS_MAC)
@@ -218,9 +217,9 @@
 
 #ifdef SMALL_MEDIUM
    /* Borland C/C++ and some old MSC versions ignore FAR inside typedef */
-#  define Bytef Byte FAR
+#define Bytef Byte FAR
 #else
-   typedef Byte  FAR Bytef;
+typedef Byte FAR Bytef;
 #endif
 typedef char  FAR charf;
 typedef int   FAR intf;
@@ -228,52 +227,52 @@
 typedef uLong FAR uLongf;
 
 #ifdef STDC
-   typedef void FAR *voidpf;
-   typedef void     *voidp;
+typedef void FAR *voidpf;
+typedef void *voidp;
 #else
-   typedef Byte FAR *voidpf;
-   typedef Byte     *voidp;
+typedef Byte FAR *voidpf;
+typedef Byte *voidp;
 #endif
 
 #ifdef HAVE_UNISTD_H
-#  include <sys/types.h> /* for off_t */
-#  include <unistd.h>    /* for SEEK_* and off_t */
-#  define z_off_t  off_t
+#include <sys/types.h>		/* for off_t */
+#include <unistd.h>		/* for SEEK_* and off_t */
+#define z_off_t  off_t
 #endif
 #ifndef SEEK_SET
-#  define SEEK_SET        0       /* Seek from beginning of file.  */
-#  define SEEK_CUR        1       /* Seek from current position.  */
-#  define SEEK_END        2       /* Set file pointer to EOF plus "offset" */
+#define SEEK_SET        0	/* Seek from beginning of file.  */
+#define SEEK_CUR        1	/* Seek from current position.  */
+#define SEEK_END        2	/* Set file pointer to EOF plus "offset" */
 #endif
 #ifndef z_off_t
-#  define  z_off_t long
+#define  z_off_t long
 #endif
 
 /* MVS linker does not support external names larger than 8 bytes */
 #if defined(__MVS__)
-#   pragma map(deflateInit_,"DEIN")
-#   pragma map(deflateInit2_,"DEIN2")
-#   pragma map(deflateEnd,"DEEND")
-#   pragma map(inflateInit_,"ININ")
-#   pragma map(inflateInit2_,"ININ2")
-#   pragma map(inflateEnd,"INEND")
-#   pragma map(inflateSync,"INSY")
-#   pragma map(inflateSetDictionary,"INSEDI")
-#   pragma map(inflate_blocks,"INBL")
-#   pragma map(inflate_blocks_new,"INBLNE")
-#   pragma map(inflate_blocks_free,"INBLFR")
-#   pragma map(inflate_blocks_reset,"INBLRE")
-#   pragma map(inflate_codes_free,"INCOFR")
-#   pragma map(inflate_codes,"INCO")
-#   pragma map(inflate_fast,"INFA")
-#   pragma map(inflate_flush,"INFLU")
-#   pragma map(inflate_mask,"INMA")
-#   pragma map(inflate_set_dictionary,"INSEDI2")
-#   pragma map(inflate_copyright,"INCOPY")
-#   pragma map(inflate_trees_bits,"INTRBI")
-#   pragma map(inflate_trees_dynamic,"INTRDY")
-#   pragma map(inflate_trees_fixed,"INTRFI")
-#   pragma map(inflate_trees_free,"INTRFR")
+#pragma map(deflateInit_,"DEIN")
+#pragma map(deflateInit2_,"DEIN2")
+#pragma map(deflateEnd,"DEEND")
+#pragma map(inflateInit_,"ININ")
+#pragma map(inflateInit2_,"ININ2")
+#pragma map(inflateEnd,"INEND")
+#pragma map(inflateSync,"INSY")
+#pragma map(inflateSetDictionary,"INSEDI")
+#pragma map(inflate_blocks,"INBL")
+#pragma map(inflate_blocks_new,"INBLNE")
+#pragma map(inflate_blocks_free,"INBLFR")
+#pragma map(inflate_blocks_reset,"INBLRE")
+#pragma map(inflate_codes_free,"INCOFR")
+#pragma map(inflate_codes,"INCO")
+#pragma map(inflate_fast,"INFA")
+#pragma map(inflate_flush,"INFLU")
+#pragma map(inflate_mask,"INMA")
+#pragma map(inflate_set_dictionary,"INSEDI2")
+#pragma map(inflate_copyright,"INCOPY")
+#pragma map(inflate_trees_bits,"INTRBI")
+#pragma map(inflate_trees_dynamic,"INTRDY")
+#pragma map(inflate_trees_fixed,"INTRFI")
+#pragma map(inflate_trees_free,"INTRFR")
 #endif
 
 #endif /* _ZCONF_H */
