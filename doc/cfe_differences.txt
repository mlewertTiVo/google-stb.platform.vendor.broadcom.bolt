:toc2:
:toclevels: 4
:max-width: 100%

CFE difference
==============
Broadcom Corporation <support@broadcom.com>

 UI commands
------------

BOLT has acquired a few new UI commands, below is a list of them.

 Devicetree
~~~~~~~~~~~
----
dt bolt ........... Modify an existing DTB with an autogenerated BOLT config.
dt del prop ....... Delete a property from the DTB.  
dt del node ....... Delete a node from the DTB.
dt add prop ....... Add a new property to the DTB.
dt add node ....... Add a new node to the DTB.
dt sane ........... Check DTB header.
dt show ........... Decode contents of a memory resident DTB file as a DTS.
dt memreserve ..... Add an entry to the DTB memory reservation table. 
                    The address and length shall be specified in hex. 
                    The DT_ADDRESS envar is used as the base address of 
                    the dtb. 
----

 Runtime configuration
~~~~~~~~~~~~~~~~~~~~~~
----
setboard .......... Set board (configuration) to use.
boards ............ Show supported boards for this build of BOLT.
rts ............... Set or show RTS sets.
mhl power ......... Show the MHL bootup power                                                                                 
----

 Flash
~~~~~~
----
erase ............. Erase entire flash device or partition
----

 Debug
~~~~~~
----
crc ............... Report the CRC32 for a memory range.
gisb .............. Show or set GISB bus timeout
memwrap ........... Test for end of (ddr) memory.
mii ............... Reads or writes register contents from/to specified PHY address
uncache ........... Mark (all ddr) memory access via the mmu as uncached.
sha ............... Calculate SHA256 of a memory region via BCM dma h/w engine.
time .............. Timing utility.
----

 eMMC
~~~~~
----
rpmb counter ...... Read the RPMB Write Counter.
rpmb program-key .. Program the authentication key.
rpmb use-key ...... Specify the key to be used for all RPMB operations.
----

 Notes
~~~~~~

* The 'dt' commands are for manipulating and showing Devicetrees that
ARM Linux needs for its configuration.

* As Broadcom has to support multiple platforms we have an option to store
common information per board (for the same chip family) as runtime
parameters.

* The 'boards' and 'setboard' allow you to see the options
available and select a new board configuration for BOLT at runtime.

* Changing board requires you to perform a reboot so
that the new board information can be picked up.

* The 'boot' and 'load' have acquired some extra flags for
the Linux zImage format.

* The 'zimg' 'loader' is the default (except for the
'batch' command), so if you want to load a raw
binary or ELF file you have to specify it, e.g.

----
# set static IP address first
ifconfig eth0 -addr=192.168.0.40 -mask=255.255.255.0 -gw=192.168.0.42

# load using ELF loader
load -elf 192.168.0.42:bolt.elf

# ...an alternative way
load -loader=elf 192.168.0.42:bolt.elf

# 'raw' loader for binary data
load -loader=raw 192.168.0.42:data.bin
----

* The 'macprog' command updates the 'ETH0_HWADDR' environment variable
without rebooting the board. It allows BOLT to update DTB with a new
MAC address and jump to Linux without the need for reboot.

NOTE: A newly programmed MAC address by the 'macprog' command
will not be effective in BOLT until the board gets rebooted.

* As of version v0.69 we've switched to a dynamic flash partitioning
scheme where after certain minimal size requirements are met,
the partitions will expand or contract to match the flash
devices size. This means being able to use the full flash size
without having to re-build BOLT. The eariler fixed flash
mapping is also available so you can still specify it
by simple alteration to the config files. No code hacking
is required.

* As of version v0.74 all physical Ethernet (GENET) devices
are instantiated in BOLT, previously only eth0 (GENET #0) was.
 You can now select from multiple Ethernet devices, but please note
that 'you have to add your own driver if using an external PHY or
another type of switch'.

* As of version v0.81 we will be moving toward dynamic CMA and 
Linux LPAE (40 bit) addressing support. If you look at the
memory node in Devicetree it can be seen to have moved from
sets of 32 bit values to now be sets of 64 bit values.

The way BOLT is built is different from CFE. The bolt.bin file
is built as a single unit then a script splits it up into fsbl.bin and
ssbl.bin, whereas CFE make a separate FSBL & SSBL to then concatenate
into a CFE.BIN. Build time configuration is set by 'cfg' files in the
config/ directory. A Perl script takes those and autogenerates c,
header and support makefiles in the gen/<FAMILY> directory.


 Saving and loading a Devicetree
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

* The 'flash' command can now source from main ram memory. Here
is an example of saving and then re-loading a Devicetree,
which exists in DDR memory:

----
BOLT> flash -forceerase -mem=0x1000 -memsize=0x10000 mem0 flash0.devtree

BOLT> load -raw -addr=0x5000 -max=0x10000 flash0.devtree:
BOLT> setenv DT_ADDRESS 0x5000
----

The value 0x1000 corresponds to the environment variable [red]#DT_ADDRESS#
and 0x10000 to the maximum Devicetree size. This may be different
on your system so 'printenv' will show the actual values.

IMPORTANT: flash0.devtree exists as a convenience for developers, BOLT
does _not_ store its Devicetree in that flash partition.

How BOLT for ARM boots and runs
-------------------------------

On the ARM chips we have 64Kb of static ram (SRAM) available, unlike 
the MIPS chips which had no real ram memory before ddr SHMOO'ing. 

If FSBL detects its running from FLASH (Boot 1.0) it copies itself to 
SRAM and then jump to SRAM and runs from there, else its _been_ copied
(Boot 2.0) to SRAM (by the system security hardware) and just runs.

You could get it to run totally from (SPI/NOR) FLASH - but that depends
if the chip security will let you and if any modifications (by 
customers) are required for the next step...

FSBL then loads into another portion of the SRAM any AVS or 
SHMOO data it needs to complete. After shmooing the SSBL is
loaded into DDR and executed. 

The old way CFE did SHMOO was to enable the cache in writeback mode so stack
and data lived in the cache above ddr (memory that was at that point unusable)
to have a working data space.


Appendix: Copyright Info
------------------------

Copyright (C) 2014-2015, Broadcom Corporation.
All Rights Reserved.
Confidential Property of Broadcom Corporation.

