:toc2:
:toclevels: 3
:max-width: 100%

 Options for a 3rd stage bootloader
===================================
Broadcom Ltd <support@broadcom.com>


 Introduction
-------------
Regular updates for security, fixes or new features are a fact of life in 
increasingly complex embedded systems. Direct or indirect interdependency
between disparate software components can also be a feature or an
emergent property of such systems.

Given the nature of these systems, strategies for updating *all* software
components should be factored into the design.

Bootloaders have generally been the one component to require the least
number of updates, often hard wired to never be updated at all. Mitigation
strategies have involved function and/or data patch tables, hacks incorporated
into the main OS the bootloader executes, or mini-bootloaders glued onto an OS
image.

Often it is wiser to have an extra step in the execution chain where the original
bootloader starts a newer (downloaded) version of itself (or any dedicated updatable
code) that would now be responsible for starting the main OS, instead of the original
bootloader. This is often called a "Third Stage BootLoader" (TSBL).

This document deals with the issues of, and how to implement a TSBL using BOLT as
with a few careful choices the majority of the SSBL source code can do double duty
as a TSBL.

NOTE: BOLT provides the Device Tree ARM Linux requires. This couples
versions of BOLT and Linux together. By using a TSBL most of the
coupling issues between BOLT and Linux resolve themselves.


 Flash layout for update
------------------------
For improved reliability systems should have multiple application images
(e.g. TSBL + OS + rootfs) that the primary bootloader can choose from.
Priority in most schemes is given to the newest image that passes validity
(signing) test(s) and decrypts properly, with fallback to earlier versions
should any newer image fail to pass the tests.

This ensures there is always some form of backup should an update fail. Some
systems also have a separate emergency 'recovery' image that is only used
to get an application image should none prove to be valid.


.Example simplified flash map #1
[options="header", width="60%"]
|=========================================
|Partition	|Role		|Updatable
|BOLT		|FSBL+SSBL	|N
|IMAGE0		|TSBL+OS+rootfs	|Y
|IMAGE1		|TSBL+OS+rootfs	|Y
|IMAGE2		|TSBL+OS+rootfs	|Y
|RECOVERY	|TSBL+OS+rootfs	|N
|=========================================

.Example simplified flash map #2
[options="header", width="60%"]
|=========================================
|Partition	|Role      		|Updatable
|BOLT		|FSBL+SSBL		|N
|TSBL		|TSBL			|Y
|IMAGE		|OS+rootfs 		|Y
|RECOVERY	|OS+rootfs (+TSBL)	|N
|=========================================

NOTE: The recovery image could incorporate a TSBL, or
if not it *must* be reliant on *not* requiring one.


 Call sequence
--------------
The FSBL is located in the on-chip SRAM. It does not use DDR memory for its
own purposes but does copy data over to it for use by the SSBL. After FSBL
jumps to SSBL, the SSBL can then decide which TSBL to load and run. SSBL/TSBL
won't fit into SRAM so typically the TSBL uses a non-overlapping (with respect
to SSBL) area of DDR memory. Once TSBL is running, the SSBL memory area may be
recovered, though caveats may apply if other memory used by SSBL is not also
relocated (see the "SSBL memory usage" section below).

[width="30%"]
|========================
|Order	|Binary	|Location
|1	|FSBL	|SRAM
|2	|SSBL	|DDR
|3	|TSBL	|DDR
|4	|Linux	|DDR
|========================


 SSBL memory usage
------------------
As well as executable code and data that the compiler generates to make the
final SSBL binary, there are other data areas that are present in DDR memory.

.Typical SSBL layout in DDR
[options="header", width="90%"]
|=======================================================================================================================================
|Type                        |Data type        |cfg file or generated defines                                  |Range (typ)
|FSBL info area              |struct fsbl_info |SSBL_BOARDINFO, SSBL_BOARDINFO_SIZE                            |0x06ffc000 - 0x07000000
|MMU 1st level page table    |ARM mmu          |SSBL_PAGE_TABLE, SSBL_PAGE_TABLE_SIZE                          |0x07000000 - 0x07004000
|MMU 2st level page table(s) |ARM mmu          |SSBL_PAGE_TABLE + SSBL_PAGE_TABLE_SIZE, SSBL_PAGE_TABLE_2_SIZE |0x07004000 - 0x07008000
|SSBL                        |compiled code+data        |SSBL_RAM_ADDR, SSBL_SIZE                              |0x07008000 - 0x07078000
|HEAP                        |data             |SSBL_RAM_ADDR+SSBL_SIZE, HEAP_SIZE                             |0x07100000 - 0x09100000
|STACK                       |data             |SSBL_RAM_ADDR+SSBL_SIZE+HEAP_SIZE, STACK_SIZE                  |0x09100000 - 0x09200000
|=======================================================================================================================================

.Other areas
[options="header", width="100%"]
|=======================================================================================================================================
|Type         | Data type         |cfg file or generated defines                                                   |Range (typ)
|SPLASH       |data               |Top of DDR memory                                                               |
|PSCI         |compiled code+data |PSCI_BASE, PSCI_BASE+PSCI_SIZE                                                  |0x06400000 - 0x06410000
|64 bit Linux |compiled code+data |BOOT_START_ADDRESS/BOOT_START_ADDRESS_ZIMAGE, BOOT_START_ADDRESS+BOOT_AREA_SIZE |0x00080000 - 0x02080000
|32 bit Linux |compiled code+data |BOOT_START_ADDRESS, BOOT_START_ADDRESS+BOOT_AREA_SIZE                           |0x00008000 - 0x02008000
|=======================================================================================================================================

 FSBL info area
~~~~~~~~~~~~~~~ 
This area is populated by the FSBL and consists of build and runtime
configuration and a list of available boards, all for use by the SSBL.

 MMU areas
~~~~~~~~~~
This is where the ARM page tables are located. The FSBL is responsible
for setting up the basic page tables. SSBL may then further modify them.

 SSBL, HEAP and STACK
~~~~~~~~~~~~~~~~~~~~~
The SSBL binary is loaded and it then sets up the HEAP and STACK.

 Splash
~~~~~~~
If enabled, splash picture and audio memory are allocated by the SSBL or TSBL
from the top of (32 bit address mode) visible memory downwards.

Some memory controllers split the DDR into 32 bit visible and LPAE/40 bit memory
section so BOLT can see a portion of each for the SHMOO (memsys) process even
though the actual memory on board is more than a 32 bit address can access.
32 bit Linux, which if LPAE support is enabled, can see all available DDR memory.
64 bit Linux can naturally see all DDR memory.

 PSCI
~~~~~
If PSCI is supported then the TSBL could load a new version over the original
SSBL version.

If the PSCI is relocated by the TSBL then VBAR_EL3 (64 bit system
bootstrap) or MVBAR (32 bit system bootstrap) has to be updated to point to the
new PSCI.

NOTE: For an aarch64 boot mode VBAR_EL3 can only be accessed at EL3. The old PSCI
code has to be modified with an extra function (or some other code overlaid at the
original PSCI base address) for a new value of VBAR_EL3 to be successfully set.
See: http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.ddi0500e/CIHHJABD.html

NOTE: For an aarch32 boot mode MVBAR should be set like VBAR_EL3 is in the 64 bit code,
though you can do it if the cpu is running in EL1 secure mode. MVBAR should never be set
if EL3 is in aarch64 mode.

 Making a TSBL
--------------
As previously indicated we can use the SSBL codebase to implement a TSBL. There are
two parts to this: (a) Implement some SSBL source code changes so SSBL can
pass control over to TSBL, (b) Edit build time variables so the SSBL can run
elsewhere in memory as a TSBL.

The process is to build BOLT twice. Once to get the primary FSBL+SSBL i.e. BOLT,
then build again after editing build time variables to get ssbl.bin which will
now be the TSBL.

For a TSBL it must be decided if the other non-SSBL areas are required to be moved or
the original ones just referenced. 

The other areas (FSBL info area, MMU page tables) may have to be moved
e.g. because Linux may be loaded over the SSBL location, and such could
happen if a very large Linux initrd is required and this was not factored
into the original system design, i.e. the SSBL was not located higher in
memory. You also could have have been supplied with an FSBL binary but not
the source code to effect a change at where the FSBL info area should be 
placed.

 Process checklist
~~~~~~~~~~~~~~~~~~
* Map out and make sure you know where everything in memory is supposed to go.
** Make sure no specified memory regions overlap, unless this is intended.
** Where in memory should the TSBL be located?
* Is SSBL properly shut down before jumping to the TSBL?
** All device drivers in SSBL should be shutdown and any
other activity (e.g. DMA) stopped before launching the TSBL. Failure
to do so may cause system instability and/or crashes.
* Does the FSBL info area need to be relocated?
* Do the MMU page tables need to be relocated?
* Have fixups (e.g. pointer references, individual MMU page entries) been done
for relocated items?
** Is another 4KiB secondary page table required for TSBL code? (see:
 'set_ssbl_page()' in 'ssbl/arch/ssbl_main.c')
* Is PSCI going to be upgradable, i.e. loaded by TSBL?
* Is the splash screen in SSBL, TSBL or both?

 Worked example
----------------
We'll use a BCM7271A0 BOLT v1.21 source tree and modify it so the
TSBL will use the existing FSBL info area, MMU and load PSCI
instead of SSBL.

 SSBL build
~~~~~~~~~~~
 Differentiating SSBL Vs. TSBL builds
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
Add a build time flag so we can tell the code what we intend
to make.

.config/layout-zeus42-stub.cfg
[source,diff]
----
@@ -71,6 +71,7 @@ gset SSBL_PAGE_TABLE_2_SIZE  0x400
 gset SSBL_PAGE_TABLE_2       $SSBL_PAGE_TABLE+$SSBL_PAGE_TABLE_SIZE
 gset SSBL_PAGE_TABLE_2_SRAM  $SSBL_PAGE_TABLE_2+$SSBL_PAGE_TABLE_2_SIZE
 gset SSBL_RAM_ADDR           0x07008000
+gset IS_TSBL                 0
 
 #  BOLT currently uses a 32 bit memory space
 # and the 'device' (ebi & rdb) regions span
----

 SSBL entry point
^^^^^^^^^^^^^^^^^
The FSBL jumps to the very start of the SSBL binary image with ARM register 'r0'
containing the address of 'struct fsbl_info'.

To make our TSBL we'll need to modify SSBL to be able to pass
'struct fsbl_info' to TSBL was well. Below is a patch that
adds 'struct fsbl_info' to the 'bolt_launch()' function - which
is part of the core BOLT loader code. This means we can use 
it via the 'boot' command or in code via the 'bolt_boot()'
function.

WARNING: Please use the 'bolt_boot()' API call for booting
a TSBL as we get the benefit of proper SSBL shutdown,
which is important for system stability. Just jumping
directly from SSBL to TSBL is *not recommended*.

.ssbl/arch/arm-launch.S
[source,diff]
----
@@ -35,11 +35,11 @@ DECLARE_INITVAR(mem_textreloc)
 # r0 - start address for jump
 # r1 - architecture i.d.  (0)
 # r2 - ATAGS pointer (unused.) ATAGS can be at addr 0x100 as well. (0)
 #     Default for BOLT is DTB only, we don't support ATAGS.
 #
-# r3 is unused
+# r3 - is fsbl_info, to be loaded into r0 before boot.
 
 ENTRY_PROC(bolt_launch)
 	/* use SRAM stack as this goes bye-bye on pop.
 	 we could also save into other registers...
 	 if careful!
@@ -48,15 +48,18 @@ ENTRY_PROC(bolt_launch)
 	push	{r0-r3}
 	bl		clear_all_d_cache
 	pop	{r4-r7}
 	bl		invalidate_all_i_cache
 	bl		disable_caches
-	mov	r0, r4
+	# In case we're booting a 3rd stage SSBL (TSBL)
+	# put r3 (struct fsbl_info *) into r0
+	# as it needs that info, Linux should ignore r0.
+	mov	r0, r7
 	mov	r1, r5
 	mov	r2, r6
 	mov	r3, r7
-	mov 	pc, r0
+	mov	pc, r4
 END_PROC(bolt_launch)
 
 ENTRY_PROC(bolt_launch_bsu)
 	push	{lr}
 	push	{r0-r3}
----

NOTE: Normally ARM register 'r3' is unused in BOLT and not currently important
for Linux startup.

Now we need to wire up the 'board_info()' function (which returns a pointer to
'struct fsbl_info') into 'bolt_start()' - which eventually calls 'bolt_launch()'.

BOLT is designed so that non-code areas of memory are marked with the ARM "XN"
page table flag bit to avoid problems with prefetching and executing memory
it should not be allowed to. TSBL will be loaded into an area of non-executable
memory so we have to remove the "XN" bit to avoid generating an ARM exception
or other type of protection fault.

As noted in the comments in the patch below you should align the TSBL so
it starts on a MMU page boundary.

.ssbl/main/boot.c
[source,diff]
----
@ -202,14 +202,35 @@ int bolt_go(bolt_loadargs_t *la)
 	 */
 #ifdef STUB64_START
 	if (!(la->la_flags & LOADFLG_DIRECT_CALL))
 		return psci_boot(la->la_flags, la->la_entrypt, p.dt_address);
 #endif
+	{
+		unsigned int base = ALIGN_TO(la->la_entrypt, _MB(1));
+		unsigned int size =
+			ALIGN_UP_TO(la->la_entrypt + la->la_maxsize - base,
+				_MB(1));
+		/*
+		 * Inform user as a double check on where
+		 * its expecting the executable code to be.
+		 */
+		xprintf("Mark executable: %x - %x\n", base, base + size);
+
+		/*
+		 * This could be for TSBL or Linux. You should align a
+		 * TSBL to a SECTION (1MiB) address unless you make a
+		 * new 2nd level table with 4KiB entries to mark only
+		 * TSBL code as executable (as SSBL does for itself),
+		 * which would be preferable if ITCH is enabled.
+		 */
+		arch_mark_executable(base, size, true);
+	}
+
 	bolt_set_aon_bootmode(0); /* Used for S3 to say how we first booted. */
 	xprintf("32 bit direct boot...\n");
 	bolt_start(la->la_entrypt, 0xffffffff,
-		(unsigned int)p.dt_address, 0);
+		(unsigned int)p.dt_address, (unsigned long)board_info());
 
 	/* In the remote event a non-BSU app saved
 	 * BOLT state for a return.
 	 */
 	return BOLT_OK;
----


 Differences in SSBL Vs. TSBL startup
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

For our case where we are using the existing MMU page tables
in generic BOLT (no security) we don't need to do anything
extra for TSBL apart from marking memory used by PSCI as
executable and uncached.

If an extra 4KiB secondary page table is required to cover
the TSBL .text segment more modifications would have to be
done, see: 'set_ssbl_page()' in 'ssbl/arch/ssbl_main.c'.

.ssbl/arch/ssbl_main.c
[source,diff]
----
@@ -241,11 +241,11 @@ static void set_ssbl_page(uint32_t *pt_1st, uint32_t _fdata)
 	/* remove XN from code area */
 	arch_mark_executable(SSBL_RAM_ADDR, _fdata-SSBL_RAM_ADDR, true);
 }
 
 
-#ifdef STUB64_START /* aarch64/smm(smc) & PSCI32 support */
+#if defined(STUB64_START) && IS_TSBL
 
 /* Use the pre-processor to stringify the name
 */
 #define _SMM_VAR(odir, modname) _binary_ ## odir ## _smm_64_bin_ ## modname
 #define SMM_VAR(odir, modname) _SMM_VAR(odir, modname)
@@ -305,18 +305,37 @@ void ssbl_main(uint32_t _end, uint32_t _fbss, uint32_t _ebss, uint32_t _fdata)
 		sec_enable_debug_ports();
 
 	puts("PINMUX");
 	board_pinmux();
 
+	/*
+	 * For TSBL just turn on the MMU as the page tables have
+	 * already been setup for us by the 2nd stage SSBL.
+	 */
+	if (IS_TSBL) {
+		__puts("TSBL @ ");
+		writehex(SSBL_RAM_ADDR);
+		puts("");
+		goto third_stage_continue;
+	}
+
 	__noisy_flush_caches();
 
 	pt_1st = (uint32_t *)get_pagetable_location();
 	supplement_fsbl_pagetable(pt_1st);
 	/* The whole DDR area was marked XN by FSBL, or assured by
 	 * supplement_fsbl_pagetable().
 	 */
-#ifdef STUB64_START
+	arch_mark_executable(SRAM_ADDR, SRAM_LEN, false);
+	set_ssbl_page(pt_1st, _fdata);
+
+third_stage_continue:
+	__puts("MMU ");
+	enable_caches();
+	puts("ON");
+
+#if defined(STUB64_START) && IS_TSBL
 	__puts("CLR PSCI MEM @ ");
 	writehex(PSCI_BASE);
 	memset((void *)PSCI_BASE, 0, PSCI_SIZE);
 	puts(" OK");
 
@@ -333,17 +352,10 @@ void ssbl_main(uint32_t _end, uint32_t _fbss, uint32_t _ebss, uint32_t _fdata)
 	arch_mark_uncached(PSCI_BASE,  SECTION_SIZE);
 	puts(" OK");
 
 	dsb(); /* make sure its there before we call it */
 #endif
-	arch_mark_executable(SRAM_ADDR, SRAM_LEN, false);
-	set_ssbl_page(pt_1st, _fdata);
-
-	__puts("MMU ");
-	enable_caches();
-	puts("ON");
-
 	__noisy_flush_caches();
 
 	mem_bottomofmem = (unsigned long)_fsbl_info;
 	__puts("_fbss  "); writehex(_fbss); puts("");
 	__puts("_ebss  "); writehex(_ebss); puts("");
----

 PSCI
^^^^^
The penultimate step before we build the primary BOLT is to prevent calling
PSCI from the SSBL.

.ssbl/main/psci.c
[source,diff]
----
@@ -23,6 +23,9 @@ void bolt_psci_init(void)
 #ifdef STUB64_START
        unsigned long b0, r0, r1;
 
+       if (!IS_TSBL)
+               return;
+
        /* TBD: get nr_* from the RDB e.g. HIF_CONTINUATION or
         * HIF_CPUBIUCTRL_CPU_RESET_CONFIG_REG. We can then use it
         * for the EL3 stack calcs in 'calc_per_cpu_stack'
@@ -54,6 +57,9 @@ void bolt_psci_init(void)
 int psci_boot(unsigned int la_flags, long la_entrypt, void *dt_address)
 {
 #ifdef STUB64_START
+       if (!IS_TSBL)
+               return BOLT_ERR;
+
        if (la_flags & LOADFLG_APP64) {
                bolt_set_aon_bootmode(S3_FLAG_PSCI_BOOT | S3_FLAG_BOOTED64);
                xprintf("64 bit PSCI boot...\n");
----

.ssbl/ui/ui_misccmds.c
[source,diff]
----
@@ -178,6 +178,9 @@ static int ui_cmd_psci(ui_cmdline_t *cmd, int argc, char *argv[])
        const char *x;
        unsigned long r0_back, r0, r1 = 0, r2 = 0, r3 = 0;
 
+       if (!IS_TSBL)
+               return BOLT_ERR;
+
        /* Only r0 is required, the rest
         * depends on the feature requested.
         */
----


Now the primary BOLT can be built. After flashing the binary and rebooting
it should start up OK, but without any PSCI initialization messages.

 TSBL build
~~~~~~~~~~~

 Relocating the SSBL
^^^^^^^^^^^^^^^^^^^^

The TSBL should be placed at a location where it will not interfere
with anything else. Using the BOLT 'info' command we get a mostly
complete picture (excluding SPLASH, PSCI and flash staging buffer)
of what SSBL uses.

----
BOLT> info
========================================================================
     CPU speed: 1503MHz
DDR0 Frequency: 1600MHz, 8Gx16 phy:32   80000000 @ 00000000
DDR0 Actual frequency: 1590MHz, ratio 0.993
  Total memory: 2048MB
   Boot Device: SPI
SDIO:
 controller 0, TYPE: NODEVICE
 controller 1, TYPE: EMMC

BSP version: '4.1.5'
Total memory used by BOLT: 0x06FFC000 - 0x09200000 (35667968)
FSBL info area:            0x06FFC000 - 0x06FFC044 (68)
Page table base:           0x07000000
Text (code) segment:       0x07008100 - 0x07034000 (179968)
Initialized Data:          0x07034000 - 0x07053588 (128392)
BSS Area:                  0x07053588 - 0x07054D80 (6136)
Local Heap:                0x07100000 - 0x09100000 (33554432)
Stack Area:                0x09100000 - 0x09200000 (1048576)

BOLT driver build information:
LDR:     ELF   1; RAW   1; SREC  1; ZIMG  1
UI:      LEVEL 3; MIN   0
FS:      FAT   1; FAT32 1
NET:     STACK 1; ENET  1; TCP   1
USB:     STACK 1; ETH   1; DISK  1; SERIAL   1; HID 1
FLASH:   NAND
========================================================================
*** command status = 0
----

SSBL spans 0x06FFC000 to 0x09200000. Let us select 0x09300000 as the
TSBL base address and enable the TSBL build.

.config/layout-zeus42-stub.cfg
[source,diff]
----
@@ -70,7 +70,8 @@ gset SSBL_PAGE_TABLE_SIZE    0x4000
 gset SSBL_PAGE_TABLE_2_SIZE  0x400
 gset SSBL_PAGE_TABLE_2       $SSBL_PAGE_TABLE+$SSBL_PAGE_TABLE_SIZE
 gset SSBL_PAGE_TABLE_2_SRAM  $SSBL_PAGE_TABLE_2+$SSBL_PAGE_TABLE_2_SIZE
-gset SSBL_RAM_ADDR           0x07008000
+gset SSBL_RAM_ADDR           0x09300000
-gset IS_TSBL                 0
+gset IS_TSBL                 1
 
 #  BOLT currently uses a 32 bit memory space
 # and the 'device' (ebi & rdb) regions span
----

After re-making BOLT the TSBL is the file 'objs/7271a0/ssbl.bin'

 Booting TSBL
~~~~~~~~~~~~~

The TSBL can be booted programmatically, or from the BOLT commandline
which is handy during development.

 Example TSBL boot
^^^^^^^^^^^^^^^^^^
----
BOLT> boot -nopsci -raw -addr=0x09300000 -max=0x70000 192.168.0.42:ssbl.bin
100 Mbps Full-Duplex
Device eth0:  hwaddr 00-10-18-AD-C3-03, ipaddr 192.168.0.32, mask 255.255.255.0
        gateway not set, nameserver not set, domain localdomain
        DHCP server 192.168.0.42, DHCP server MAC 00-50-B6-4E-0B-71
Loader:raw Filesys:tftp Dev:(null) File:192.168.0.42:ssbl.bin Options:(null)
..............
Closing network 'eth0'
Starting program at 0x9300000 (DTB @ 0x771e000)

Mark executable: 9300000 - 9400000
32 bit direct boot...
SSBL
SEC: jtag debug status: 000000af
PINMUX
TSBL @ 09300000
MMU ON
CLR PSCI MEM @ 06400000 OK
INSTALL psci32@06400000 OK
CACHE FLUSH OK
_fbss  0934b528
_ebss  0934cd00
_end   0934cd20
HEAP @ 09400000
STACK @ 0b500000
ARCH: CONFIG OK
CLR BSS 0934b528 to 0934cd00 OK
CLR SRAM  OK
CACHE FLUSH OK
CPU CLKSET OK
GO!
PSCI: Init...
PSCI: config @ 06401b00 cpus:4 cpu idx:0
cpu 0 state:5
cpu 1 state:0
cpu 2 state:0
cpu 3 state:0
PSCI: v0.2
...
...
...
AUTOBOOT [waitusb -t=0 -d='USB Disk' && batch usbdisk0:sysinit.txt]
USB device matching <USB Disk> not found!
BOLT>
----

The 'info' command shows that we really are in the TSBL as it
spans 0x09300100 to 0x0B500000. Note that the 'FSBL info area'
and 'Page table base' have not changed from SSBL.

----
BOLT> info
========================================================================
     CPU speed: 1503MHz
DDR0 Frequency: 1600MHz, 8Gx16 phy:32   80000000 @ 00000000
DDR0 Actual frequency: 1590MHz, ratio 0.993
  Total memory: 2048MB
   Boot Device: SPI
SDIO:
 controller 0, TYPE: NODEVICE
 controller 1, TYPE: EMMC

BSP version: '4.1.5'
Total memory used by BOLT: 0x06FFC000 - 0x0B500000 (72368128)
FSBL info area:            0x06FFC000 - 0x06FFC044 (68)
Page table base:           0x07000000
Text (code) segment:       0x09300100 - 0x0932C000 (179968)
Initialized Data:          0x0932C000 - 0x0934B528 (128296)
BSS Area:                  0x0934B528 - 0x0934CD20 (6136)
Local Heap:                0x09400000 - 0x0B400000 (33554432)
Stack Area:                0x0B400000 - 0x0B500000 (1048576)

BOLT driver build information:
LDR:     ELF   1; RAW   1; SREC  1; ZIMG  1
UI:      LEVEL 3; MIN   0
FS:      FAT   1; FAT32 1
NET:     STACK 1; ENET  1; TCP   1
USB:     STACK 1; ETH   1; DISK  1; SERIAL   1; HID 1
FLASH:   NAND
========================================================================
*** command status = 0
BOLT>
----

 TSBL booting Linux
^^^^^^^^^^^^^^^^^^^

TSBL can boot Linux, just like the original BOLT SSBL.

.Example
----
BOLT> boot 192.168.0.42:vmlinuz-initrd-7271a0-32
100 Mbps Full-Duplex
Device eth0:  hwaddr 00-10-18-AD-C3-03, ipaddr 192.168.0.32, mask 255.255.255.0
        gateway not set, nameserver not set, domain localdomain
        DHCP server 192.168.0.42, DHCP server MAC 00-50-B6-4E-0B-71
Loader:zimg Filesys:tftp Dev:(null) File:192.168.0.42:vmlinuz-initrd-7271a0-32 Options:(null)
Reading 8082328 bytes from zImage...........
Closing network 'eth0'
Starting program at 0x8000 (DTB @ 0x9a1e000)

32 bit PSCI boot...
PSCI: DTB @ 09a1e000, Linux entry @ 00008000
...
...
...
----

 TSBL and S3
------------
The path from an S3 warm boot back to Linux is from the FSBL
(via PSCI if it exists) to the Linux re-entry vector. TSBL
is not involved at all, at least directly.

If a fixup between wakeup and Linux is required e.g. to fix a bug,
then the TSBL can be used indirectly if it is responsible for
loading PSCI, as PSCI could be patched with the bugfix instead.
This means Linux need not be hacked with difficult to maintain
patch sets. 

NOTE: PSCI is currently only present in BOLT for 64 bit cpus
at the moment.

 An example of calling the 'bolt_boot()' function
-------------------------------------------------

Below is some demo code on how to load a binary blob from flash.
This does not include any signature checks or decryption  - which
should be factored into a real products design.

[source,c]
----
/*
 * Demo load from a reference board flash.
 * flash0.kernel  SPI flash @ CS0: 0x00120000-0x00F70000 (15MB)
 */
#define	LOADER_IMAGE_PARTITION	"flash0.kernel"
#define	LOADER_IMAGE_MEM_ADDR	(SSBL_RAM_ADDR)
#define	LOADER_IMAGE_LEN	(SSBL_SIZE)

void custom_main(void)
{
	int rc;
	bolt_loadargs_t la;

	la.la_filename	= NULL;
	la.la_filesys	= "raw";
	la.la_device	= LOADER_IMAGE_PARTITION;
	la.la_options	= NULL; /* no cmdline "chosen" args */
	la.la_flags	= LOADFLG_EXECUTE | LOADFLG_SPECADDR | LOADFLG_DIRECT_CALL;
	la.la_offs	= 0;
	la.la_address	= LOADER_IMAGE_MEM_ADDR;
	la.la_maxsize	= LOADER_IMAGE_LEN;
	la.la_entrypt	= LOADER_IMAGE_MEM_ADDR;

	rc = bolt_boot("raw", &la);
	err_msg("failed to boot TSBL, error = %d", rc);
}
----

NOTE: On BOLT builds with PSCI the 'LOADFLG_DIRECT_CALL' flag added
to 'la.la_flags' above prevents booting the code via PSCI, which
is the default boot method. Booting via PSCI would also start us in
HYP instead  of SVC mode and for TSBL would also mess up passing
'struct fsbl_info' properly.



 Device Tree only changes
-------------------------

This can be an alternative or additional to TSBL.

If a new Linux version requires a Device Tree different in some way to that provided by the
original bootloader and there are *no other changes at all* required of the bootloader then
the Linux CONFIG_ARM_APPENDED_DTB configuration
footnote:[link:porting_bolt_to_customer_platforms.html#_building_linux_with_an_appended_dtb[]]
could be used. This does currently require porting the BOLT code (specifically, the SSBL) to
your platform to be able to generate the new Device Tree via the "dt bolt;dt show" command
pair, though you don't have to ship the code - just the generated Device Tree appended to
a Linux binary.

NOTE: Even though an appended DTB may seem to require less initial effort, it lacks the future
proofing flexibility of the TSBL solution that can run code as well as providing a Device Tree.
Choose carefully, _very_ carefully!

Appendix: Copyright Info
------------------------

Copyright (C) 2016, Broadcom Ltd.
All Rights Reserved.
Confidential Property of Broadcom Ltd.

