/*
=========================================================================
     Broadcom Proprietary and Confidential.
     Copyright (c), 2016. All rights reserved.

  THIS SOFTWARE MAY ONLY BE USED SUBJECT TO AN EXECUTED SOFTWARE LICENSE
  AGREEMENT BETWEEN THE USER AND BROADCOM.  YOU HAVE NO RIGHT TO USE OR
  EXPLOIT THIS MATERIAL EXCEPT SUBJECT TO THE TERMS OF SUCH AN AGREEMENT.
=========================================================================

automatically generated file : memsys_top_api.h
DO NOT EDIT
(Any changes will be automatically overwritten!!)

Generation Date:    Tue Nov 15 18:26:45 EST 2016

Generated By:       generate_top_api.pl 
Generator version:  2.6

Description:
  Memsys Library Public API

=========================================================================
*/
#ifndef MEMSYS_TOP_API_H__
#define MEMSYS_TOP_API_H__

/* 
 * Note the following data types need to be specified ahead of this header.
 *    uint32_t   - 32-bit unsigned integer type
 *    uint8_t    - 8-bit unsigned integer type
 */

#ifdef __cplusplus
extern "C" {
#endif

/*
 * Memsys Library Version
 *
 * This is a 32-bit word to identify Memsys Library version. Fields are:
 *
 * Bits [31:24] MEMSYS_FW_VERSION_MAJOR : Major version number
 *                                        (incompatible changes)
 * Bits [23:16] MEMSYS_FW_VERSION_MINOR : Minor version number
 *                                        (backwards-compatible new features)
 * Bits [15:08] MEMSYS_FW_VERSION_PATCH : Patch number
 *                                        (backwards-compatible bug fixes)
 * Bits [07:00] MEMSYS_FW_VERSION_ENG   : Engineering drop number
 *                                        (internal debug, 0=non-engineering)
 *
 * The Memsys Library Version can be used to track API changes.
 * There will be more version changes than actual API version changes.
 * Please read the release notes to see which version changed API, and whether
 * new MCBs are required or not.
 *
 * Minor version number tracks changes that are compatible with earlier
 * versions. For instance, a previously unused option bit now has meaning,
 * or an additional error code is added. The patch number is reset to 0 when
 * minor version changes. If minor version changes, but not major, both of
 * the following conditions are met:
 *   1. Existing user code can use either the old or the new API, without
 *      breaking any existing functionalities. This means code written for
 *      v1.0.0.0 will continue to work the same way with v1.3.0.0 library.
 *   2. New user code that utilizes the new API will also work using the old
 *      API, except new functionalities will not be available. This means code
 *      written for v1.3.0.0 will still work with v1.0.0.0 library,
 *      however features introduced after v1.0.0.0 will not be available.
 * 
 * Major version number tracks changes that are incompatible with earlier
 * versions. For example, the meaning of an existing option bit is changed,
 * or adding a new field to a struct. Both minor and patch numbers set to 0
 * when major version changes.
 *
 * Note major version may change without any changes to the API, such as when
 * MCB become incompatible, and user need to get new MCBs. Incompatible API
 * change will always trigger the library's major version number to change,
 * and whenever there is compatible API change, the library's minor version
 * number will also change.
 *
 * Patch number tracks backward compatible bug fixes.
 *
 * A non-zero engineering drop number means the library is for internal
 * debug and testing purposes only.
 */
#define MEMSYS_FW_VERSION_MAJOR_SHIFT       24
#define MEMSYS_FW_VERSION_MINOR_SHIFT       16
#define MEMSYS_FW_VERSION_PATCH_SHIFT       8
#define MEMSYS_FW_VERSION_ENG_SHIFT         0
    
#define MEMSYS_FW_VERSION_MAJOR             5
#define MEMSYS_FW_VERSION_MINOR             4
#define MEMSYS_FW_VERSION_PATCH             9
#define MEMSYS_FW_VERSION_ENG               0
    
#define MEMSYS_FW_VERSION                                         \
    ((MEMSYS_FW_VERSION_MAJOR << MEMSYS_FW_VERSION_MAJOR_SHIFT) | \
     (MEMSYS_FW_VERSION_MINOR << MEMSYS_FW_VERSION_MINOR_SHIFT) | \
     (MEMSYS_FW_VERSION_PATCH << MEMSYS_FW_VERSION_PATCH_SHIFT) | \
     (MEMSYS_FW_VERSION_ENG   << MEMSYS_FW_VERSION_ENG_SHIFT))

/*
 * Helper for Memsys Library users to perform API feature checks. e.g.,
 * if API feature Z is only available on version >= major.minor.patch.eng
 *
 * #if (MEMSYS_VERSION_IN_API_FILE_IS_THIS_OR_MORE(major, minor, patch, eng))
 *  enable_API_feature_Z
 * #endif
 */
#define MEMSYS_VERSION_IN_API_FILE_IS_THIS_OR_MORE(major, minor, patch, eng) \
    (MEMSYS_FW_VERSION >=                                               \
     (((major) << MEMSYS_FW_VERSION_MAJOR_SHIFT) |                      \
      ((minor) << MEMSYS_FW_VERSION_MINOR_SHIFT) |                      \
      ((patch) << MEMSYS_FW_VERSION_PATCH_SHIFT) |                      \
      ((eng) << MEMSYS_FW_VERSION_ENG_SHIFT)))
     
/*
 * memsys_version_t
 *   Memsys Library version data structure
 *
 *   version - Memsys Library version, same as MEMSYS_FW_VERSION.
 *   build_ver - A string showing internal build information such as source
 *       code revision. Note this is a pointer to a global address. This
 *       pointer may be NULL.
 *   hw_ver_str - A string showing the HW combo (PHY + MEMC) this library
 *       supports, for example, "hpf0_b1p3". Note this is a pointer to a
 *       global address. This pointer may be NULL.
 *   ver_str - Version string. This is a human readable string of the library
 *       version, e.g. "1.0.0.0". Note this is a pointer to a global address.
 *       This pointer may be NULL to prevent external output of version info.
 */
typedef struct memsys_version
{
    uint32_t version;           // MEMSYS_FW_VERSION
    const char * build_ver;     // Internal build version string
    const char * hw_ver_str;    // HW version this library supports (string)
    const char * ver_str;       // library version string
} memsys_version_t;
     
/*
 * memsys_system_callbacks_t
 *   Helper functions provided by the system (i.e., boot loader)
 *
 * putchar - Output a single character to console. This will be used to display
 *     debug information (shmoo output) and should be implemented. The output
 *     should have as little buffering delay as possible. This function may be
 *     NULL to prevent any output. This function should return 0 on success
 *     and non-zero on failure.
 *
 * getchar - Get a single character from console. If blocking_on_non_zero
 *     parameter is set to a non-zero value, this function is blocking and
 *     should wait forever for user input, a return value of 0 or less will be
 *     interpreted as error. If blocking_on_non_zero is set to zero, this
 *     function is non-blocking, and it will return user input if it exist, or
 *     zero if no input. This is an optional debug function and can be NULL.
 */
typedef struct memsys_system_callbacks
{
    int      (*putchar)(char c);            // required for debug
    char     (*getchar)(int blocking_on_non_zero); // optional
} memsys_system_callbacks_t;
     
/*
 * Memsys run-time option flags.
 *   bit  [0]   1 = Normal console print disabled
 *   bit  [1]   Reserved, set to 0
 *   bit  [2]   1 = Warm boot, 0 = Cold boot
 *   bit  [3]   Reserved, set to 0
 *   bit  [4]   1 = Skip shmoo
 *   bit  [5]   Reserved, set to 0
 *   bit  [6]   1 = Skip MEMC init
 *   bit  [7]   1 = Skip PHY init
 *   bit  [8]   1 = Skip PHY DRAM init
 *   bit  [9]   1 = Skip PHY PLL init
 *   bit [10]   1 = Save PHY state at end of memsys_top
 *   bit [11]   1 = Prepare PHY for standby entry
 *   bit [12]   1 = PHY placed in low power mode when in standby
 *   bits[16:13]  Number of ranks to use, zero-based. For example,
 *                    0 = one rank,
 *                    1 = two ranks,
 *                    2 = three ranks (not likely),
 *                    3 = four ranks, etc.
 *                Setting this value to 14 will use the maximum number
 *                of ranks supported by the MCB.
 */
typedef enum memsys_top_options
{
    MEMSYS_OPTION_CONSOLE_OUTPUT_DISABLED   = (1 << 0),    // 0x00000001
    MEMSYS_OPTION_WARM_BOOT                 = (1 << 2),    // 0x00000004
    MEMSYS_OPTION_SKIP_SHMOO                = (1 << 4),    // 0x00000010
    MEMSYS_OPTION_SKIP_MEMC_INIT            = (1 << 6),    // 0x00000040
    MEMSYS_OPTION_SKIP_PHY_INIT             = (1 << 7),    // 0x00000080
    MEMSYS_OPTION_SKIP_PHY_DRAM_INIT        = (1 << 8),    // 0x00000100
    MEMSYS_OPTION_SKIP_PHY_PLL_INIT         = (1 << 9),    // 0x00000200
    MEMSYS_OPTION_SAVE_PHY_STATE            = (1 << 10),   // 0x00000400
    MEMSYS_OPTION_PREP_PHY_FOR_STANDBY      = (1 << 11),   // 0x00000800
    MEMSYS_OPTION_PHY_LOW_POWER_AT_STANDBY  = (1 << 12),   // 0x00001000
    MEMSYS_OPTION_RANKS                     = (0xf << 13)  // 0x0001e000
} memsys_top_options_e;

/* Number of bits to shift number of ranks into options */
#define MEMSYS_OPTION_RANKS_SHIFT           13

/* Maximum number of ranks supported */
#define MEMSYS_MAX_RANKS                    4

/* Set number of ranks to this value to use the rank count from the MCB */
#define OBTAIN_RANK_COUNT_FROM_MCB         14

/*
 * Memsys Library Error Codes and Error Data Structure
 */
/*
 * List of memc error codes
 */
typedef enum memsys_error_memc
{
    MEMSYS_ERROR_MEMC_NONE              = 0,
    MEMSYS_ERROR_MEMC_POWER_UP_TIMEOUT,
    MEMSYS_ERROR_MEMC_MAX
} memsys_error_memc_e;

/*
 * List of phy error codes
 */
typedef enum memsys_error_phy
{
    MEMSYS_ERROR_PHY_NONE = 0,
    MEMSYS_ERROR_PHY_VDL_CALIB_NOLOCK,
    MEMSYS_ERROR_PHY_PLL_NOLOCK,
    MEMSYS_ERROR_PHY_MEMC_NODFIACK,
    MEMSYS_ERROR_PHY_MEMC_NODFIRELEASE,
    MEMSYS_ERROR_PHY_VDL_CALIB_BUS,
    MEMSYS_ERROR_PHY_EDC_NOLOCK,
    MEMSYS_ERROR_PHY_VTT_NOREADY,
    MEMSYS_ERROR_PHY_MAX
} memsys_error_phy_e;

/*
 * List of shmoo/memsys error codes
 */
typedef enum memsys_error_shmoo
{
    MEMSYS_ERROR_SHMOO_NONE    =    0,
    MEMSYS_ERROR_OVERALL_MCB_INVALID,                       // word 0: 0x00000002
    MEMSYS_ERROR_OVERALL_MCB_BAD_CHECKSUM,                  // word 0: 0x00000004
    MEMSYS_ERROR_OVERALL_PHY_MCB_INVALID,                   // word 0: 0x00000008
    MEMSYS_ERROR_OVERALL_PHY_MCB_BAD_VERSION,               // word 0: 0x00000010
    MEMSYS_ERROR_OVERALL_MEMC_MCB_INVALID,                  // word 0: 0x00000020
    MEMSYS_ERROR_OVERALL_MEMC_BAD_REG_BASE,                 // word 0: 0x00000040
    MEMSYS_ERROR_OVERALL_MEMC_MCB_BAD_VERSION,              // word 0: 0x00000080
    MEMSYS_ERROR_PSSR_BIG_BIT_LENGTH,                       // word 0: 0x00000100
    MEMSYS_ERROR_PSSR_NULL_PTR,                             // word 0: 0x00000200
    MEMSYS_ERROR_PSSR_BAD_ALT_ID,                           // word 0: 0x00000400
    MEMSYS_ERROR_PSSR_CHECKSUM,                             // word 0: 0x00000800
    MEMSYS_ERROR_PSSR_GLOBAL_COUNTER,                       // word 0: 0x00001000
    MEMSYS_ERROR_PSSR_UNEXPECTED_ALT_ENTRY,                 // word 0: 0x00002000
    MEMSYS_ERROR_PSSR_UNEXPECTED_FUNC_INDEX,                // word 0: 0x00004000
    MEMSYS_ERROR_PSSR_MEMC_TIMEOUT_ON_WARM_BOOT,            // word 0: 0x00008000
    MEMSYS_ERROR_SHMOO_ZQCAL_NO_P_LOW,                      // word 0: 0x00010000
    MEMSYS_ERROR_SHMOO_ZQCAL_NO_P_HIGH,                     // word 0: 0x00020000
    MEMSYS_ERROR_SHMOO_ZQCAL_NO_N_LOW,                      // word 0: 0x00040000
    MEMSYS_ERROR_SHMOO_ZQCAL_NO_N_HIGH,                     // word 0: 0x00080000
    MEMSYS_ERROR_SHMOO_ZQCAL_NO_SOLUTION,                   // word 0: 0x00100000         
    MEMSYS_ERROR_SHMOO_WR_LEVEL_TO_1,                       // word 0: 0x00200000        
    MEMSYS_ERROR_SHMOO_WR_LEVEL_NOT_CONVERGED,              // word 0: 0x00400000
    MEMSYS_ERROR_SHMOO_READ_ENABLE_FAILED,                  // word 0: 0x00800000
    MEMSYS_ERROR_SHMOO_READ_ENABLE_MEM_TEST_FAILED,         // word 0: 0x01000000
    MEMSYS_ERROR_SHMOO_READ_ENABLE_PEGGED_VDL,              // word 0: 0x02000000   
    MEMSYS_ERROR_SHMOO_RD_DQS_MEM_TEST_FAILED,              // word 0: 0x04000000     
    MEMSYS_ERROR_SHMOO_RD_DQS_NO_BYTE_PASS,                 // word 0: 0x08000000
    MEMSYS_ERROR_SHMOO_READ_DQS_PEGGED_VDL,                 // word 0: 0x10000000       
    MEMSYS_ERROR_SHMOO_WR_DQS_DQ_0,                         // word 0: 0x20000000       
    MEMSYS_ERROR_SHMOO_WR_DQS_DQ_1,                         // word 0: 0x40000000       
    MEMSYS_ERROR_SHMOO_WR_DQS_DQ_2,                         // word 0: 0x80000000       
    MEMSYS_ERROR_SHMOO_WR_DQS_MEM_TEST_FAILED,                  // word 1: 0x00000001    
    MEMSYS_ERROR_SHMOO_WR_DQS_PEGGED_VDL,                       // word 1: 0x00000002      
    MEMSYS_ERROR_SHMOO_WR_DM_TO_0,                              // word 1: 0x00000004      
    MEMSYS_ERROR_SHMOO_WR_DM_TO_1,                              // word 1: 0x00000008      
    MEMSYS_ERROR_SHMOO_WR_DM_TO_2,                              // word 1: 0x00000010
    MEMSYS_ERROR_SHMOO_WR_DM_TO_3,                              // word 1: 0x00000020       
    MEMSYS_ERROR_SHMOO_WR_DM_MEM_TEST_FAILED,                   // word 1: 0x00000040       
    MEMSYS_ERROR_SHMOO_WR_DM_PEGGED_VDL,                        // word 1: 0x00000080       
    MEMSYS_ERROR_SHMOO_PRINT_REPORT,                            // word 1: 0x00000100       
    MEMSYS_ERROR_SHMOO_FILTER,                                  // word 1: 0x00000200      
    MEMSYS_ERROR_SHMOO_ADDX_SHMOO_PEGGED_VDL,                   // word 1: 0x00000400     
    MEMSYS_ERROR_SHMOO_ADDX_SHMOO_MEM_TEST_FAILED,              // word 1: 0x00000800
    MEMSYS_ERROR_SHMOO_CA_TRAINING_FAILED,                      // word 1: 0x00001000
    MEMSYS_ERROR_SHMOO_GDDR5_ADDX_ALIGN_VDL_NOT_AT_CALIB,       // word 1: 0x00002000
    MEMSYS_ERROR_SHMOO_GDDR5_ADDX_ALIGN_PEGGED_VDL,             // word 1: 0x00004000  
    MEMSYS_ERROR_SHMOO_GDDR5_VENDOR_ID_ERROR,                   // word 1: 0x00008000 
    MEMSYS_ERROR_SHMOO_GDDR5_WCK2CK_ALIGN_SAMPLE_TO,            // word 1: 0x00010000 
    MEMSYS_ERROR_SHMOO_GDDR5_ADDX_TRAIN_ERROR,                  // word 1: 0x00020000   
    MEMSYS_ERROR_SHMOO_GDDR5_WCK2CK_INVALID_INITIAL_STATE,      // word 1: 0x00040000  
    MEMSYS_ERROR_SHMOO_GDDR5_WCK2CK_ALIGN_FAIL_CONVERGE,        // word 1: 0x00080000  
    MEMSYS_ERROR_SHMOO_GDDR5_WCK2CK_ALIGN_PEGGED_VDL,           // word 1: 0x00100000
    MEMSYS_ERROR_SHMOO_GDDR5_WCK2CK_FAILED_TO_DETECT_POLARITY,  // word 1: 0x00200000
    MEMSYS_ERROR_SHMOO_GDDR5_RD_EN_SHMOO_NO_LEFT_WINDOW,        // word 1: 0x00400000 
    MEMSYS_ERROR_SHMOO_GDDR5_RD_EN_SHMOO_NO_RIGHT_WINDOW,       // word 1: 0x00800000  
    MEMSYS_ERROR_SHMOO_GDDR5_READ_ENABLE_SHMOO_PEGGED_VDL,      // word 1: 0x01000000 
    MEMSYS_ERROR_SHMOO_GDDR5_INVALID_MRE_OPTIONS,               // word 1: 0x02000000    
    MEMSYS_ERROR_SHMOO_HP_RX_TRIM_TO_ERROR,                     // word 1: 0x04000000           
    MEMSYS_ERROR_SHMOO_HP_RX_TRIM_NO_RESULT,                    // word 1: 0x08000000          
    MEMSYS_ERROR_SHMOO_HP_RX_TRIM_INVALID_DDR_TYPE,             // word 1: 0x10000000
    MEMSYS_ERROR_SHMOO_DDR4_ADDX_ALIGN_PEGGED_VDL,              // word 1: 0x20000000
    MEMSYS_ERROR_OVERALL_INCOMPATIBLE_FW_VERSION,               // word 1: 0x40000000 
    MEMSYS_ERROR_OVERALL_PARAM_INVALID,                         // word 1: 0x80000000
    MEMSYS_ERROR_SHMOO_VTT_NOT_READY,                       // word 2: 0x00000001    
    MEMSYS_ERROR_FLOW_CONTROL_REGISTER_CALLBACKS,           // word 2: 0x00000002    
    MEMSYS_ERROR_FLOW_CONTROL_MEMSYS_BEGIN,                 // word 2: 0x00000004    
    MEMSYS_ERROR_FLOW_CONTROL_PRE_MEMC_INIT,                // word 2: 0x00000008    
    MEMSYS_ERROR_FLOW_CONTROL_PRE_SHMOO,                    // word 2: 0x00000010 
    MEMSYS_ERROR_FLOW_CONTROL_MEMSYS_END,                   // word 2: 0x00000020 
    MEMSYS_ERROR_SHMOO_DDR4_CS_SHMOO_PEGGED_VDL,            // word 2: 0x00000040 
    MEMSYS_ERROR_SHMOO_RD_DATA_DLY_WRONG_MODE,              // word 2: 0x00000080 
    MEMSYS_ERROR_SHMOO_RD_DATA_DLY_ERROR,                   // word 2: 0x00000100 
    MEMSYS_ERROR_OVERALL_INCOMPATIBLE_PHY_HW,               // word 2: 0x00000200 
    MEMSYS_ERROR_OVERALL_INCOMPATIBLE_MEMC_HW,              // word 2: 0x00000400 
    MEMSYS_ERROR_OVERALL_MCB_INVALID_DDR_TYPE,              // word 2: 0x00000800 
    MEMSYS_ERROR_OVERALL_UNSUPPORTED_DDR_WIDTH,             // word 2: 0x00001000 
    MEMSYS_ERROR_SHMOO_INVALID_CLK_SHIFT,                   // word 2: 0x00002000 
    MEMSYS_ERROR_SHMOO_MPR_READOUT_MEM_TEST_FAILED,         // word 2: 0x00004000
    MEMSYS_ERROR_SHMOO_MACH_INITIAL_ANGLE_MISMATCH,         // word 2: 0x00008000
    MEMSYS_ERROR_SHMOO_LP4_WL_FAILED,                       // word 2: 0x00010000
    MEMSYS_ERROR_SHMOO_LP4_WR_DQ_CAL_FAILED,                // word 2: 0x00020000
    MEMSYS_ERROR_SHMOO_LP4_ZQ_CAL_STARTS_AT_ZERO,           // word 2: 0x00040000
    MEMSYS_ERROR_SHMOO_LP4_ZQ_CAL_FAILED_TO_CONVERGE,       // word 2: 0x00080000
    MEMSYS_ERROR_SHMOO_LP4_VOH_CAL_BAD_INITIAL_CA,          // word 2: 0x00100000
    MEMSYS_ERROR_SHMOO_LP4_VOH_CAL_BAD_FINAL_CA,            // word 2: 0x00200000
    MEMSYS_ERROR_SHMOO_LP4_VOH_CAL_NOT_CONVERGED,           // word 2: 0x00400000
    MEMSYS_ERROR_SHMOO_LP4_CS_TRAINING_FAILED_TO_RAISE_CLK, // word 2: 0x00800000
    MEMSYS_ERROR_SHMOO_LP4_CS_TRAINING_FAILED_PHY_BIST,     // word 2: 0x01000000
    MEMSYS_ERROR_SHMOO_LP4_CS_TRAINING_FAILED_TO_LOWER_CLK, // word 2: 0x02000000
    MEMSYS_ERROR_SHMOO_LP4_CS_TRAINING_FAILED_MR_WR,        // word 2: 0x04000000
    MEMSYS_ERROR_SHMOO_LP4_CS_TRAINING_NO_EDGE_FOUND,       // word 2: 0x08000000
    MEMSYS_ERROR_SHMOO_LP4_CB_TRAINING_FAILED_TO_RAISE_CLK, // word 2: 0x10000000
    MEMSYS_ERROR_SHMOO_LP4_CB_TRAINING_FAILED_PHY_BIST,     // word 2: 0x20000000
    MEMSYS_ERROR_SHMOO_LP4_CB_TRAINING_FAILED_TO_LOWER_CLK, // word 2: 0x40000000
    MEMSYS_ERROR_SHMOO_LP4_CB_TRAINING_FAILED_MR_WR,        // word 2: 0x80000000
    MEMSYS_ERROR_SHMOO_LP4_DQ_VOH_MCP_WR_FAILED,                // word 3: 0x00000001
    MEMSYS_ERROR_SHMOO_LP4_DQ_VOH_ILLEGAL_VAL_AT_MIN_PD_STREN,  // word 3: 0x00000002
    MEMSYS_ERROR_SHMOO_LP4_DQ_VOH_ILLEGAL_VAL_AT_MAX_PD_STREN,  // word 3: 0x00000004
    MEMSYS_ERROR_SHMOO_LP4_FAILED_MR_WR,                        // word 3: 0x00000008
    MEMSYS_ERROR_SHMOO_LP4_FAILED_DELAYED_MR_WR,                // word 3: 0x00000010
    MEMSYS_ERROR_SHMOO_LP4_FAILED_DPFE_EDIS_CONFIG,             // word 3: 0x00000020
    MEMSYS_ERROR_SHMOO_LP4_FAILED_CMD_INJ_TRIGGER,              // word 3: 0x00000040
    MEMSYS_ERROR_SHMOO_LP4_FAILED_CMD_INJ_ARM,                  // word 3: 0x00000080
    MEMSYS_ERROR_SHMOO_LP4_FAILED_VDL_STEP,                     // word 3: 0x00000100
    MEMSYS_ERROR_SHMOO_LP4_FAILED_RD_DQ_PATTERN,                // word 3: 0x00000200
    MEMSYS_ERROR_SHMOO_LP4_RD_DQ_CAL_EDIS_TO,                   // word 3: 0x00000400
    MEMSYS_ERROR_SHMOO_LP4_RD_DQ_CAL_FAILED_FILTER,             // word 3: 0x00000800
    MEMSYS_ERROR_SHMOO_LP4_RD_DQ_CAL_FAILED_REPORT,             // word 3: 0x00001000
    MEMSYS_ERROR_SHMOO_LP4_WR_DQ_CAL_EDIS_TO,                   // word 3: 0x00002000
    MEMSYS_ERROR_SHMOO_LP4_WR_DQ_CAL_FAILED_REPORT,             // word 3: 0x00004000
    MEMSYS_ERROR_SHMOO_LP4_DPFE_SEQUENCER_REFRESH_FAILURE,      // word 3: 0x00008000
    MEMSYS_ERROR_SHMOO_LP4_RD_DMI_SHMOO_FAILED_EDIS_WR,         // word 3: 0x00010000
    MEMSYS_ERROR_SHMOO_LP4_RD_DMI_SHMOO_FAILED_EDIS_READ_CHECK, // word 3: 0x00020000
    MEMSYS_ERROR_SHMOO_LP4_RD_DMI_SHMOO_FAILED_FILTER,          // word 3: 0x00040000
    MEMSYS_ERROR_SHMOO_LP4_RD_DMI_SHMOO_FAILED_REPORT,          // word 3: 0x00080000
    MEMSYS_ERROR_SHMOO_LP4_RD_DMI_SHMOO_BAD_WINDOW,             // word 3: 0x00100000
    MEMSYS_ERROR_SHMOO_LP4_RD_DQ_SHMOO_EDIS_ERROR,              // word 3: 0x00200000
    MEMSYS_ERROR_SHMOO_LP4_RD_DQ_SHMOO_FAILED_FILTER,           // word 3: 0x00400000
    MEMSYS_ERROR_SHMOO_LP4_RD_DQ_SHMOO_FAILED_REPORT,           // word 3: 0x00800000
    MEMSYS_ERROR_SHMOO_LP4_WR_DQ_SHMOO_EDIS_ERROR,              // word 3: 0x01000000
    MEMSYS_ERROR_SHMOO_LP4_WR_DQ_SHMOO_FAILED_FILTER,           // word 3: 0x02000000
    MEMSYS_ERROR_SHMOO_LP4_WR_DQ_SHMOO_FAILED_REPORT,           // word 3: 0x04000000
    MEMSYS_ERROR_SHMOO_LP4_WR_WR_SHMOO_BAD_WINDOW,              // word 3: 0x08000000
    MEMSYS_ERROR_SHMOO_LP4_CB_TRAINING_BAD_FINAL_VDL,           // word 3: 0x10000000
    MEMSYS_ERROR_SHMOO_LP4_FAILED_RD_DLY_PATTERN,               // word 3: 0x20000000
    MEMSYS_ERROR_SHMOO_LP4_RD_DLY_NO_MIN_PASS_WINDOW,           // word 3: 0x40000000
    MEMSYS_ERROR_SHMOO_LP4_RD_DLY_FAILED_REPORT,                // word 3: 0x80000000
    MEMSYS_ERROR_OVERALL_MCB_SPD_INCOMPATIBLE,              // word 4: 0x00000001
    MEMSYS_ERROR_SHMOO_RD_DQS_RD_EN_CYCLE_MAXED_OUT,        // word 4: 0x00000002
    MEMSYS_ERROR_SHMOO_RD_DQS_FAILED_DQS_TUNING,            // word 4: 0x00000004
    MEMSYS_ERROR_SHMOO_WR_SHMOO_EXCEEDED_RANGE_LIMIT,       // word 4: 0x00000008
    MEMSYS_ERROR_SHMOO_WR_SHMOO_WIDE_NO_WINDOW,             // word 4: 0x00000010
    MEMSYS_ERROR_OVERALL_INVALID_RANK_COUNT,                // word 4: 0x00000020
    MEMSYS_ERROR_SHMOO_LP4_WR_DMI_SHMOO_BAD_WINDOW,         // word 4: 0x00000040
    MEMSYS_ERROR_SHMOO_ALERT_FAILED_TO_CLEAR,               // word 4: 0x00000080
    MEMSYS_ERROR_OVERALL_UNSUPPORTED_DIMM_TYPE,             // word 4: 0x00000100
    MEMSYS_ERROR_SHMOO_ZERO_OUT_MEMORY_FAILED,              // word 4: 0x00000200
    MEMSYS_ERROR_SHMOO_DB_RD_EN_PHASE_TRAINING_FAILED,      // word 4: 0x00000400
    MEMSYS_ERROR_SHMOO_DB_RD_CYC_TRAINING_FAILED,           // word 4: 0x00000800
    MEMSYS_ERROR_SHMOO_DCPU_IMEM_MISMATCH,                  // word 4: 0x00001000
    MEMSYS_ERROR_SHMOO_DCPU_DMEM_MISMATCH,                  // word 4: 0x00002000
    MEMSYS_ERROR_SHMOO_DCPU_TIMEOUT,                        // word 4: 0x00004000
    MEMSYS_ERROR_SHMOO_LP4_DQS_OSC_INVALID,                 // word 4: 0x00008000

    MEMSYS_ERROR_SHMOO_MAX
} memsys_error_shmoo_e;

/* Number of bits per word */
#define MEMSYS_ERROR_BITS_PER_WORD   (sizeof(unsigned int) * 8)

/* Maximum number of error words needed */
#define MEMSYS_ERROR_MEMC_MAX_WORDS       \
    ((MEMSYS_ERROR_MEMC_MAX / MEMSYS_ERROR_BITS_PER_WORD) + 1)
#define MEMSYS_ERROR_PHY_MAX_WORDS       \
    ((MEMSYS_ERROR_PHY_MAX / MEMSYS_ERROR_BITS_PER_WORD) + 1)
#define MEMSYS_ERROR_SHMOO_MAX_WORDS       \
    ((MEMSYS_ERROR_SHMOO_MAX / MEMSYS_ERROR_BITS_PER_WORD) + 1)

/*
 * Memsys error data structure.
 *   memc  - an array of memc error words, each bit reflects one error code
 *   phy   - an array of phy error words, each bit reflects one error code
 *   shmoo - an array of shmoo error words, each bit reflects one error code
 */
typedef struct memsys_error
{
    unsigned int memc [ MEMSYS_ERROR_MEMC_MAX_WORDS ]; 
    unsigned int phy  [ MEMSYS_ERROR_PHY_MAX_WORDS ]; 
    unsigned int shmoo[ MEMSYS_ERROR_SHMOO_MAX_WORDS ]; 
} memsys_error_t;

/*
 * memsys_top_params_t
 *   Memsys Library top level function parameters
 *
 *   version - Memsys Library version, user should pass in MEMSYS_FW_VERSION.
 *   options - Runtime options and flags. This is a bit field.
 *       See memsys_top_options_e. All other bits not defined are reserved and
 *       should be set to 0. In general, the value 1 does what the option says,
 *       and the value 0 does the opposite of the enum. 
 *   reserved1 - Reserved, set to 0.
 *   mem_test_size_bytes - Memory test size in bytes for Shmoo. Test size
 *       starting at physical memory space as specified by phys_mem_test_base
 *       will be thrashed. The larger the region, the longer Shmoo will run.
 *       Test size should be aligned on 64 bytes boundary. This parameter can
 *       be set to 0 if not running Shmoo.
 *   phys_mem_test_base - Memory test base addresses for Shmoo. These are
 *       specified in MB, with the lowest 20 bits removed. For example, if the
 *       base address is 1MB, then put 1. This is an array of physical
 *       addresses, where the lowest array index is for the first rank. Each
 *       test base specifies the address within each rank.  
 *   phys_memc_reg_base - MEMC register base. This is a physical address.
 *       Memsys Library will directly access this address. This parameter
 *       cannot be 0.
 *   phys_phy_reg_base - PHY register base. This is a physical address.
 *       Memsys Library will directly access this address. This parameter
 *       cannot be 0.
 *   function - See Integration Guide for details.
 *   spd_addr - Physical or virtual address pointing to SPD. Memsys Library
 *       will directly access this address. This parameter should be 0 if
 *       there is no SPD. SPD will be in the endian order per SPD JEDEC spec.
 *   mcb_addr - Physical or virtual address pointing to MCB. Memsys Library
 *       will directly access this address. This parameter cannot be 0.
 *       MCB should be aligned on 32-bit boundary.
 *   saved_state_base - This is a pointer to a physical or virtual address,
 *       where PHY state will be saved. Memsys Library will access this
 *       memory space 32-bits at a time. This should be aligned on 32-bit
 *       boundary. This parameter should be valid if S3 functionality is
 *       required. The size of saved state in bytes is specified by
 *       memsys_get_saved_state_size_bytes().
 *   callbacks - Pointer to system provided helper functions data structure.
 *   error - Memsys error data structure. Memsys Library will fill in this
 *       data structure. 
 */
typedef struct memsys_top_params 
{
    uint32_t version;
    uint32_t options;
    uint32_t reserved1;
    uint32_t mem_test_size_bytes;
    uint32_t phys_mem_test_base[MEMSYS_MAX_RANKS];
    uint32_t phys_memc_reg_base;
    uint32_t phys_phy_reg_base;
    uint32_t * function;
    uint8_t  * spd_addr;
    uint32_t * mcb_addr;
    uint32_t * saved_state_base;
    memsys_system_callbacks_t * callbacks;
    memsys_error_t error;
} memsys_top_params_t;

/* 
 * Generic callback function pointer supplied by user to Memsys Library
 *
 * Params:
 *   memsys_top_params_t * params [IN] -
 *       Pointer to Memsys Library top level function parameters structure. 
 *   void * args [I/O] -
 *       Pointer to data structure used by the function.
 *
 * Returns:
 *   0 - No error.
 *   1 - Error has occured.
 */                      
typedef int (*memsys_user_callback_func)(memsys_top_params_t * params, void * args);
 
/*
 * memsys_flow_control_user_callbacks_t    
 *   User helper functions that are used in Memsys Library flow control
 *
 * All functions shall return 0 on success and 1 on failure unless otherwise
 * noted below.
 *
 * Memsys Library will call memsys_register_flow_control_user_callbacks() to
 * register this data structure. This function shall be provided by the user
 * that supplies these flow control callback functions. The prototype is:
 *     extern int memsys_register_flow_control_user_callbacks(
 *              memsys_flow_control_user_callbacks_t * memsys_flow_cb )
 *
 * fp_memsys_begin - This function is called by Memsys Library after top level
 *     entry, prior to any other flow control stages. This function is optional
 *     and can be set to NULL.
 *
 * fp_pre_memc_init - This function is called by Memsys Library prior to
 *     calling MEMC init. This function is optional and can be set to NULL.
 *
 * fp_memc_init - This is the main MEMC initialization function. If MEMC
 *     init is broken into multiple stages, this should be the main stage.
 *     This function returns a 32bit word, 0 on success, and non-zero on error.
 *     Memsys Library will write the return word into params->error.memc[0].
 *     This is a required function if not using Andover MEMC.
 *
 * fp_pre_shmoo - This function is called by Memsys Library prior to calling
 *     Shmoo. This function is optional and can be set to NULL.
 *
 * fp_memsys_end - This function is called by Memsys Library after all other
 *     flow control stages and prior to the exit of Memsys top level function.
 *     This function is called when MEMSYS HW block has been initialized
 *     correctly without errors. This function is optional and can be set to NULL.
 *
 * fp_disable_dram_refresh - This function is called by Memsys Library during
 *     Shmoo to disable issuing refresh command to DRAM. This function is optional
 *     and can be set to NULL.
 *
 * fp_enable_dram_refresh - This function is called by Memsys Library during
 *     Shmoo to enable issuing refresh command to DRAM. This function is optional
 *     and can be set to NULL.
 *
 * fp_reserved1, fp_reserved2, fp_reserved3 - These functions are reserved.
 *     Set to NULL.
 */
typedef struct memsys_flow_control_user_callbacks
{                              
    memsys_user_callback_func  fp_memsys_begin;
    memsys_user_callback_func  fp_pre_memc_init;
    memsys_user_callback_func  fp_memc_init; // required for non-Andover MEMC
    memsys_user_callback_func  fp_pre_shmoo;
    memsys_user_callback_func  fp_memsys_end;
    
    memsys_user_callback_func  fp_disable_dram_refresh;
    memsys_user_callback_func  fp_enable_dram_refresh;
    
    // the following functions are reserved
    memsys_user_callback_func  fp_reserved1;
    memsys_user_callback_func  fp_reserved2;
    memsys_user_callback_func  fp_reserved3;
    
} memsys_flow_control_user_callbacks_t;

/************************************************************************
 * Function: memsys_get_version
 *   Get Memsys Library version information.
 *
 * Params:
 *   memsys_version_t *version [I/O] -
 *       Pointer to Memsys Library version data structure, allocated by caller.
 *
 * Returns:
 *   0 - No error, data structure is filled.
 *   1 - Error, data inside the structure cannot be used.
 *
 * Notes:
 *   This function may set the strings to NULL to prevent caller from
 *   outputting the version string.
 ************************************************************************/
int memsys_get_version(memsys_version_t * version);

/************************************************************************
 * Function: memsys_get_saved_state_size_bytes
 *   Get the size needed to save PHY state, in number of bytes
 *
 * Params:
 *   None
 *
 * Returns:
 *   Number of bytes needed to save PHY state.
 *   A return value of 0 means saving PHY state is not supported.
 ************************************************************************/
int memsys_get_saved_state_size_bytes();

/************************************************************************
 * Function: memsys_top
 *   Initialize MEMSYS HW block.
 *
 * Params:
 *   memsys_top_params_t *params [I/O] -
 *       Pointer to Memsys Library top level parameters data structure.
 *
 * Returns:
 *   0 - No error.
 *   1 - Error has occured, the memsys_error_t structure inside the params
 *       will be filled in.
 *
 * Notes:
 *   If this function returns non-zero number, error has occurred, and the
 *   caller should print all words in the error structure to console output.
 *   Printing of error codes is required even when the Memsys Library is the
 *   "no print" version.
 *   If MEMSYS_OPTION_WARM_BOOT option is used, PHY state will be recovered
 *   from saved_state_base.
 *   If MEMSYS_OPTION_SAVE_PHY_STATE option is used, PHY state will be saved
 *   to saved_state_base.
 ************************************************************************/
int memsys_top(memsys_top_params_t * params);

#ifdef __cplusplus
} /* extern "C" */
#endif

#endif /* MEMSYS_TOP_API_H__ */

